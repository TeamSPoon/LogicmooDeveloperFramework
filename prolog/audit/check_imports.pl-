:- module(check_imports, []).

:- use_module(library(record_locations)).
:- use_module(library(location_utils)).
:- use_module(library(option_utils)).
:- use_module(library(normalize_head)).

:- multifile
    prolog:message//1.

prolog:message(acheck(imports)) -->
    ['--------------',nl,
     'Unused Imports',nl,
     '--------------',nl,
     'The predicates or modules below has been imported, however', nl,
     'they are never used in the importing module.', nl,
     'If they contain clauses for multifile predicates, you can avoid', nl,
     'this messages by calling use_module/2 with an empty import list,', nl,
     'also, modules that export operators are not reported, nor modules',nl,
     'that do not export any predicates because we assume that they',nl,
     'implement hooks or multifile clauses.', nl,
     'If they cause side effects when loaded, you can refactorize them', nl,
     'so that they are not required anymore.', nl, nl].
prolog:message(acheck(imports, (U/T)-PILocL)) -->
    ['~w have unused ~w:'-[U, T], nl],
    maplist_dcg(unused_import, PILocL).

unused_import(PI/Loc) -->
    Loc,
    [': unused import ~w'-[PI], nl].

:- dynamic
    used_import/1,
    used_usemod/2.

audit:check(imports, Ref, Result, OptionL0 ) :-
    option_allchk(OptionL0, OptionL, FileChk),
    check_imports(Ref, FileChk, OptionL, Result).

:- meta_predicate check_imports(?, ?, +, -).
check_imports(Ref, FileChk, OptionL0, Pairs) :-
    normalize_head(Ref, M:H),
    merge_options(OptionL0,
		  [source(false),
		   infer_meta_predicates(false),
		   autoload(false),
		   evaluate(false),
		   trace_reference(_:H),
		   module_class([user]),
		   on_trace(collect_imports(M, FileChk))
		  ], OptionL),
    prolog_walk_code(OptionL),
    forall(( extra_location(Head, M, goal, _),
	     implementation_module(M:Head, IM)),
	   mark_import(Head, M, IM)),
    findall(warning-((use_module(U)/imports)-((F/A)/Loc)),
	    ( clause(extra_location(Head, M, import(U), From), _, CRef),
	      M \= user,
	      \+ memberchk(Head, [term_expansion(_,_),
				  term_expansion(_,_,_,_),
				  goal_expansion(_,_),
				  goal_expansion(_,_,_,_)
				 ]),
	      \+ used_import(CRef),
	      \+ extra_location(Head, M, goal, _),
	      module_property(M, class(Class)),
	      memberchk(Class, [user]),
	      functor(Head, F, A),
	      from_location(From, Loc)
	    ),
	    Pairs, Tail),
    findall(warning-((module(M)/use_module)-(U/Loc)),
	    ( clause(extra_location(U, M, use_module, From), _, CRef),
	      M \= user,
	      module_property(M, class(Class)),
	      memberchk(Class, [user]),
	      from_to_file(From, File),
	      \+ findall(I, source_file_property(File, included_in(I, _)),
			 [_, _|_]),
	      \+ used_usemod(CRef),
	      from_location(From, Loc)
	    ), Tail),
    cleanup_imports.

collect_imports(M, FileChk, MGoal, _, From) :-
    from_to_file(From, File),
    call(FileChk, File),
    record_location_meta(MGoal, M, From, all_call_refs, mark_import).

mark_import(M:Head, CM, _, _, _, _) :-
    nonvar(M),
    callable(Head),
    mark_import(Head, M, CM).

mark_import(Head, M, CM) :-
    forall(( clause(extra_location(Head, CM, import(_), _), _, CRef),
	     \+ used_import(CRef)),
	   assertz(used_import(CRef))),
    forall(( clause(extra_location(U, CM, use_module, _), _, CRef),
	     absolute_file_name(U, UFile, [file_type(prolog), access(exist),
					   file_errors(fail)]),
	     current_module(UM, UFile),
	     % Here we only check that the predicate was really imported, but
	     % not where the predicate comes from:
	     predicate_property(M:Head, imported_from(_)),
				% Note that we use module_property(_,exports(_))
				% and not predicate_property(_,imported_from(_))
				% due to it reports the actual implementation
				% module and not the reexporting one:
	     ( module_property(UM, exported_operators(OL)),
	       OL \= []
	     ->true
	     ; module_property(UM, exports(EL)),
	       EL \= []
	     ->functor(Head, F, A),
	       memberchk(F/A, EL)
	     ; true
	     ),
	     \+ used_usemod(CRef)),
	   assertz(used_usemod(CRef))).

cleanup_imports :-
    retractall(used_import(_)),
    retractall(used_usemod(_, _)).
