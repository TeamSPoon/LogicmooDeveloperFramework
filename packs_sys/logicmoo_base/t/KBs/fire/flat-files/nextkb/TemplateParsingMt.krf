(in-microtheory TemplateParsingMt)

(isa assertTemplate-Reln ParseTemplatePredicate-Reln)
(isa templateMarkerRepresentation TemplateMarkerObject)
(isa SentenceSubjectIndexical NonAbducibleCollection)
(isa TheGappedTerm TemplateMarkerObject)
(isa RequireSome SetDenotingFunction)
(isa TemplateSemiColonMarker TemplateSententialMarker)
(isa TheActiveSubject SentenceSubjectIndexical)
(isa TemplateSink TemplateMarkerObject)
(isa queryTemplate ParseTemplatePredicate)
(isa TemplateQuestionMarkMarker TemplateSententialMarker)
(isa QuantityFn TemplateMarkerObject)
(isa OptionalOne SetDenotingFunction)
(isa TemplateSingleQuoteMarker TemplateSententialMarker)
(isa commandTemplate ParseTemplatePredicate)
(isa TemplateCommaMarker TemplateSententialMarker)
(isa templateCategoryFillWord TemplateMarkerObject)
(isa TemplateStatementSeparating TemplateMetaAttribute)
(isa templateMarkerAttribute TemplateMarkerObject)
(isa TemplateHyphenMarker TemplateSententialMarker)
(isa assertTemplate ParseTemplatePredicate)
(isa TemplateBacklashMarker TemplateSententialMarker)
(isa OptionalSome SetDenotingFunction)
(isa TemplateCloseBracketMarker TemplateSententialMarker)
(isa termTemplate ParseTemplatePredicate)
(isa metaStatementTemplate-Reln ParseTemplatePredicate-Reln)
(isa TemplateTermAbbreviating TemplateMetaAttribute)
(isa Simply TemplateMarkerObject)
(isa rewriteTemplate ParseTemplatePredicate)
(isa queryTemplate-Test ParseTemplateTestPredicate)
(isa termTemplate-Reln ParseTemplatePredicate-Reln)
(isa TemplatePeriodMarker TemplateSententialMarker)
(isa RequireOne SetDenotingFunction)
(isa HowManyQueryingFn TemplateMarkerObject)
(isa TemplateColonMarker TemplateSententialMarker)
(isa commandTemplate-Reln ParseTemplatePredicate-Reln)
(isa assertTemplate-Test ParseTemplateTestPredicate)
(isa TemplateExclamationMarkMarker TemplateSententialMarker)
(isa queryTemplate-Reln ParseTemplatePredicate-Reln)
(isa VariableFn TemplateMarkerObject)
(isa QuantityVariableFn TemplateMarkerObject)
(isa noTemplateNeeded DocumentationPredicate)
(isa TemplateCloseParenMarker TemplateSententialMarker)
(isa TemplateQuoting TemplateMetaAttribute)
(isa TemplateOpenBracketMarker TemplateSententialMarker)
(isa TemplateDoubleQuoteMarker TemplateSententialMarker)
(isa termTemplate-Test ParseTemplateTestPredicate)
(isa TheSentenceSubject SentenceSubjectIndexical)
(isa TemplateStatementTerminating TemplateMetaAttribute)
(argQuotedIsa assertTemplate-Reln 4 CycLTerm)
(argQuotedIsa noTemplateNeeded 2 SubLString)
(arg4QuotedIsa assertTemplate-Test CycLTerm)
(arg1Genl queryTemplate ParsingTemplateCategory)
(argQuotedIsa queryTemplate 3 CycLTerm)
(argQuotedIsa templateCategoryFillWord 2 SubLString)
(arg4QuotedIsa queryTemplate-Reln CycLTerm)
(arg1Genl commandTemplate ParsingTemplateCategory)
(argQuotedIsa metaStatementTemplate-Reln 4 CycLTerm)
(arg1Genl termTemplate ParsingTemplateCategory)
(arg1QuotedIsa templatePrecedes CycLAssertion)
(arg3QuotedIsa rewriteTemplate CycLTerm)
(argGenl posPredForTemplateCategory 2 ParsingTemplateCategory)
(argGenl TheResultOfParsing 3 ParsingTemplateCategory)
(arg1Genl templateCategoryFillWord ParsingTemplateCategory)
(arg4QuotedIsa assertTemplate-Reln CycLTerm)
(arityMin AssemblePhraseFn 1)
(arg1Genl assertTemplate ParsingTemplateCategory)
(arg2QuotedIsa noTemplateNeeded SubLString)
(argGenl commandTemplate 1 ParsingTemplateCategory)
(argQuotedIsa termTemplate-Test 4 CycLTerm)
(argQuotedIsa semanticTest 1 SubLKeyword)
(arg3QuotedIsa queryTemplate CycLTerm)
(transitiveViaArgInverse posPredForTemplateCategory genlPreds 1)
(argGenl templateCategoryFillWord 1 ParsingTemplateCategory)
(argGenl gapTypeForTemplateCategory 2 ParsingTemplateCategory)
(arg1Genl rewriteTemplate ParsingTemplateCategory)
(argFormat nlPhraseTypeForTemplateCategory 1 SingleEntry)
(arg2QuotedIsa templateCategoryFillWord SubLString)
(argQuotedIsa queryTemplate-Test 4 CycLTerm)
(argGenl termTemplate-Reln 1 ParsingTemplateCategory)
(arg4QuotedIsa metaStatementTemplate-Reln CycLTerm)
(argQuotedIsa termTemplate-Reln 4 CycLTerm)
(argQuotedIsa commandTemplate 3 CycLTerm)
(arg2Genl posPredForTemplateCategory ParsingTemplateCategory)
(argGenl posForTemplateCategory 2 ParsingTemplateCategory)
(arg3Genl TheResultOfParsing ParsingTemplateCategory)
(arg4QuotedIsa termTemplate-Test CycLTerm)
(arg1QuotedIsa semanticTest SubLKeyword)
(argQuotedIsa templatePrecedes 2 CycLAssertion)
(argQuotedIsa assertTemplate 3 CycLTerm)
(arg2Genl gapTypeForTemplateCategory ParsingTemplateCategory)
(arg4QuotedIsa queryTemplate-Test CycLTerm)
(argQuotedIsa templateMarkerRepresentation 2 SubLString)
(argQuotedIsa termTemplate 3 CycLTerm)
(arityMin TheResultOfParsing 2)
(arg3QuotedIsa commandTemplate CycLTerm)
(arityMin RewriteSequenceFn 1)
(arg4QuotedIsa termTemplate-Reln CycLTerm)
(arg2Genl posForTemplateCategory ParsingTemplateCategory)
(argQuotedIsa commandTemplate-Reln 4 CycLTerm)
(argGenl queryTemplate 1 ParsingTemplateCategory)
(argQuotedIsa TheResultOfParsing 4 CycLSentence)
(arg1Genl termTemplate-Reln ParsingTemplateCategory)
(argGenl nlPhraseTypeForTemplateCategory 2 ParsingTemplateCategory)
(arg3QuotedIsa assertTemplate CycLTerm)
(argQuotedIsa gapTypeForTemplateCategory 1 SubLKeyword)
(arg2QuotedIsa templatePrecedes CycLAssertion)
(arg1Genl assertTemplate-Reln ParsingTemplateCategory)
(arg2QuotedIsa templateMarkerRepresentation SubLString)
(argQuotedIsa assertTemplate-Test 4 CycLTerm)
(transitiveViaArgInverse nlPhraseTypeForTemplateCategory genls 1)
(quotedArgument noTemplateNeeded 1)
(arg3QuotedIsa termTemplate CycLTerm)
(argGenl assertTemplate 1 ParsingTemplateCategory)
(argQuotedIsa queryTemplate-Reln 4 CycLTerm)
(arg4QuotedIsa TheResultOfParsing CycLSentence)
(arg4QuotedIsa commandTemplate-Reln CycLTerm)
(argGenl termTemplate 1 ParsingTemplateCategory)
(argGenl assertTemplate-Reln 1 ParsingTemplateCategory)
(arg2Genl nlPhraseTypeForTemplateCategory ParsingTemplateCategory)
(arg1QuotedIsa gapTypeForTemplateCategory SubLKeyword)
(argQuotedIsa templatePrecedes 1 CycLAssertion)
(argQuotedIsa rewriteTemplate 3 CycLTerm)
(argGenl rewriteTemplate 1 ParsingTemplateCategory)
(comment queryTemplate-Test "#$queryTemplate-Test relates a class of natural language questions (e.g. sentences) to CycL.  In addition the slot for the #$Relation (function or pred) that is the focus of the CycL translation, queryTemplate-Test also has a test that must succeed for the template to match.  The test is carried out in #$InferencePSC as a removal-only ask (e.g. no backchaining allowed).   For example, (#$queryTemplate-Test #$STemplate #$objectHasColor ((Be-TheWord Verb) (#$NPTemplate :obj) (#$AdjPTemplate :color)) (#$objectHasColor :obj :color) (#$isa :color #$Color)) would map \"Is Muffet green\" to (#$objectHasColor #$Muffet #$GreenColor), but would not match \"Is Muffet happy?\".")
(comment NLPattern-TermPred "(#$NLTermPredPattern THING SPEECH-PART-PREDICATE) is an alternative form of #$NLTermPattern (q.v.) which focus on a particular #$SpeechPartPredicate. For example, in English, 'got' counts as a match for (#$NLTermPattern #$GivingSomething #$Verb), but not for (#$NLTermPredPattern #$GivingSomething #$tensed).")
(comment TemplateSink "This template marker is a stand-in for eliminating all remaining pieces of a sentence; it will match anything.")
(comment ProgressiveVBarTemplate "The #$ParsingTemplateCategory for phrases headed by a gerund,

 participial, present progressive verb, or any form specified by  

 #$gerund.")
(comment RTPTensedVBarTemplate "#$RTPTensedVBarTemplate is a #$ParsingTemplateCategory which, along with #$RTPUntensedVBarTemplate, can be used for writing \"tense specific\" templates for parsing active voice V-Bar constituents.  In providing coverage for a given construction, it is necessary to assert two different templates of this category: one in which the head verb is specified to have #$presentTense-Generic form, and another in which it is specified to have a #$pastTense-Universal form.(with Cycl translations that differ accordingly).  For more details on how templates for parsing V-Bar constituents should be represented,  see the comments on #$RTPUntensedVBarTemplate, #$RTPActiveVBarTemplate and the #$SharedNoteOnRTPVBarTemplates.")
(comment termTemplate "#$termTemplate relates a class of natural language utterances to CycL terms.  For example, (#$termTemplate #$NPTemplate (\"pictures\" \"of\" (#$NPTemplate :obj)) (#$PicturesFn :obj)) would map \"pictures of The Beatles\" to (#$PicturesFn #$TheBeatles-MusicGroup).")
(comment NLPattern-Word "(#$NLPattern-Word THE-WORD SPEECH-PART) maps a #$LexicalWord to the #$Set-Mathematical of #$CharacterStrings representing all the possible 'one-word' conjugations of that word, restricted to a particular #$SpeechPart. For example, (#$NLPattern-Word #$Sleep-TheWord #$Verb) would (in English) match 'sleep', 'sleeps', 'slept', and so on, but not 'asleep.' It would match 'sleeping', but would only interpret it as a #$presentParticiple, not (ambiguously) as a #$GerundiveNoun. Note that, due to general syntactic pressures, we can only match conjugations resulting from direct assertions on the #$LexicalWord, not compositional conjugations such as the English #$futureTense-Generic (e.g. 'will sleep') wouldn't match. This function is not meant to be used in inference, other than for concluding one type of template from another.")
(comment templateCategoryFillWord "Use this predicate to specify words that are typical fill words in templates of the template category specified.")
(comment NLPattern-Template "(#$NLPattern-Template THE-TEMPLATE KEYWORDP) is essentially an instruction to the NL template parser to recursively match upcoming words to the specified #$ParsingTemplateCategory, returning the binding in the #$SubLKeyword. For example, (#$NLPattern-Template #$NPTemplate :OBJECT) will attempt to parse an NP out of the remainder of the sentence, and if it finds one, will bind the results to :OBJECT. This function is not meant to be used in inference, other than in concluding one type of template from another.")
(comment WordSequence "(#$WordSequence E1 E2 ... En) is used in parsing templates to mean that each of the items in the sequence must match consecutive portions of the input. For example, (#$WordSequence \"means\" \"of\") would only match if \"means of\" were in the input, and would not match for either \"means\" or \"of\" alone. Likewise, (#$WordSequence (#$Kind-TheWord SimpleNoun) \"of\") would match \"kind of\" or \"kinds of\", but would not match \"kind\", \"kinds\", or \"of\".  This function is not meant to be used in inference.")
(comment TemplateSemiColonMarker "The marker used in templates to denote the semi-colon object.")
(comment commandTemplate "#$commandTemplate relates English sentences meant as commands to the #$Addressee to CycL.")
(comment assertTemplate-Test "#$assertTemplate-Test relates a class of natural language statements (e.g. sentences) to CycL.  In addition to the slot for the #$Relation (function or pred) that is the focus of the CycL translation, assertTemplate-Test also has a test that must succeed for the template to match.  For example, (#$assertTemplate-Test #$STemplate #$objectHasColor ((#$NPTemplate :obj) (#$Be-TheWord #$Verb) (#$AdjPTemplate :color)) (#$objectHasColor :obj :color) (#$isa :color #$Color)) would map \"Muffet is green\" to (#$objectHasColor #$Muffet #$GreenColor), but would not match \"Muffet is happy.\".")
(comment TemporalTemplate "The collection of parsing template categories that map to temporal prepositional phrases.")
(comment ListTemplate "The collection of parsing template categories that map to numbers.")
(comment TheResultOfParsing "(#$TheResultOfParsing <string> args) is used in parsing templates to mean that whatever string might mean in this context is to be substituted for the whole functional expession. This function is not meant to be used in inference.")
(comment SinkTemplate "Template category for things that should be ignored (it's used as a sink--things fall in, but they never get back out).  When using this category, the variable that is assigned to it should not be used in the output of the rule.")
(comment TheGappedTerm "This term is a stand-in for whatever the parsing code eventually determines to be the filler for a gap in a wh-question.")
(comment NPTemplate "The collection of parsing template categories that map to individual Cyc terms.")
(comment PercentTemplate "The collection of parsing template categories that map to numeric percentages.  The CycL returned by a #$PercentTemplate takes the form (#$Percent ?NUM) where ?NUM is a #$NonNegativeNumber.")
(comment OptionalOne "(#$OptionalOne E1 E2 ... En) is used in parsing templates to mean that at most one of the the items in this set are allowed in this location of the rule/template.  This function is not meant to be used in inference.")
(comment QuantityTemplate "The collection of parsing template categories that map to quantities, e.g., \"thousands,\" \"lots,\" \"plenty,\" etc.  To write templates that map to actual numbers, use #$NumberTemplate.")
(comment TemplateSententialMarker "The collection of template objects that have sentential significance, such as punctuation indications.")
(comment AdjPTemplate "The collection of parsing template categories that map to adjectival phrases.")
(comment queryTemplate "#$queryTemplate relates a class of natural language queries (e.g. sentences) to CycL.  For example, (#$queryTemplate #$STemplate (\"what color are\" (#$NPTemplate :obj)) (#$colorOfType :obj ?X)) would map \"what color are frogs?\" to (#$colorOfType #$Frog ?X).")
(comment AssemblePhraseFn "(#$AssemblePhraseFn STRING-1 ... STRING-N) denotes a phrase resulting from assembling the strings together into a single string.  This is used in templates that indicate the rewriting of a more complicated sentence into simpler sentences in which eash sentence is assembled from parts of the larger sentence. When writing templates, the only thing that may enclose an #$AssemblePhraseFn term is #$RewriteSequenceFn. Anything else around an #$AssemblePhraseFn term will cause an error in the parser.")
(comment VerbParticipleTemplate "A past participle form of a verb.  This is commonly used in passives that map into event types.")
(comment HowManyQueryingFn "(#$HowManyQueryingFn ?NUM ?VAR COL) is an #$IntermediateVocabTerm generated during the parse of a query.  Through reformulation, it can be used to ask how many instances of COL are known to satisfy the query.")
(comment PerfectiveVBarTemplate "The #$ParsingTemplateCategory for #$perfect v-bars.")
(comment posForTemplateCategory "(#$posForTemplateCategory POS TEMPLATE-CAT) means that the head of a phrase that is of category TEMPLATE-CAT should be a POS.  For example, (#$posForTemplateCategory #$Noun #$NPTemplate) means that #$NPTemplates are typically headed by #$Nouns.")
(comment TemplateStatementTerminating "This template object quality expresses that such template markers can be used in contexts of terminating object sequences that they dominate.")
(comment PresentTenseVBarTemplate "The #$ParsingTemplateCategory for

 parsing verb phrases in the #$presentTense-Generic.")
(comment ParseTemplatePredicate "The group of predicates that provide a map for parsing from strings to CycL via templates.")
(comment PPByTemplate "PP with the word \"by\" in which the semantics of the preposition are ignored.  This is commonly used for by-phrases in passives.")
(comment SentenceSubjectIndexical "The collection of instances of #$IndexicalConcept used in the course of RKF parsing as stand-ins for the subject of a sentence.")
(comment OrdinalTemplate "The collection of parsing template categories that map to ordinal numbers.  The CycL returned by an OrdinalTemplate is an #$Integer.")
(comment TemplateOpenBracketMarker "The marker used in templates to denote the open bracket object.")
(comment RequireSome "(#$RequireSome E1 E2 ... En) is used in parsing templates to mean that at least one item in this set must match a token in the input.  This function is not meant to be used in inference.")
(comment termTemplate-Test "#$termTemplate-Test relates a class of natural language phrases (e.g. noun phrases) to CycL.  In addition to the slot for the #$Relation (function or pred) that is the focus of the CycL translation, termTemplate-Test also has a test that must succeed for the template to match.")
(comment NLPattern-POS "(#$NLPattern-POS KEYWORDP SPEECHPART) is essentially an instruction to the NL template parser to match any word that corresponds to the #$SpeechPart and bind it to the keyword. For example, (#$NLPattern-POS #$MassNoun :MASS) will, in English, match the #$massNumber form of any noun and, if found, bind the string to :MASS. This function is not meant to be used in inference, other than in concluding one type of template from another.")
(comment PPTemporalDurationTemplate "The collection of parsing template categories that map to temporal prepositional phrases of duration.")
(comment TemplateDoubleQuoteMarker "The marker used in templates to denote the double quote object.")
(comment TemplateMarkerObject "The collection of the markers used in the templates for the template parser to denote linguistic and parsing properties.")
(comment TemplateQuoting "The template object quality expressing that these template markers can be used in contexts of quoting the objects that they dominate.")
(comment semanticTest "This predicate is true if the meaning of the keyword is a member of the arg2 set.  Thus, (#$semanticTest :VAR (#$TheSetOf ?X (#$isa ?X #$Horse))) is only true for values of :VAR which denote horses.  This predicate is designed for use in template parsing only, and is not intended to be used in inference.")
(comment TemplateCloseParenMarker "The marker used in templates to denote the close bracket object.")
(comment VBarTemplate "The general #$ParsingTemplateCategory

 for v-bars.")
(comment TheActiveSubject "This template marker is a stand-in for whatever the reformulator code can determine to be the active subject of a sentence with a passive verb phrase parsed by the VP Parser.")
(comment CycConstantTemplate "The collection of parsing template categories designed to enable a user to reference constants by name, e.g., \"# $ doneBy.\"")
(comment NLPattern-Agr "(#$NLPattern-Agr KEYWORDP SPEECHPARTPREDICATE) is essentially an instruction to the NL template parser to match any word that corresponds to the #$SpeechPartPredicate and bind it to the keyword. For example, (#$NLPattern-Agr :INF #$infinitive) will, in English, match the infinitival form of any verb and, if found, bind the string to :INF. This function is not meant to be used in inference, other than in concluding one type of template from another.")
(comment ResultOfConjunctionDecomposition "This function is used to denote the different CycL sentences

that are intended in a single English sentence.  In general, the

English sentence will have one or more conjunctions which lead to the

multiplicity of CycL sentences.  The first argument is the list of conjunctions used, while

the second argument is a list of the meanings produced after

decomposition of any conjoined phrases  The order of items in the arg2

is significant, and should correspond as closely as possible the order

in the original sentence.")
(comment PassiveVBarTemplate "Template for passive VPs (e.g. everything after the 'be' in a passive sentence).")
(comment TemplateExclamationMarkMarker "The marker used in templates to denote the exclamation mark object.")
(comment InfinitivalVPTemplate "This is a ParsingTemplateCategory for VPs in which the head has a infinitival form. In general, these are strings which can serve as the complement to a modal auxillary verb (e.g. CAN, WILL).")
(comment PPTemplate "Template for prepositional phrases.  The semantics of the preposition is frequently bound up with the verb, thereby rendering a generic PP template of little use.  However, PPTemplates are still very useful for rewrites of sentences, since they will match any PP exactly.")
(comment TemplateMetaAttribute "The collection of the meta information attributes that can be encoded within the templates and the marker objects that can occur inside the templates.")
(comment TheSentenceSubject "This template marker is a stand-in for whatever the parsing code can determine to be the grammatical subject of the sentence.")
(comment posPredForTemplateCategory "(#$posPredForTemplateCategory POS-PRED TEMPLATE-CAT) means that the head of a phrase that is of category TEMPLATE-CAT should be be in the POS-PRED.  For example, (#$posForTemplateCategory #$infinitive #$InfinitivalVBarTemplate) means that #$InfinitivalVBarTemplates are typically headed by #$infinitives.")
(comment RTPActiveVBarTemplate "This is the #$ParsingTemplateCategory which should normally be used to specify templates for parsing active voice V-Bar constituents via the RTP. Please note that template assertions on this category should be non-specific wrt. the tense of the main verb.For details on how \"tense specific\" templates may be represented for active voice V-Bar constituents, see the comments on #$RTPTensedVBarTemplate and #$RTPUntensedVBarTemplate, and the #$SharedNoteOnRTPVBarTemplates; for details on templates for passive voice V-Bar constituents, see #$RTPPassiveVBarTemplate.")
(comment TemplatePeriodMarker "The marker used in templates to denote the period object.")
(comment LocationTemplate "The template parsing category for locations. Example: Austin, Texas.")
(comment NBarTemplate "The collection of parsing template categories used to parse

 N-Bars, versus genuine Noun Phrases.")
(comment commandTemplate-Reln "#$commandTemplate-Reln relates English sentences meant as commands to the Cyc system to CycL.  Unlike #$commandTemplate, #$commandTemplate-Reln has a slot for the #$Relation (function or pred) that is the focus of the CycL translation.   For example, (#$commandTemplate-Reln #$STemplate #$CycConceptCreator (\"I\" \"want\" \"to\" \"create\" \"a\" \"concept\" \"called\" (StringTemplate :NEW)) (NLRequestFn StartTool-NLRequest CycConceptCreator (:NEW))) would map \"I want to create a concept called Muffet\" to (NLRequestFn StartTool-NLRequest CycConceptCreator (\"Muffet\")).")
(comment templatePrecedes "This predicate is the means to impose a partial ordering on templates for the template parser.  (#$templatePrecedes ASSERT1 ASSERT2) means that when template parsing, if both ASSERT1 and ASSERT2 are among the templates that will be tried for a given utterance, ASSERT1 should be used before ASSERT2.  Note that this predicate makes it possible to put cycles in the templates, which could cause significant headaches for the template parser.")
(comment termTemplate-Reln "#$termTemplate-Reln relates a class of natural language utterances to CycL terms.  Unlike #$termTemplate, there is a slot for the Cyc #$Relation (function or pred) that is the focus of the CycL translation.  For example, (#$termTemplate #$NPTemplate PicturesFn (\"pictures\" \"of\" (#$NPTemplate :obj)) (#$PicturesFn :obj)) would map \"pictures of The Beatles\" to (#$PicturesFn #$TheBeatles-MusicGroup).")
(comment TemplateColonMarker "The marker used in templates to denote the colon object.")
(comment STemplate-NPGap "This is a #$ParsingTemplateCategory for parsing sentential constituents which contain some NP gap.")
(comment ConjoinedPhrases "This function is used to denote the different phrases that
are conjoined in a phrase.  The first argument is a list of the
conjunctions used to join the pieces, while the second argument is a
list of the conjoined phrases")
(comment ProgressiveVPTemplate "This is a ParsingTemplateCategory for VPs in which the head has a progressive form. In general, these are strings which can serve as the complement to the auxillary (progressive) BE.")
(comment queryTemplate-Reln "#$queryTemplate-Reln relates a class of natural language questions (e.g. sentences) to CycL.  Unlike #$queryTemplate, #$queryTemplate-Reln has a slot for the #$Relation (function or pred) that is the focus of the CycL translation.   For example, (#$queryTemplate-Reln #$STemplate #$objectHasColor (\"what\" \"color\" (Be-TheWord Verb) (#$NPTemplate :obj)) (#$objectHasColor :obj ?X)) would map \"What color is Muffet\" to (#$objectHasColor #$Muffet ?X).")
(comment ScenarioTemplate "The collection of parsing template categories that map to #$ScenarioInstances. ")
(comment RTPPassiveVBarTemplate "This is the #$ParsingTemplateCategory which should be used to specify templates for parsing passive voice V-Bar constituents via the RTP. In general, the head verb (usually the first term in the #$TemplateParsingSyntacticConstraint) for a template assertion on this category should be specified as having a #$passiveParticiple form.

For details on how templates for active voice VBar constituents should be represented, see the comment on #$RTPActiveVBarTemplate; for other information on V-Bar parsing,  see the #$SharedNoteOnRTPVBarTemplates and #$SharedNoteOnVBarParsingTemplateCategories.")
(comment NLPatternList "(#$NLPatternList THING1 THING2 ... THINGN) provides a set of things for the NL template parser to use in a #$ParseTemplatePredicate. For example, given (#$assertTemplate-Reln STemplate #$eatsWillingly (#$NLPatternList (#$NLPattern-Template NPTemplate :SUBJECT) (#$NLPattern-Term #$EatingEvent #$Verb) (#$NLPattern-Template #$NPTemplate :OBJECT)) (#$eatsWillingly :SUBJECT :OBJECT)), if (in English) the parser finds a sentence of the form 'NP1 eats NP2', 'NP1 gobbles NP2', and so on, it will present (#$eatsWillingly NP1 NP2) as a possible parse of the sentence. This function is not meant to be used in inference, other than in concluding one type of template from another.")
(comment SubAtomicParticleTemplate "This template category covers all the expressions that map to #$SubAtomicParticles. This allows us to refine templates that would otherwise be stuck using (#$NPTemplate :ARGX) and therefore firing on all sorts of undesirable input.")
(comment RewriteSequenceFn "(#$RewriteSequenceFn SENTENCE-1 ... SENTENCE-N) denotes the rewriting of several sentences in the given sequence.  This is used in templates that indicate the rewriting of a more complicated sentence into a sequence of several smaller sentences assembled from parts of the larger sentence.  See also #$AssemblePhraseFn.")
(comment PastTenseVBarTemplate "The #$ParsingTemplateCategory for

 parsing verb phrases in the #$pastTense-Universal.")
(comment VariableFn "(#$VariableFn VAR COL) is an #$IntermediateVocabTerm generated during the parse of a query, which denotes an instance INS of COL for which it is true that (PRED ... INS ...), where PRED is the predicate that forms the basis of the query.")
(comment NLPattern-Exact "(#$NLPattern-Exact ITEM1 ... ITEMN) instructs the parser to present a match only if the next sequence of words in the sentence being parsed matches the args to #$NLPattern-Exact exactly. These args can be any combination of #$CharacterStrings, instances of #$NLPattern-Word, and/or instances of #$NLPattern-Term. For example, (#$NLPattern-Exact \"the\" (#$NLPattern-Term (#$HighAmountFn #$Speed)) \"brown\" (#$NLPattern-Word #$Fox-TheWord #$CountNoun)) would match 'the quick brown fox', 'the speedy brown foxes', and so on, but not 'a quick brown fox'.")
(comment templateMarkerRepresentation "Use this predicate to specify the ASCII representation of the template marker objects.")
(comment joinTemplateComponents "The predicate #$joinTemplateComponents can be used in sentence-level templates to piece together components that were identified in other parts of the sentence. Examples include subjects from previous subclauses and the like.")
(comment ParsingTemplateCategory "The collection of parsing template categories.")
(comment NLPattern-Agr "Note that this function should not be expected to handle multi-word conjugations, such as #$futureTense-Generic in English.")
(comment NLPattern-Term-Optional "(#$NLPattern-Term-Optional THE-WORD SPEECH-PART) is a workaround for the fact that you can't put an #$NLPattern-Term inside things like #$WordSequences. Like #$NLPattern-Term, it examines the lexical assertions on a #$CycLConstant and returns all conjugations of all of its lexifications matching a particular #$SpeechPart. For example, (#$NLPattern-Term #$Dog #$Noun) will - in English - match 'dog', 'dogs', 'hounds', 'doggie', and so on, but not conjugations of the verbal forms of those words, such as 'dogged'. However, matching one of those conjugations is not required for the #$NLPatternList to fire on a string. This function is not meant to be used in inference, other than in concluding one type of template from another.")
(comment RTPUntensedVBarTemplate "This is the #$ParsingTemplateCategory for VBar constituents which are i) expected to be parsed by the RTP, and ii)  untensed but still in the active voice.")
(comment ParseTemplateTestPredicate "The collection of predicates that provide a map for parsing from strings to CycL via templates.  These predicates all include a test argument that is run as a removal-only ask in #$InferencePSC.  In order for the template to match, the ask of the test must succeed.")
(comment QuantityVariableFn "(#$QuantityVariableFn VAR COL) is an #$IntermediateVocabTerm generated during the parse of a query, which denotes a the number of instances (INS) of COL for which it is true that (PRED ... INS ...), where PRED is the predicate that forms the basis of the query.")
(comment ActiveVBarTemplate-NPGap "This is a #$ParsingTemplateCategory for parsing active voice VBar-level constituents which contain some NP gap.")
(comment RatioTemplate "The collection of parsing template categories that map to ratios.")
(comment Simply "This template marker is used whenever a complex template expression simplifies to a single fort and the formalism requires an expression.")
(comment TemplateTermAbbreviating "This template object quality expresses that such template markers can be used in contexts of abbreviating the objects that they dominate.")
(comment TemplateCommaMarker "The marker used in templates to denote the comma object.")
(comment metaStatementTemplate-Reln "#$metaStatementTemplate-Reln relates English sentences meant as commands to the Cyc system to CycL.   For example, (#$metaStatementTemplate-Reln #$ResponseTemplate #$Affirmative-NLResponse (\"Yes\") (NLResponseFn Affirmative-NLResponse)) would map \"Yes\" to (NLResponseFn Affirmative-NLResponse).")
(comment NLPattern-Term "(#$NLPattern-Term THE-WORD SPEECH-PART) examines the lexical assertions on a #$CycLConstant and returns all conjugations of all of its lexifications matching a particular #$SpeechPart. For example, (#$NLPattern-Term #$Dog #$Noun) will - in English - match 'dog', 'dogs', 'hounds', 'doggie', and so on, but not conjugations of the verbal forms of those words, such as 'dogged'. As with #$NLPattern-Word, we don't match conjugations that require additional words, so 'will eat' doesn't match (#$NLPattern-Term #$EatingEvent #$futureTense-Generic). This function is not meant to be used in inference, other than in concluding one type of template from another.")
(comment TemplateCloseBracketMarker "The marker used in templates to denote the close bracket object.")
(comment AdjPTemplate-Predicative "The collection of parsing template categories that map to predicative adjectival phrases (i.e. those that can be used in a sentence of the form \"X is Adj-Pred.\", like \"Bill Clinton is happy.\").  This category has special code support within the template parser to prevent gerunds from matching this category.")
(comment ParserMadLibsFn "(#$ParserMadLibsFn SENTENCE N (a #$PositiveInteger)) evaluates to the set of (SYNTAX SEMANTICS) pairs returned by calling (rtp-madlibs-generate SENTENCE N). The set will be empty if the #$ELSentence-Assertible's arg0 doesn't #$genlPreds to #$assertTemplate-Reln or #$queryTemplate-Reln.")
(comment VPTemplate-NPGap "This is a #$ParsingTemplateCategory for parsing VP-level constituents which contain some NP gap.")
(comment TemplateHyphenMarker "The marker used in templates to denote the hyphen object.")
(comment TemplateBacklashMarker "The marker used in templates to denote the backslash
object.")
(comment NumberTemplate "The collection of parsing template categories that map to numbers.")
(comment templateMarkerAttribute "Use this predicate to specify words that are typical fill words in templates of the template category specified.")
(comment CardinalOrOrdinalTemplate "The collection of parsing template categories that map to numbers.")
(comment TemplateStatementSeparating "The template object quality expressing that these template markers can be used in contexts of separating objects that they dominate.")
(comment GenericQuantityTemplate "This template category covers all the ways one might express #$GenericQuantitys.  This allows us to parse different parts of speech that may be used to express the same CycL semantics.  For example, #$highAmountOf might be expressed by 'high', 'a lot of', 'much', or 'very'.")
(comment STemplate "The collection of parsing template categories that map to natural language sentences.  In general these will map to a GAF containing a predicate and its arguments.")
(comment AdvPTemplate "The collection of parsing template categories that map to adverbial phrases.")
(comment RequireOne "(#$RequireOne E1 E2 ... En) is used in parsing templates to mean that exactly one item in this set must match the input.  This function is not meant to be used in inference.")
(comment noTemplateNeeded "(#$noTemplateNeeded RELATION REASON) says that REASON explains why

 RELATION does not need be the arg3 in an #$assertTemplate-Reln or #$termTemplate-Reln assertion.  For example, (#$noTemplateNeeded #$noTemplateNeeded \"documentation constant\") says that #$noTemplateNeeded does not need a template because it is a documentaton constant.  Keep in mind that #$noTemplateNeeded assertions on RELATION are consistent with there being a need to make an #$assertTemplate or #$termTemplate assertion in which RELATION appears in the output semantics, as there might stll be exotic cases where we need to write a strange template involving RELATION as well as some other 

terms.")
(comment RTPUntensedVBarTemplate "#$RTPUntensedVBarTemplate is a #$ParsingTemplateCategory which, along with #$RTPTensedVBarTemplate, can be used for writing \"tense specific\" templates for parsing active voice V-Bar constituents.  In providing coverage for a given construction, it is necessary to assert a template of this category in which the head verb is specified to have an #$untensed form. For more details on how templates for parsing V-Bar constituents should be represented,  see the comments on #$RTPTensedVBarTemplate, #$RTPActiveVBarTemplate and the #$SharedNoteOnRTPVBarTemplates.")
(comment PPTemporalTemplate "The collection of parsing template categories that map to temporal prepositional phrases.")
(comment TemplateSingleQuoteMarker "The marker used in templates to denote the single quote object.")
(comment rewriteTemplate "#$rewriteTemplate relates a class of natural language utterances to a set of different natural language utterances.  It generally is used to reduce a complicated sentence into several less-complicated sentences.")
(comment gapTypeForTemplateCategory "(#$gapTypeForTemplateCategory :KEYWORD TEMPLATE-CAT) means that the head of a phrase that is of category TEMPLATE-CAT contains a gap of type :KEYWORD. For example, (#$gapTypeForTemplateCategory :NP #$STemplate-NPGap) means that #$STemplate-NPGap constituents contain a gap of type :NP. Gaps are typically found in things like questions and relative clauses.")
(comment joinTemplateVariable "The predicate #$joinTemplateComponents can be used in sentence-level templates to piece together components that were identified in other parts of the sentence. Examples include subjects from previous subclauses and the like.")
(comment assertTemplate-Reln "#$assertTemplate-Reln relates a class of natural language assertions (e.g. sentences) to CycL.  Unlike #$assertTemplate, #$assertTemplate-Reln has a slot for the #$Relation (function or pred) that is the focus of the CycL translation.   For example, (#$assertTemplate-Reln #$STemplate #$objectHasColor ((#$NPTemplate :subj) \"is\" \"colored\" (#$AdjPTemplate :obj)) (#$objectHasColor :subj :obj)) would map \"Muffet is colored strawberry-blonde\" to (#$objectHasColor #$Muffet #$StrawberryBlonde-HairColor), and the template is indexed under Arg2 of #$objectHasColor.")
(comment QuantityFn "(#$QuantityFn VAR COL) is an #$IntermediateVocabTerm, generated during parsing, that denotes the number of instances (INS) of COL for which it is true that (PRED ... INS ...), where PRED is the predicate that forms the basis of the query.")
(comment STemplate-RC "This is a #$ParsingTemplateCategory for parsing sentential constituents which are part of a relative clause.")
(comment nlPhraseTypeForTemplateCategory "(#$nlPhraseTypeForTemplateCategory PHRASE-TYPE TEMPLATE-CAT) means that a phrase that is of category TEMPLATE-CAT should be a phrase of type PHRASE-TYPE.  For example, (#$nlPhraseTypeForTemplateCategory #$NounPhrase #$NPTemplate) means that phrases that correspond to #$NPTemplates are typically #$NounPhrases.")
(comment TemplateQuestionMarkMarker "The marker used in templates to denote the question mark object.")
(comment PassiveVBarTemplate-NPGap "This is a #$ParsingTemplateCategory for parsing passive voice VBar-level constituents which contain some NP gap.")
(comment PerfectiveVPTemplate "This is a ParsingTemplateCategory for VPs in which the head has a perfective form. In general, these are strings which can serve as the complement to the auxillary (perfective) HAVE.")
(comment OptionalSome "(#$OptionalSome E1 E2 ... En) is used in parsing templates to mean that the items in this set are optional in the set context in a rule/template.  This function is not meant to be used in inference.")
(comment TermPOSPair "(#$TermPOSPair TERM POS) is used in parsing templates to match any string that is of speech-part POS on the Cyc Term TERM.  For example, (#$TermPOSPair #$Sleeping #$Verb) matches \"sleep\", \"doze\", etc.  This function is not meant to be used in inference.")
(comment GeopoliticalEntityTemplate "The template parsing category for geopolitical entities. Example: Austin, Texas.")
(comment assertTemplate "#$assertTemplate relates a class of natural language assertions (e.g. sentences) to CycL.  For example, (#$queryTemplate #$STemplate ((#$NPTemplate :subj) \"is\" \"colored\" (#$AdjPTemplate :obj)) (#$hairColor :subj :obj)) would map \"Muffet is colored strawberry-blonde\" to (#$hairColor #$Muffet #$StrawberryBlonde-HairColor).")
(genls PPTemporalDurationTemplate PPTemporalTemplate)
(genls PassiveVBarTemplate VBarTemplate)
(genls PresentTenseVBarTemplate VBarTemplate)
(genls PassiveVBarTemplate-NPGap VBarTemplate)
(genls PerfectiveVPTemplate VPTemplate)
(genls PPTemporalTemplate TemporalTemplate)
(genls RatioTemplate QuantityTemplate)
(genls SubAtomicParticleTemplate NPTemplate)
(genls ActiveVBarTemplate-NPGap VBarTemplate)
(genls SubjectRolePredicate TemplateMarkerObject)
(genls PerfectiveVBarTemplate VBarTemplate)
(genls AdjPTemplate-Predicative AdjPTemplate)
(genls PastTenseVBarTemplate VBarTemplate)
(genls CardinalOrOrdinalTemplate QuantityTemplate)
(genls SentenceSubjectIndexical TemplateMarkerObject)
(genls InfinitivalVPTemplate VPTemplate)
(genls PPByTemplate PPTemplate)
(genls ProgressiveVBarTemplate VBarTemplate)
(genls ParseTemplatePredicate-Reln ParseTemplatePredicate)
(genls ProgressiveVPTemplate VPTemplate)
(genls GenericQuantityTemplate NPTemplate)
(genls ParseTemplateTestPredicate ParseTemplatePredicate)
(genls PossessiveTemplate NPTemplate)
(genls ListTemplate QuantityTemplate)
(genls PPForTemplate PPTemplate)
(genls InfinitivalVBarTemplate VBarTemplate)
(genls QuantityTemplate NPTemplate)
(genls TemplateSententialMarker TemplateMarkerObject)
