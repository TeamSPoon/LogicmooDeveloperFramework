(in-microtheory PlanningVocabularyMt)

(isa preconditionForMethod PlanningKBPredicate)
(isa doIterateOverSet-Internal ComplexActionPredicate)
(isa doIterateOverSet ComplexActionPredicate)
(isa effectOfActionIf-Props PlanningKBPredicate)
(isa sufficientFor-Props PlanningKBPredicate)
(isa preconditionFor-Props PlanningKBPredicate)
(isa effectOfAction-Props PlanningKBPredicate)
(isa methodForAction PlanningKBPredicate)
(argGenl doGetAccessToAccountOfType 1 ComputerAccount)
(arg1Genl (ComplexActionFn (NonDavidsonianPredFn AccessingAComputerAccount (TheList (BinaryRoleTypePredFn accountAccessed)))) ComputerAccount)
(arg1Genl (NonDavidsonianPredFn AccessingAComputerAccount (TheList (BinaryRoleTypePredFn accountAccessed))) ComputerAccount)
(argGenl (NonDavidsonianPredFn AccessingAComputerAccount (TheList (BinaryRoleTypePredFn accountAccessed))) 1 ComputerAccount)
(arg1Genl doGetAccessToAccountOfType ComputerAccount)
(argGenl (ComplexActionFn (NonDavidsonianPredFn AccessingAComputerAccount (TheList (BinaryRoleTypePredFn accountAccessed)))) 1 ComputerAccount)
(arg2QuotedIsa prevents-SitProp CycLSentence-Assertible)
(argQuotedIsa prevents-SitProp 2 CycLSentence-Assertible)
(argGenl (NonDavidsonianPredFn Stealing (TheList toPossessor fromPossessor (BinaryRoleTypePredFn itemsStolen))) 3 SomethingExisting)
(arg2Genl (NonDavidsonianPredFn Buying (TheList toPossessor (BinaryRoleTypePredFn objectOfPossessionTransfer) moneyTransferred)) SomethingExisting)
(argGenl (NonDavidsonianPredFn Buying (TheList toPossessor (BinaryRoleTypePredFn objectOfPossessionTransfer) moneyTransferred)) 2 SomethingExisting)
(arg3Genl (NonDavidsonianPredFn Stealing (TheList toPossessor fromPossessor (BinaryRoleTypePredFn itemsStolen))) SomethingExisting)
(argQuotedIsa doIterateOverSet-Internal 4 CycLSentence-Assertible)
(arg4QuotedIsa doIterateOverSet-Internal CycLSentence-Assertible)
(argQuotedIsa doIterateOverSet 3 CycLSentence-Assertible)
(arg3QuotedIsa doIterateOverSet CycLSentence-Assertible)
(argQuotedIsa planForTask 2 CycLSentence-Assertible)
(arg2QuotedIsa planForTask CycLSentence-Assertible)
(argQuotedIsa planForTask 1 CycLSentence-Assertible)
(arg1QuotedIsa planForTask CycLSentence-Assertible)
(argQuotedIsa doIterateOverSet 1 CycLVariable)
(arg1QuotedIsa doIterateOverSet CycLVariable)
(argQuotedIsa doIterateOverSet-Internal 1 CycLVariable)
(arg1QuotedIsa doIterateOverSet-Internal CycLVariable)
(argGenl developsAilmentConditionInPartType 3 AnimalBodyRegion)
(arg3Genl developsAilmentConditionInPartType AnimalBodyRegion)
(argGenl developsAilmentConditionInPartType 2 AilmentCondition)
(arg2Genl developsAilmentConditionInPartType AilmentCondition)
(argGenl developsAilmentCondition 2 AilmentCondition)
(arg2Genl developsAilmentCondition AilmentCondition)
(comment IdealTimeInterval "An instance of #$IdealTimeInterval is an abstract object having
relations to other instances of #$IdealTimeInterval that mirror temporal
relations between instances of #$TimeInterval.  The relation between instances
of #$IdealTimeInterval and instances of #$TimeInterval can be thought of
as comparable to the relation between physical objects having certain
shapes  and the instances of#$GeometricThing-Abstract corresponding to
those shapes.")
(comment PlanStep "An instance of #$PlanStep is an instance of #$IdealTimeInterval corresponding to a 'step' in an instance of #$Plan.  Such a step is an abstraction from subevents of executions of the plan and serves as an ideal representative of events in a class of events whose membership in the class depends upon their relationships to other events that are subevents of the execution of the plan.  For example, a plan for obtaining milk might be:  (1) drive to the grocery store; (2) buy milk at the grocery store; (3) drive back home with the milk; and (4) put the milk in the refrigerator. This plan has four steps which are temporally ordered, with Step 2 starting after the ending of Step 1, Step 3 starting after the ending of Step 2, and Step 4  starting after the ending of Step 3.  These steps are not events in any actual carrying out of the plan.  There might be many different executions of this plan, in each of which there will be a subevent corresponding to the step of driving to the store.  The step of driving to the store in the plan itself is an abstraction from all the particular drivings to the store that occur in particular executions of the plan.  The temporal relations among the steps of a plan mirror the temporal relations among the corresponding subevents in executions of the plan. ")
(comment planStepSentence "(planStepFormula STEP FORMULA) means that FORMULA is an action
formula characterizing the action represented by STEP.")
(comment stepsInPlan "(#$stepsInPlan PLAN STEPS) means that STEPS is a list of steps for       
carrying out PLAN.")
(comment PlanningKBPredicate "An instance of #$PredicateType.  Instances of this collection are predicates that can be used to form rules and GAFs that are used by the Cyc planner.")
(comment planForTask "A binary predicate which relates instances of #$ELSentence-Assertible to instances of #$ELSentence-Assertible, and a specialization of #$methodForAction. (#$planForTask TASK PLAN) means that executing the steps of PLAN in sequential order is a way of achieving TASK. PLAN is assumed to be a literal with operator #$actionSequence (i.e. with the predicate #$actionSequence in the arg0 position). TASK is assumed to be a literal with #$ComplexActionPredicate as an operator. This predicate has (potentially) code support that calls a planner in the case of the first argument being an open variable, and a plan checker in the fully bound case (cf. #$PlanningDomainMicrotheory).")
(comment doIterateOverSet-Internal "A quaternary complex action predicate. This predicate should be used exclusively 
as a helper decomposition for #$doIterateOverSet.")
(genls IdealTimeInterval TimeInterval)
(genls PlanStep IdealTimeInterval)
(genlPreds planForTask methodForAction)
