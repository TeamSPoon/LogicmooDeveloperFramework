(in-microtheory CoreCycLMt)

(isa ConceptFilterSpecificationFn TernaryFunction)
(isa interArgIsa4-3 WFFConstraintPredicate)
(isa arg1Format WFFConstraintPredicate)
(isa BinaryFunction Collection)
(isa arg2Genl WFFConstraintPredicate)
(isa CBLParametersList Collection)
(isa interArgResultIsaReln WFFConstraintPredicate)
(isa MultiDimensionalUnitOfMeasure Collection)
(isa NonArbitarilyGeneratedCycLDenotationalTerm Collection)
(isa argAndRestGenl WFFConstraintPredicate)
(isa SymmetricBinaryPredicate Collection)
(isa arg5SometimesIsa WFFConstraintPredicate)
(isa CycLNonAtomicTerm-ClosedFunctor Collection)
(isa CycLTruthValueSentence Collection)
(isa September Collection)
(isa arg4Format WFFConstraintPredicate)
(isa QuintaryRelation Collection)
(isa arg4Isa WFFConstraintPredicate)
(isa PartiallyCommutativeRelation Collection)
(isa argAndRestIsa WFFConstraintPredicate)
(isa CycLClosedNonAtomicTerm Collection)
(isa CycLRuleAssertion Collection)
(isa CycLAssertedAssertion Collection)
(isa interArgIsa5-2 WFFConstraintPredicate)
(isa interArgFormat5-3 WFFConstraintPredicate)
(isa QuintaryPredicate Collection)
(isa ConceptFilterSpecificationWithMtFn QuaternaryFunction)
(isa arg5Genl WFFConstraintPredicate)
(isa UnitOfRatio Collection)
(isa expresses Predicate)
(isa CycLDeducedAssertion Collection)
(isa Set-Mathematical Collection)
(isa CycLAssertion Collection)
(isa interArgFormat2-5 WFFConstraintPredicate)
(isa ProblemSolvingCntxt Collection)
(isa arg3Genl WFFConstraintPredicate)
(isa arg4SometimesIsa WFFConstraintPredicate)
(isa ConceptFilterSpecificationWithMtFn ReifiableFunction)
(isa CycLOpenNonAtomicTerm Collection)
(isa interArgFormat3-1 WFFConstraintPredicate)
(isa BookkeepingPredicate Collection)
(isa argGenl WFFConstraintPredicate)
(isa CycLConstant Collection)
(isa interArgFormat5-4 WFFConstraintPredicate)
(isa CycLOpenExpression Collection)
(isa NonHumanCyclist Collection)
(isa interArgIsa4-5 WFFConstraintPredicate)
(isa FactSheetGenerationHeuristicsPredicate Collection)
(isa arg5Format WFFConstraintPredicate)
(isa interArgFormat1-2 WFFConstraintPredicate)
(isa EvaluatableRelation Collection)
(isa December Collection)
(isa specificationForConceptFilterWithMt StrictlyFunctionalPredicate)
(isa ConceptFilterSpecificationFn ReifiableFunction)
(isa ExemptFromFactsInFictionalWorldCollector Collection)
(isa interArgFormat3-2 WFFConstraintPredicate)
(isa CycLClosedDenotationalTerm Collection)
(isa interArgIsa2-4 WFFConstraintPredicate)
(isa CommutativeRelation Collection)
(isa arg3SometimesIsa WFFConstraintPredicate)
(isa MonthOfYearType Collection)
(isa interArgIsa3-5 WFFConstraintPredicate)
(isa CycLExpression-Assertible Collection)
(isa SetOrCollection Collection)
(isa arg2Format WFFConstraintPredicate)
(isa TransitiveBinaryPredicate Collection)
(isa arg2Isa WFFConstraintPredicate)
(isa May Collection)
(isa means Predicate)
(isa CBLParameterValuesList Collection)
(isa DistributingMetaKnowledgePredicate Collection)
(isa interArgIsa3-4 WFFConstraintPredicate)
(isa DocumentationPredicate Collection)
(isa CycLSentence-ClosedPredicate Collection)
(isa interArgIsa3-1 WFFConstraintPredicate)
(isa interArgFormat4-2 WFFConstraintPredicate)
(isa EvaluatableFunction Collection)
(isa ConceptFilterSpecificationFn IndividualDenotingFunction)
(isa CycLNonAtomicTerm-Assertible Collection)
(isa TernaryRelation Collection)
(isa DocumentationConstant Collection)
(isa ScopingRelation Collection)
(isa interArgFormat2-3 WFFConstraintPredicate)
(isa QuaternaryFunction Collection)
(isa CycLPropositionalSentence Collection)
(isa interArgIsa2-3 WFFConstraintPredicate)
(isa List Collection)
(isa CycLAtomicAssertion Collection)
(isa ConceptNodesForTaskTypeFn CollectionDenotingFunction)
(isa interArgFormat1-3 WFFConstraintPredicate)
(isa KnowledgeBase Collection)
(isa QuintaryFunction Collection)
(isa arg5Isa WFFConstraintPredicate)
(isa ArgGenlBinaryPredicate Collection)
(isa TernaryFunction Collection)
(isa ConceptFilterSpecificationWithMtFn IndividualDenotingFunction)
(isa arg1Isa WFFConstraintPredicate)
(isa interArgIsa4-2 WFFConstraintPredicate)
(isa ConceptNodesForTaskTypeFn UnaryFunction)
(isa CycLNonAtomicTerm-Askable Collection)
(isa arg6SometimesIsa WFFConstraintPredicate)
(isa interArgFormat2-2 WFFConstraintPredicate)
(isa DirectedMultigraph Collection)
(isa CycLSentence Collection)
(isa CycLGenericRelationFormula Collection)
(isa CycLOpenFormula Collection)
(isa interArgIsa3-2 WFFConstraintPredicate)
(isa ExceptionPredicate Collection)
(isa TheCollectionOf TotalFunction)
(isa CycLClosedAtomicTerm Collection)
(isa interArgFormat3-4 WFFConstraintPredicate)
(isa January Collection)
(isa QueryModificationStrategyPredicate Collection)
(isa QuaternaryPredicate Collection)
(isa interArgIsa2-5 WFFConstraintPredicate)
(isa ThreeDimensionalUnitOfMeasure Collection)
(isa AntiSymmetricBinaryPredicate Collection)
(isa NonNegativeScalarInterval Collection)
(isa interArgDifferent WFFConstraintPredicate)
(isa TheCollectionOf CollectionDenotingFunction)
(isa July Collection)
(isa specificationForConceptFilter StrictlyFunctionalPredicate)
(isa ArgIsaBinaryPredicate Collection)
(isa interArgResultIsa WFFConstraintPredicate)
(isa IrreflexiveBinaryPredicate Collection)
(isa ScalarInterval Collection)
(isa interArgIsa5-3 WFFConstraintPredicate)
(isa interArgFormat5-2 WFFConstraintPredicate)
(isa resultIsa WFFConstraintPredicate)
(isa HumanCyclist Collection)
(isa arg2QuotedIsa WFFConstraintPredicate)
(isa CycLAtomicSentence Collection)
(isa interArgFormat4-4 WFFConstraintPredicate)
(isa June Collection)
(isa MicrotheoryDesignatingRelation Collection)
(isa Format Collection)
(isa CycLOpenDenotationalTerm Collection)
(isa specificationForConceptFilter QuaternaryPredicate)
(isa interArgFormat4-5 WFFConstraintPredicate)
(isa interArgIsa1-4 WFFConstraintPredicate)
(isa CycLReifiableDenotationalTerm Collection)
(isa TheCollectionOf ReifiableFunction)
(isa ArgTypeTernaryPredicate Collection)
(isa interArgFormat1-4 WFFConstraintPredicate)
(isa interArgFormat4-3 WFFConstraintPredicate)
(isa DocumentationPageExternalURLPredicate Collection)
(isa Integer Collection)
(isa ArgQuotedIsaTernaryPredicate Collection)
(isa interArgResultGenl WFFConstraintPredicate)
(isa AsymmetricBinaryPredicate Collection)
(isa interArgGenl1-2 WFFConstraintPredicate)
(isa ConceptNodesForTaskTypeFn ReifiableFunction)
(isa ArgIsaTernaryPredicate Collection)
(isa CycLRepresentedTerm Collection)
(isa arg3QuotedIsa WFFConstraintPredicate)
(isa interArgFormat3-3 WFFConstraintPredicate)
(isa UnaryFunction Collection)
(isa interArgIsa4-1 WFFConstraintPredicate)
(isa ScalarPointValue Collection)
(isa interestingSpecForTaskType TernaryPredicate)
(isa August Collection)
(isa argIsa WFFConstraintPredicate)
(isa CycLFormula Collection)
(isa OneDimensionalUnitOfMeasure Collection)
(isa CycLDenotationalTerm Collection)
(isa interArgIsa1-3 WFFConstraintPredicate)
(isa UnaryRelation Collection)
(isa specificationForConceptFilterWithMt QuintaryPredicate)
(isa CycLReifiedDenotationalTerm Collection)
(isa interArgFormat2-4 WFFConstraintPredicate)
(isa ScalarNullValue Collection)
(isa interArgIsa WFFConstraintPredicate)
(isa BinaryRelation Collection)
(isa SiblingDisjointCollectionType Collection)
(isa arg1Genl WFFConstraintPredicate)
(isa interArgFormat5-5 WFFConstraintPredicate)
(isa ArgConstraintPredicate Collection)
(isa conceptFilterSpecifications StrictlyFunctionalPredicate)
(isa interArgResultGenlReln WFFConstraintPredicate)
(isa QuaternaryRelation Collection)
(isa interArgResultGenlPred WFFConstraintPredicate)
(isa CycLSentence-Assertible Collection)
(isa Cyclist Collection)
(isa InterArgFormatPredicate Collection)
(isa argSometimesIsa WFFConstraintPredicate)
(isa CycLAtomicTerm Collection)
(isa argIsaArg WFFConstraintPredicate)
(isa CycLRepresentedAtomicTerm Collection)
(isa CycLFormulaicSentence Collection)
(isa interArgIsa1-5 WFFConstraintPredicate)
(isa UnaryPredicate Collection)
(isa interArgFormat4-1 WFFConstraintPredicate)
(isa October Collection)
(isa argFormat WFFConstraintPredicate)
(isa interArgFormat2-1 WFFConstraintPredicate)
(isa argQuotedIsa WFFConstraintPredicate)
(isa CycLNonAtomicReifiedTerm Collection)
(isa arg2SometimesIsa WFFConstraintPredicate)
(isa March Collection)
(isa RealNumber ObjectType)
(isa CycLClosedExpression Collection)
(isa arg5QuotedIsa WFFConstraintPredicate)
(isa ArgGenlQuantityTernaryPredicate Collection)
(isa ZeroDimensionalUnitOfMeasure Collection)
(isa TwoDimensionalUnitOfMeasure Collection)
(isa CycLClosedSentence Collection)
(isa InterArgIsaPredicate Collection)
(isa ReflexiveBinaryPredicate Collection)
(isa interArgIsa5-4 WFFConstraintPredicate)
(isa CycLExpression-Askable Collection)
(isa SiblingDisjointAttributeType Collection)
(isa ArgTypePredicate Collection)
(isa arg3Format WFFConstraintPredicate)
(isa arg4Genl WFFConstraintPredicate)
(isa CollectionDenotingFunction Collection)
(isa AntiTransitiveBinaryPredicate Collection)
(isa interArgFormat3-5 WFFConstraintPredicate)
(isa April Collection)
(isa interArgIsa1-2 WFFConstraintPredicate)
(isa disjointWith WFFConstraintPredicate)
(isa ExistentialQuantifier Collection)
(isa arg1SometimesIsa WFFConstraintPredicate)
(isa HypotheticalContext Collection)
(isa CollectionRelatingFunction Collection)
(isa TheCollectionOf BinaryFunction)
(isa arg6QuotedIsa WFFConstraintPredicate)
(isa ArgGenlTernaryPredicate Collection)
(isa arg4QuotedIsa WFFConstraintPredicate)
(isa CycLClosedAtomicSentence Collection)
(isa ArgTypeBinaryPredicate Collection)
(isa CycLOpenSentence Collection)
(isa interArgIsa5-1 WFFConstraintPredicate)
(isa Multigraph Collection)
(isa interArgFormat5-1 WFFConstraintPredicate)
(isa CycLSentence-Askable Collection)
(isa UnitOfMeasure Collection)
(isa arg3Isa WFFConstraintPredicate)
(isa November Collection)
(isa CycLGAFAssertion Collection)
(isa interArgFormat1-5 WFFConstraintPredicate)
(isa interArgFormat1-1 WFFConstraintPredicate)
(isa interArgIsa2-1 WFFConstraintPredicate)
(isa BinaryPredicate Collection)
(isa ArgGenlQuantityBinaryPredicate Collection)
(isa CycLVariable Collection)
(isa February Collection)
(isa arg1QuotedIsa WFFConstraintPredicate)
(isa CycLNonAtomicTerm Collection)
(isa TernaryPredicate Collection)
(isa AssociativeRelation Collection)
(isa interArgGenl2-1 WFFConstraintPredicate)
(isa CycLClosedFormula Collection)
(isa CycLTerm Collection)
(isa resultGenl WFFConstraintPredicate)
(relationAllInstance arity BinaryRelation 2)
(constrainsArg arg3QuotedIsa 3)
(constrainsArg arg3SometimesIsa 3)
(constrainsArg interArgIsa1-5 5)
(constrainsArg arg5Genl 5)
(implies (and (natFunction ?NAT ?FUNC) (resultGenlArg ?FUNC ?N) (natArgument ?NAT ?N ?COL)) (genls ?NAT ?COL))
(constrainsArg argsIsa 0)
(constrainsArg arg2Isa 2)
(constrainsArg arg4QuotedIsa 4)
(implies (completelyDecidableCollection ?COL) (completeExtentDecidableForValueInArg isa ?COL 2))
(constrainsArg arg4Genl 4)
(constrainsArg interArgIsa1-3 3)
(constrainsArg arg12Isa 12)
(constrainsArg arg5QuotedIsa 5)
(constrainsArg arg2Genl 2)
(constrainsArg arg4Format 4)
(implies (isa ?REL TernaryRelation) (arity ?REL 3))
(constrainsArg interArgIsa2-1 1)
(implies (completeExtentEnumerableForValueInArg isa ?COL 2) (completelyEnumerableCollection ?COL))
(constrainsArg interArgIsa2-5 5)
(implies (and (natFunction ?NAT ?FUNCTION) (resultQuotedIsa ?FUNCTION ?COL)) (quotedIsa ?NAT ?COL))
(constrainsArg arg6QuotedIsa 6)
(constrainsArg arg1Genl 1)
(constrainsArg argsGenl 0)
(constrainsArg arg4SometimesIsa 4)
(implies (and (natFunction ?NAT ?FUNCTION) (resultGenl ?FUNCTION ?COL)) (genls ?NAT ?COL))
(functionalInArgs specificationForConceptFilterWithMt 5)
(constrainsArg arg4Isa 4)
(constrainsArg arg13Isa 13)
(constrainsArg interArgIsa1-2 2)
(constrainsArg arg8Genl 8)
(constrainsArg arg2Format 2)
(constrainsArg interArgIsa3-5 5)
(constrainsArg interArgIsa2-4 4)
(functionalInArgs specificationForConceptFilter 4)
(implies (isa ?REL QuaternaryRelation) (arity ?REL 4))
(constrainsArg interArgIsa5-2 2)
(constrainsArg interArgIsa2-3 3)
(constrainsArg interArgIsa4-1 1)
(constrainsArg arg9Isa 9)
(constrainsArg interArgIsa3-4 4)
(constrainsArg arg1SometimesIsa 1)
(implies (and (natFunction ?NAT ?FUNCTION) (resultIsa ?FUNCTION ?COL)) (isa ?NAT ?COL))
(constrainsArg interArgIsa3-1 1)
(constrainsArg arg5SometimesIsa 5)
(constrainsArg interArgIsa5-1 1)
(constrainsArg arg7Genl 7)
(constrainsArg interArgIsa4-2 2)
(constrainsArg arg6Isa 6)
(constrainsArg arg11Isa 11)
(implies (and (natFunction ?NAT ?FUNC) (isa ?TERM ?INDEP-COL) (natArgument ?NAT ?N ?TERM) (interArgResultIsa ?FUNC ?N ?INDEP-COL ?DEP-COL)) (isa ?NAT ?DEP-COL))
(constrainsArg interArgIsa3-2 2)
(implies (isa ?REL QuintaryRelation) (arity ?REL 5))
(constrainsArg interArgIsa1-4 4)
(constrainsArg arg8Isa 8)
(constrainsArg arg1Format 1)
(constrainsArg arg3Format 3)
(constrainsArg arg5Format 5)
(quotedIsa False CycLTruthValueSentence)
(implies (isa ?REL UnaryRelation) (arity ?REL 1))
(constrainsArg interArgIsa5-3 3)
(constrainsArg arg2SometimesIsa 2)
(constrainsArg arg3Isa 3)
(constrainsArg arg3Genl 3)
(constrainsArg arg6SometimesIsa 6)
(constrainsArg interArgGenl1-2 2)
(constrainsArg arg7Isa 7)
(implies (and (natFunction ?NAT ?FUNC) (resultIsaArg ?FUNC ?N) (natArgument ?NAT ?N ?COL)) (isa ?NAT ?COL))
(genls-SpecDenotesGenlInstances DocumentationPredicate Predicate)
(constrainsArg interArgIsa5-4 4)
(implies (completeExtentDecidableForValueInArg isa ?COL 2) (completelyDecidableCollection ?COL))
(implies (and (isa ?ARG-ISA ArgIsaBinaryPredicate) (constrainsArg ?ARG-ISA ?NUM)) (trueRule (CollectionRuleTemplateFn ArgIsaPredicate) (and (implies (?ARG-ISA ?RELN ?COL) (argIsa ?RELN ?NUM ?COL)) (implies (argIsa ?RELN ?NUM ?COL) (?ARG-ISA ?RELN ?COL)))))
(constrainsArg arg1QuotedIsa 1)
(constrainsArg arg10Isa 10)
(constrainsArg interArgIsa4-3 3)
(constrainsArg arg5Isa 5)
(constrainsArg interArgFormat1-2 2)
(constrainsArg arg6Genl 6)
(quotedIsa True CycLTruthValueSentence)
(implies (isa ?REL BinaryRelation) (arity ?REL 2))
(constrainsArg arg2QuotedIsa 2)
(constrainsArg arg1Isa 1)
(constrainsArg interArgIsa4-5 5)
(implies (completelyEnumerableCollection ?COL) (completeExtentEnumerableForValueInArg isa ?COL 2))
(comment completelyDecidableCollection "A unary #$InferenceCompletenessPredicate (q.v.) that applies to collections.  <code>(#$completelyDecidableCollection COL)</code> means that the #$CycInferenceEngine can determine if any given thing is an instance of <code>COL</code>.  More precisely: for any given instance <code>INST</code> whatsoever (and for no non-instances) of <code>COL</code>, there is a CycL term <code>INST-TERM</code> that denotes <code>INST</code> such that (without using transformations) the Inference Engine, given a query of the form <code>(#$isa INST-TERM COL)</code>, will return the answer <code>#$True</code>.
<p>
For example, the collection #$Integer is completely decidable. Given any integer <code>INT</code>, the Cyc query <code>(#$isa INT #$Integer)</code> -- wherein <code>INT</code> is given its standard base-10 arabic numeral representation -- will come back <code>#$True</code>.
<p>
If <code>COL</code> is completely decidable and Cyc fails to return <code>#$True</code> for some query <code>(#$isa TERM COL)</code>, that fact consitutes a strong argument for the truth of its negation <code>(#$not (#$isa TERM COL))</code>.  But note that it is not a conclusive argument: the normally-reliable \"unique name assumption\" might fail here, and the term <code>TERM</code> could conceivably denote something that Cyc can prove to be an instance of <code>COL</code> only under some <i>other</i> CycL name it has.  For suppose #$Pace's favorite number happens to be 3, but nobody has told that to Cyc.  Cyc can prove the sentence <code>(#$isa 3 #$Integer)</code>; but it might nevertheless fail to prove the equally true sentence
<pre>
  (#$isa (<b>FavoriteNumberOfFn</b> #$Pace) #$Integer) .
</pre>
See also the more specific predicates #$completelyEnumerableCollection and #$completelyAssertedCollection.  And see #$completeExtentDecidable, which applies to #$Predicates.")
(comment constraintsComplete "(#$constraintsComplete QBF) means that all relevant constraints regarding QBF have been asserted into the knowledge base.")
(comment completeExtentAssertedForValueInArg "A ternary #$InferenceCompletenessPredicate and a specialization of #$completeExtentEnumerableForValueInArg (q.v.) that can apply to a predicate and a specified value for a specified argument-place.  (#$completeExtentAssertedForValueInArg PRED VALUE N) means that for every sequence of arguments that PRED holds of and whose Nth member is VALUE, there is an explicit assertion to that effect in the Cyc Knowledge Base.  Thus, if asked a query of the form (PRED ... VALUE ...), where VALUE appears in the Nth argument-position and all of the other positions (>= 1) are filled with variables, the Inference Engine -- simply via lookup of assertions in the KB -- can return an extensionally complete list of binding-sequences for those variables.  That is, for every sequence SEQ in PRED's extension whose Nth member is VALUE (and for nothing else), the returned list contains a sequence of bindings (i.e. CycL terms) whose members denote, pointwise, the members of SEQ excepting VALUE.
<p>
For example, (#$completeExtentAssertedForValueInArg #$hasMembers #$InternationalMonetaryFund 1) holds, as all the members of the International Monetary Fund are asserted to be such in the KB.
<p>
If PRED's extent is completely asserted for VALUE in the Nth argument and a given sequence of bindings <TERM1, ..., TERM(N-1), TERM(N+1), ...> (whose length matches the arity of PRED, if fixed) is not returned for the above query, that fact consitutes a strong argument for the truth of the negation (#$not (PRED TERM1 ... TERM(N-1) VALUE TERM(N+1) ...)).  But note that it is not a conclusive argument: the normally-reliable \"unique name assumption\" might fail here, and a term TERMi could conceivably denote something that Cyc can prove a member of something in the extent of PRED only under some _other_ CycL name it has.  For suppose Pace resides in Texas, but nobody has told that to Cyc.  The KB contains the assertion '(#$cityInState #$CityOfDallasTX #$Texas-State)'; but it might nevertheless fail to contain the equally true sentence '(#$cityInState #$CityOfDallasTX (StateOfResidenceFn #$Pace))'.
<p>
See also #$completeExtentAsserted.")
(comment completeExtentEnumerableViaBackchain "A unary #$InferenceCompletenessPredicate and a specialization of  #$minimizeExtent (qq.v.) that applies to predicates whose entire extents can be enumerated by reference to the transformation rules currently asserted on it.  For example, #$occursDuringHospitalization is #$completeExtentEnumerableViaBackchain in the context of certain medical domain microtheories because the rules on it are sufficient to completely generate its entire extent within those microtheories.")
(comment completeExtentDecidable "A unary #$InferenceCompletenessPredicate (q.v.) that applies to predicates.  <code>(#$completeExtentDecidable PRED)</code> means that the #$CycInferenceEngine can determine if any given sequence of things is in the extent of <code>PRED</code> (see #$relationExtension and #$relationHoldsAmong).  More precisely: for any given n-length sequence <code>SEQ</code> among which <code>PRED</code> holds (and for nothing else), there are CycL terms <code>TERM<sub>1</sub></code>, ..., <code>TERM<sub>N</sub></code> that denote the respective items in <code>SEQ</code> such that (without using transformations) the Inference Engine, given a query of the form <code>(PRED TERM<sub>1</sub> ... TERM<sub>N</sub>)</code>, will return the answer <code>#$True<code>.
<p>
For example, <code>(#$completeExtentDecidable #$integerBetween)</code> holds, as the Inference engine can correctly determine if any given triple of integers is such that the second member is numerically between the first and third.  Conversely, the extent of #$likesAsFriend is not decidable, as many of the friendships in the world are beyond Cyc's ken.
<p>
If <code>PRED</code>'s extent is completely decidable and there are CycL terms <code>TERM<sub>1</sub>, ..., TERM<sub>N</sub></code> such that the sentence <code>(PRED TERM<sub>1</sub> ... TERM<sub>N</sub>)</code> is semantically well-formed but <i>not</i> provable by the Inference Engine, that fact consitutes a strong argument for the truth of its negation <code>(#$not (PRED TERM<sub>1</sub> ... TERM<sub>1</sub>))</code>.  But note that it is not a conclusive argument: the normally-reliable \"unique name assumption\" might fail here, and some <code>TERM<sub>I</sub></code> could conceivably denote something that Cyc can prove to be a member of a sequence in the extent of <code>PRED</code> only under some <i>other</i> CycL name it has.  For suppose #$Pace's favorite number happens to be 3, but nobody has told that to Cyc.  Cyc can prove the sentence <code>(#$integerBetween 1 2 3)</code>; but it might nevertheless fail to prove the equally true sentence
<pre>
  (#$integerBetween 1 2 (FavoriteNumberOfFn #$Pace)) .
</pre>
See also the more specific predicates #$completeExtentEnumerable and #$completeExtentAsserted.  And see #$completelyDecidableCollection.")
(comment collectionCompletelyEnumerableViaBackchain "A unary #$InferenceCompletenessPredicate.  <code>(#$collectionCompletelyEnumerableViaBackchain COL)</code> means that the #$CycInferenceEngine can generate a list of all of (and only) the instances of <code>COL</code> by appeal to isa consequent rules.  For example, in certain medical domain microtheories, #$MazeProcedure-SurgicalProcedure is collectionCompletelyEnumerableViaBackchain because backchaining on its single rule is sufficient to generate all the relevant instances in those microtheories.")
(comment completelyEnumerableCollection "A unary #$InferenceCompletenessPredicate that is a specialization of #$completelyDecidableCollection (qq.v.).  <code>(#$completelyEnumerableCollection COL)</code> means that the #$CycInferenceEngine can generate a list of all of (and only) the instances of <code>COL</code>.  More precisely: given a query of the form <code>(#$isa VAR COL)</code>, the Inference Engine can (without using transformations) return a list of terms -- bindings for the variable <code>VAR</code> -- such that every instance (and no non-instance) of the collection <code>COL</code> is denoted by some binding on the list.
<p>
For example, #$SkolemFunction is a completely enumerable collection.  (But note that #$SkolemFunction does <i>not</i> satisfy the more specialized #$completelyAssertedCollection (q.v.), as most of its instances are only asserted to be instances of one of its specializations, such as #$FixedAritySkolemFunction.)
<p>
See also #$completeExtentEnumerable, which applies to #$Predicates.")
(comment completeExtentEnumerable "A unary #$InferenceCompletenessPredicate and a specialization of #$completeExtentDecidable and #$minimizeExtent (qq.v.) that applies to predicates whose entire extents can be enumerated by the #$CycInferenceEngine.  <code>(#$completeExtentEnumerable PRED)</code> means that the Inference Engine can, without using transformations, generate a list of all of (and only) the sequences of things among which <code>PRED</code> holds (see #$relationExtension and #$relationHoldsAmong).
<p>
For example, (#$completeExtentEnumerable #$assertedSentence) holds, as the Inference Engine could, if asked, list all of the assertions in the Knowledge Base.  Conversely, although the Inference engine could correctly determine if any given CycL sentence is in the extent of #$knownSentence (i.e #$completeExtentDecidable holds of #$knownSentence), it could not generate a list of all CycL sentences in the extent of #$knownSentence.
<p>
The practical import of #$completeExtentEnumerable can be stated more precisely as follows.  Let's say that an N-length sequence of terms \"pointwise-denotes\" an N-length sequence of things just in case each term in the former denotes the corresponding item in the latter.  Suppose <code>(#$completeExtentEnumerable PRED)</code> holds.  If <code>PRED</code> is a #$FixedArityRelation of arity N and <code>VAR1...VARN</code> are N distinct #$CycLVariables, then, given a query of the form <code>(PRED VAR1 ... VARN)</code>, the Inference Engine can, without the use of Transformation Modules, return a list of N-length sequences of terms -- each sequence consisting of bindings for the respective variables <code>VAR1-VARN</code> -- such that every sequence in <code>PRED</code>'s extent (and nothing else) is pointwise-denoted by some term-sequence on the list.   If <code>PRED</code> is a #$VariableArityRelation, it is the same, except the given query should then have the form <code>(PRED . VARS)</code>, and there might be no constant length N shared by all of the term-sequences in the returned list.
<p>
If <code>PRED</code>'s extent is completely enumerable and a given term-sequence <code><TERM-1, ..., TERM-N></code> is <i>not</i> in the list returned for the above query, that fact consitutes a <i>strong argument</i> for the truth of the negation <code>(#$not (PRED TERM-1 ... TERM-N))</code>, assuming that it's semantically well-formed.  But note that it is <i>not a conclusive argument</i>: the normally-reliable \"unique name assumption\" might fail here, and some term <code>TERM-I</code> could conceivably denote something that Cyc can prove to be a member of something in the extent of <code>PRED</code> only under some <i>other</i> CycL name it has.  For suppose #$Pace was also denoted by the (imaginary) CycL term <code>ErasmusCAnderson</code>, but Cyc did not know that #$Pace and Erasmus C. Anderson are the same person.  Cyc will return the term-sequence <<code>#$Pace, #$GeneralCycKE</code>> for the query <code>(#$cyclistPrimaryProject ?X ?Y)</code>; but it might nevertheless <i>fail</i> to return the sequence <<code>ErasmusCAnderson, #$GeneralCycKE</code>>, even though the sentence
<pre>
  (#$cyclistPrimaryProject ErasmusCAnderson #$GeneralCycKE)
</pre>
was in fact true.")
(comment completeExtentEnumerableForArg "A binary #$InferenceCompletenessPredicate (q.v.) that can apply to a predicate and a specified argument-place.  (#$completeExtentEnumerableForArg PRED N) means that, for any given thing ARGN, the #$CycInferenceEngine can enumerate every sequence in the extent of PRED whose Nth item is ARGN (see #$relationExtension and #$relationHoldsAmong).  In practical terms this means that, if asked a query of the form (PRED ... ARGN ...), where all of PRED's argument-places save the Nth are filled with variables, the Inference Engine can return an extensionally complete list of binding-sequences for the other (i.e. non-Nth) arguments.  That is, for every sequence SEQ in PRED's extension whose Nth member is ARGN (and for nothing else), the returned list contains a sequence of bindings (i.e. CycL terms) whose members denote, pointwise, the members of SEQ excepting ARGN.
<p>
For example, (#$completeExtentEnumerableForArg #$cityInState 1) holds: given any city, Cyc can return a list of all the states (i.e. the one state, if any) in which it is located.
<p>
If PRED's extent is completely enumerable for the Nth argument and a given sequence of bindings <TERM1, ..., TERM(N-1), TERM(N+1), ...> (whose length matches the arity of PRED, if fixed) is not returned for the above query, that fact consitutes a strong argument for the truth of the negation (#$not (PRED TERM1 ... TERM(N-1) ARGN TERM(N+1) ...)).  But note that it is not a conclusive argument: the normally-reliable \"unique name assumption\" might fail here, and a term TERMi could conceivably denote something that Cyc can prove a member of a sequence in the extent of PRED only under some _other_ CycL name it has.  For suppose Pace resides in Texas, but nobody has told that to Cyc.  Cyc can return the binding '#$Texas-State' for the query '(#$cityInState #$CityOfDallasTX ?X)'; but it might nevertheless fail to return the equally correct binding '(StateOfResidenceFn #$Pace)'.
<p>
See also #$completeExtentEnumerable and #$completeExtentEnumerableForValueInArg).")
(comment completeExtentDecidableForValueInArg "(#$completeExtentDecidableForValueInArg PRED VALUE ARGNUM) means that when the            #$CycInferenceEngine                                                                                 is asked a closed query of the form (PRED ... VALUE ...) where VALUE appears in the                  ARGNUMth position, either it can prove (PRED ... VALUE ...) without transformation,                  or (#$not (PRED ... VALUE ...)) is true.")
(comment completeExtentEnumerableForArg "(#$completeExtentEnumerableForArg PRED ARGNUM) means that when the #$CycInferenceEngine   is asked a query of the form (PRED ... ARG ...) where ARG is any closed term in the                  ARGNUMth position, it can completely enumerate all possible bindings for the other argument          positions.                                                                                           This means that for any arguments (PRED ... NOT-ARGi ... ARG ... NOT-ARGj) for which the             NOT-ARGs are not a member of the enumerated bindings,                                                (#$not (PRED ... NOT-ARGi ... ARG ... NOT-ARGj)) is true.")
(comment completeExtentEnumerableForValueInArg "A ternary #$InferenceCompletenessPredicate and a specialization of #$completeExtentDecidableForValueInArg (q.v.) that can apply to a predicate and a specified value for a specified argument-place.  <code>(#$completeExtentEnumerableForValueInArg PRED VALUE N)</code> means that the #$CycInferenceEngine can enumerate every sequence in the extent of <code>PRED</code> whose <code>N</code>th item is <code>VALUE</code>.  In practical terms this means that, if asked a query of the form <code>(PRED ... VALUE ...)</code>, where <code>VALUE</code> appears in the <code>N</code>th argument-position and all of the other positions (>= 1) are filled with variables, the Inference Engine can return an extensionally complete list of binding-sequences for those variables.  That is, for every sequence <code>SEQ</code> in <code>PRED</code>'s extension whose <code>N</code>th member is <code>VALUE</code> (and for nothing else), the returned list contains a sequence of bindings (i.e. CycL terms) whose members denote, pointwise, the members of <code>SEQ</code> excepting <code>VALUE</code>.
<p>
For example, (#$completeExtentEnumerableForValueInArg #$hasMembers #$InternationalMonetaryFund 1) holds, as Cyc can enumerate all the members of the International Monetary Fund.
<p>
If PRED's extent is completely enumerable for <code>VALUE</code> in the <code>N</code>th argument and a given sequence of bindings <<code>TERM1</code>, ..., <code>TERM(N-1)</code>, <code>TERM(N+1)</code>, ...> (whose length matches the arity of <code>PRED</code>, if fixed) is <i>not</i> returned for the above query, that fact consitutes a strong argument for the truth of the negation (#$not <code>(PRED TERM1 ... TERM(N-1) VALUE TERM(N+1) ...))</code>.  But note that it is not a conclusive argument: the normally-reliable \"unique name assumption\" might fail here, and a term <code>TERM</code>i could conceivably denote something that Cyc can prove a member of a sequence in the extent of <code>PRED</code> only under some <i>other</i> CycL name it has.  For suppose Pace resides in Texas, but nobody has told that to Cyc.  Cyc can return the binding '#$Texas-State' for the query '(#$cityInState #$CityOfDallasTX ?X)'; but it might nevertheless fail to return the equally correct binding '(StateOfResidenceFn #$Pace)'.
<p>
See also the specialization #$completeExtentAssertedForValueInArg and see #$completeExtentEnumerableForArg.")
(comment completeExtentAsserted "A unary #$InferenceCompletenessPredicate and a specialization of #$completeExtentEnumerable (q.v.) that applies to predicates whose entire extents are explicitly asserted in the Cyc Knowledge Base.  <code>(#$completeExtentAsserted PRED)</code> means that, for every sequence <code><THING1,..., THING<sub>N</sub>></code> that satisfies <code>PRED</code>, <code>(PRED THING1 ... THING<sub>N</sub>)</code> is asserted in the Knowledge Base.  That is, for each such sequence, there are reified CycL terms <code>PRED-NAME</code>, <code>TERM1</code>, ..., <code>TERM<sub>N</sub></code> -- which denote <code>PRED</code>, <code>THING1</code>, ..., <code>THING<sub>N</sub></code>, respectively -- such that the sentence <code>(PRED-NAME TERM1 ... TERM<sub>N</sub>)</code> built from those terms is an assertion in the KB.
<p>
If #$completeExtentAsserted is true of <code>PRED</code>, then the #$CycInferenceEngine, when asked a query of the form <code>(PRED <b>. VARS</b>)</code>, can return a complete set of bindings for the variables in <code>VARS</code> simply via a lookup of assertions in the KB.  By a \"complete set of bindings\" is meant a set of sequences of terms such that, for each sequence <code><THING1, ..., THING<sub>N</sub>></code> in the extent of <code>PRED</code>, there is a corresponding sequence of terms <code><TERM1, ..., TERM<sub>N</sub>></code> returned wherein each <code>TERM<sub>I</sub></code> denotes <code>THING<sub>I</sub></code> (for 1 <= <code>I</code> <= <code>N</code>).
<p>
For example, (#$completeExtentAsserted #$hourOfDayIndex-24Hour) holds.  Thus, the sentence <code>(#$hourOfDayIndex-24Hour #$TimeOfDay-1AM 1)</code> is one of twenty-four similar ground-atomic sentences asserted in the KB.  Conversely, (#$completeExtentAsserted #$argN) does <i>not</i> hold.  Thus, while the Inference Engine could generate the set of all true <code>#$argN</code> based ground-atomic sentences (i.e. #$completeExtentEnumerable holds of #$argN), the members of this set are not all asserted in the KB.
<p>
See also #$completelyAssertedCollection, which applies to collections rather than predicates.")
(comment nonAbducibleWithValueInArg "A ternary predicate that is an instance of #$AbductionConstraintConstant (q.v.) and that can apply to a predicate and a specified value for a specified argument-place. 
<p>
(#$nonAbducibleWithValueInArg PRED VALUE N) means that, if asked a query of the form (PRED ... VALUE ...), where VALUE appears in the Nth argument-position and all of the other positions (>= 1) are filled with variables, the Inference Engine cannot use abduction to hypothesize that any non-abduced terms are legitimate bindings for those variables.
<p>
For example, (#$nonAbducibleWithValueInArg #$hasMembers #$InternationalMonetaryFund 1) holds, so Cyc cannot use abduction to hypothesize that Sealand is a member of the IMF.  (Note that this does not mean that Cyc cannot prove that some abduced term is a member of the IMF.)")
(comment completelyAssertedCollection "A unary #$InferenceCompletenessPredicate that is a specialization of #$completelyEnumerableCollection (qq.v.).  <code>(#$completelyAssertedCollection COL)</code> means that, for every instance <code>INST</code> whatsoever of the collection <code>COL</code>, there is an assertion in the Cyc Knowledge Base of the form <code>(#$isa INST COL)</code>.  This requires, of course, that for every instance of <code>COL</code> there be a reified CycL term that denotes it.  
<p>
For example, <code>(#$completelyAssertedCollection #$DayOfWeekType)</code> holds because there are seven assertions of the form <code>(#$isa INST #$DayOfWeekType)</code> in the KB, one for each day of the week (viz. #$Monday, #$Tuesday, etc.). 
<p>
Note, however, that if one reified a specialization of #$DayOfWeekType called <i>DayOfWeekendType</i>, and edited the #$isa assertions on #$Saturday and #$Sunday so that they referenced the latter collection instead of the former, then #$DayOfWeekType would no longer be a #$completelyAssertedCollection (though it would still be a completely-enumerable one).")
(comment completeByNature "An instance of #$CompletenessGroundsPredicate (q.v.) that is used to state, about a collection or predicate whose extent is inferentiallly complete (see #$InferenceCompletenessPredicate), that the completeness derives mainly from the nature of the collection or predicate itself (or the nature of the items in its extent), rather than from any conventional stipulation. For example, (#$completelyDecidableCollection #$Integer) holds, and so does (#$completeByNature #$Integer). In contrast, #$completeByNature does <i>not</i> hold of the completely-asserted collection #$DayOfWeekType. Cf. #$completeByConvention.")
(genls TernaryPredicate TernaryRelation)
(genlPreds completeExtentEnumerableViaBackchain minimizeExtent)
(genls CycLClosedNonAtomicTerm CycLNonAtomicTerm)
(genls CycLGenericRelationFormula CycLFormula)
(genlPreds completeExtentEnumerableForValueInArg nonAbducibleWithValueInArg)
(genls CycLAtomicSentence CycLFormulaicSentence)
(genls CycLClosedAtomicSentence CycLClosedFormulaicSentence)
(genls ArgGenlQuantityBinaryPredicate ArgTypeBinaryPredicate)
(genls NonArbitarilyGeneratedCycLDenotationalTerm CycLReifiableDenotationalTerm)
(genls CycLDenotationalTerm CycLTerm)
(genls HypotheticalContext Microtheory)
(genls CycLClosedAtomicSentence CycLAtomicSentence)
(genls AssociativeRelation Relation)
(genls ArgTypePredicate ArgConstraintPredicate)
(genls CycLNonAtomicTerm-Assertible CycLNonAtomicTerm-Askable)
(genls CycLPropositionalSentence CycLClosedSentence)
(genls ScopingRelation Relation)
(genls CycLTruthValueSentence CycLClosedSentence)
(genls CycLClosedSentence CycLSentence-ClosedPredicate)
(genls ScalarPointValue ScalarInterval)
(genls EvaluatableFunction EvaluatableRelation)
(genls EvaluatableRelation Relation)
(genls CycLDenotationalTerm CycLExpression)
(genls CycLClosedExpression CycLTerm)
(genls CycLAssertedAssertion CycLAssertion)
(genls CycLAtomicAssertion CycLAssertion)
(genlPreds completeExtentAssertedForValueInArg completeExtentEnumerableForValueInArg)
(genls CommutativeRelation Relation)
(genls TransitiveBinaryPredicate BinaryPredicate)
(genls HumanCyclist Cyclist)
(genls CycLClosedNonAtomicTerm CycLClosedDenotationalTerm)
(genls CycLGAFAssertion CycLClosedAtomicSentence)
(genls CycLAtomicSentence CycLSentence)
(genls QueryModificationStrategyPredicate Predicate)
(genls UnaryPredicate UnaryRelation)
(genls CycLClosedAtomicTerm CycLClosedDenotationalTerm)
(genls AsymmetricBinaryPredicate AntiSymmetricBinaryPredicate)
(genls ArgIsaTernaryPredicate ArgTypeTernaryPredicate)
(genls CycLNonAtomicTerm CycLFormula)
(genls QuintaryFunction QuintaryRelation)
(genls CycLNonAtomicReifiedTerm CycLClosedNonAtomicTerm)
(genls CycLExpression-Assertible CycLExpression-Askable)
(genls CycLClosedDenotationalTerm CycLDenotationalTerm)
(genls BinaryPredicate FixedArityRelation)
(genls NonArbitarilyGeneratedCycLDenotationalTerm CycLClosedAtomicTerm)
(genls UnaryPredicate Predicate)
(genls CycLClosedFormula CycLFormula)
(genls CycLOpenSentence CycLFormulaicSentence)
(genls CycLOpenDenotationalTerm CycLDenotationalTerm)
(genls CycLVariable CycLAtomicTerm)
(genls AntiTransitiveBinaryPredicate IrreflexiveBinaryPredicate)
(genls CycLExpression CycLTerm)
(genls RealNumber ScalarPointValue)
(genls ArgTypeTernaryPredicate TernaryPredicate)
(genls ArgIsaBinaryPredicate ArgTypeBinaryPredicate)
(genls MicrotheoryDesignatingRelation Relation)
(genls AsymmetricBinaryPredicate IrreflexiveBinaryPredicate)
(genls SetOrCollection Thing)
(genls CycLOpenExpression CycLTerm)
(genls BookkeepingPredicate Predicate)
(genls ArgQuotedIsaBinaryPredicate ArgTypeBinaryPredicate)
(genls UnaryFunction Function-Denotational)
(genls QuintaryFunction Function-Denotational)
(genls CycLSentence-Assertible CycLExpression-Assertible)
(genls SymmetricBinaryPredicate BinaryPredicate)
(genls CycLExpression-Askable CycLExpression)
(genls SymmetricBinaryPredicate CommutativeRelation)
(genls CollectionDenotingFunction Function-Denotational)
(genls QuaternaryFunction Function-Denotational)
(genls TernaryRelation FixedArityRelation)
(genls CycLAtomicTerm CycLDenotationalTerm)
(genls CycLVariable CycLRepresentedAtomicTerm)
(genls CycLConstant CycLReifiableDenotationalTerm)
(genls UnaryRelation FixedArityRelation)
(genls CycLSentence-Askable CycLSentence)
(genls CycLRepresentedTerm CycLDenotationalTerm)
(genls CycLSentence-Assertible CycLSentence-Askable)
(genls IrreflexiveBinaryPredicate BinaryPredicate)
(genls CycLGAFAssertion CycLAtomicAssertion)
(genls CycLRepresentedAtomicTerm CycLRepresentedTerm)
(genls CycLConstant CycLReifiedDenotationalTerm)
(genlPreds completelyAssertedCollection completelyEnumerableCollection)
(genls CycLReifiableDenotationalTerm CycLClosedDenotationalTerm)
(genlPreds completeExtentAsserted completeExtentEnumerable)
(genls BinaryPredicate Predicate)
(genls ArgGenlTernaryPredicate ArgTypeTernaryPredicate)
(genls NonArbitarilyGeneratedCycLDenotationalTerm CycLReifiedDenotationalTerm)
(genls QuintaryPredicate QuintaryRelation)
(genls CollectionRelatingFunction Function-Denotational)
(genls CycLNonAtomicTerm-ClosedFunctor CycLNonAtomicTerm)
(genls QuasiTransitiveBinaryPredicate BinaryPredicate)
(genls CycLNonAtomicTerm-Askable CycLExpression-Askable)
(genls CycLSentence CycLTerm)
(genls ArgGenlBinaryPredicate ArgTypeBinaryPredicate)
(genls CycLNonAtomicTerm CycLDenotationalTerm)
(genlPreds completeExtentEnumerable minimizeExtent)
(genls DirectedMultigraph Multigraph)
(genls CycLOpenFormula CycLFormula)
(genls CycLOpenNonAtomicTerm CycLOpenDenotationalTerm)
(genls ArgQuotedIsaTernaryPredicate ArgTypeTernaryPredicate)
(genls PartiallyCommutativeRelation Relation)
(genls DocumentationConstant CycLConstant)
(genls CycLFormulaicSentence CycLSentence)
(genls QuaternaryPredicate QuaternaryRelation)
(genls CycLTerm CycLExpression)
(genls Collection SetOrCollection)
(genls CycLFormula CycLTerm)
(genls InterArgFormatPredicate TernaryPredicate)
(genls CycLDeducedAssertion CycLAssertion)
(genlPreds completeExtentEnumerableForValueInArg completeExtentDecidableForValueInArg)
(genls QuintaryRelation FixedArityRelation)
(genls ArgTypeTernaryPredicate ArgTypePredicate)
(genls CycLFormula CycLExpression)
(genls CycLClosedFormula CycLClosedExpression)
(genls NonNegativeScalarInterval ScalarInterval)
(genls CycLPropositionalSentence CycLSentence-Askable)
(genls QuaternaryRelation FixedArityRelation)
(genls CycLClosedExpression CycLExpression)
(genls ReflexiveBinaryPredicate BinaryPredicate)
(genls ArgTypeBinaryPredicate BinaryPredicate)
(genls PositiveInteger Integer)
(genls CycLOpenExpression CycLExpression)
(genls ArgGenlQuantityTernaryPredicate ArgTypeTernaryPredicate)
(genls QuaternaryPredicate Predicate)
(genls CycLNonAtomicTerm CycLRepresentedTerm)
(genls CycLClosedNonAtomicTerm CycLNonAtomicTerm-ClosedFunctor)
(genls CycLSentence CycLExpression)
(genls CycLSentence-Askable CycLExpression-Askable)
(genls CycLOpenFormula CycLOpenExpression)
(genlPreds completeExtentEnumerable completeExtentDecidable)
(genls CycLRepresentedAtomicTerm CycLAtomicTerm)
(genls TernaryPredicate Predicate)
(genls CycLClosedAtomicTerm CycLAtomicTerm)
(genls CycLOpenSentence CycLOpenFormula)
(genls CycLAtomicAssertion CycLAtomicSentence)
(genls CycLOpenDenotationalTerm CycLOpenExpression)
(genls CycLOpenNonAtomicTerm CycLNonAtomicTerm)
(genls CycLVariable CycLOpenDenotationalTerm)
(genls CycLOpenNonAtomicTerm CycLOpenFormula)
(genls Set-Mathematical SetOrCollection)
(genls CycLConstant CycLClosedAtomicTerm)
(genls Quantifier ScopingRelation)
(genls CycLAssertion CycLSentence-Assertible)
(genls QuintaryPredicate Predicate)
(genls ExemptFromFactsInFictionalWorldCollector FictionalContext)
(genls ProblemSolvingCntxt Microtheory)
(genls CycLNonAtomicTerm-Assertible CycLExpression-Assertible)
(genls CycLAtomicTerm CycLExpression)
(genls QuaternaryFunction QuaternaryRelation)
(genls EvaluatableFunction Function-Denotational)
(genls TernaryFunction Function-Denotational)
(genls CycLReifiedDenotationalTerm CycLReifiableDenotationalTerm)
(genls CycLConstant CycLRepresentedAtomicTerm)
(genls CycLFormulaicSentence CycLFormula)
(genls BinaryFunction BinaryRelation)
(genls BinaryFunction Function-Denotational)
(genls ArgTypeBinaryPredicate ArgTypePredicate)
(genlPreds completelyEnumerableCollection completelyDecidableCollection)
(genls CycLClosedDenotationalTerm CycLClosedExpression)
(genls CycLNonAtomicReifiedTerm CycLReifiedDenotationalTerm)
(genls CycLOpenSentence CycLSentence)
(genls BinaryRelation FixedArityRelation)
(genls CycLExpression SubLSExpression)
(genls BinaryPredicate BinaryRelation)
(genls CycLSentence-ClosedPredicate CycLSentence)
(genls UnaryFunction UnaryRelation)
(genls TernaryFunction TernaryRelation)
(genls AntiSymmetricBinaryPredicate BinaryPredicate)
(genls CycLRuleAssertion CycLAssertion)
(genls CycLNonAtomicTerm-Askable CycLNonAtomicTerm)
(genls NonNegativeInteger Integer)
(genls ExistentialQuantifier Quantifier)
