;;;
;;; New-shakedown.meld
;;;

(in-microtheory TestPlanMt)
(genlMt TestPlanMt CompanionsMt)
(genlMt CompanionsMt TestPlanMt)

(isa shakedown2 ComplexActionPredicate)
(arity shakedown2 0)

(preconditionForMethod
  (and (currentExecutive ?ex)
       (currentSessionReasoner ?sr)
       (agendaContext ?mt)
       (newUniqueTask task1 ?task1)  ; make a new name of the form (TaskFn task1XXXX)
       (newUniqueTask task2 ?task2)
       (newUniqueTask task2a ?task2a)
       (newUniqueTask task2b ?task2b)
       (newUniqueTask task3 ?task3))
  (methodForAction
    (shakedown2)
    (actionSequence
      (TheList
        (doAnnounce "Expanding shakedown2 into sub-tasks." ())
        (doTell (ist-Information ?mt (assignedTo ?task1 ?ex)))
        (doTell (ist-Information ?mt (assignedTo ?task2 ?sr)))
        (doTell (ist-Information ?mt (assignedTo ?task2a ?sr)))
        (doTell (ist-Information ?mt (assignedTo ?task2b ?sr)))
        (doTell (ist-Information ?mt (assignedTo ?task3 ?ex)))
        (doTell (ist-Information ?mt (subTasks ?task1 ?task2)))
        ;; tasks 2a & 2b are implicitly concurrent:
        (doTell (ist-Information ?mt (subTasks ?task2 ?task2a)))
        (doTell (ist-Information ?mt (subTasks ?task2 ?task2b)))
        (doTell (ist-Information ?mt (startsAfterEndingOf ?task3 ?task1)))
        (doEnqueue ?ex ?task1 (s2Task1))
        (doEnqueue ?sr ?task2 (s2Task2))
        (doEnqueue ?sr ?task2a (s2Task2a))
        (doEnqueue ?sr ?task2b (s2Task2b))
        (doEnqueue ?ex ?task3 (s2Task3))))))


;;; What can it mean to say on the executive that two tasks on the session-reasoner have
;;; a subtask or precedence relation?  What we want is complete transparency with respect
;;; to agent locality.
;;; If task X invokes taskY on a different machine, then Y is intrinsically a subtask
;;; of X.  Y should inform X when it finishes, whether or not X cares.
;;; We can do this because whenever we schedule a task, either locally or remotely,
;;; we can look at the currentAgendaItem slot to see if we're operating in the context
;;; of a task.  We don't need an explicit subTasks relation.  It's nice to have for 
;;; reasoning about, but it isn't necessary for notification.

;;; Precedence ordering is more challenging.  We may state that sibling tasks on 
;;; different agents are sequenced, but how do we know whom to notify upon completion?
;;; If the session reasoner depends on completion of a task on the tickler, we don't
;;; want the executive necessarily involved, yet that's where the assignments and
;;; constraints are written out.  The executive lays out the roadways, but it isn't
;;; the traffic cop.

(isa s2Task1 ComplexActionPredicate)
(arity s2Task1 0)

(preconditionForMethod
  (localAgent ?agent)
  (methodForAction
    (s2Task1)
    (actionSequence
      (TheList
        (doAnnounce "~%s2Task1 running on ~a" (?agent))))))

(isa s2Task2 ComplexActionPredicate)
(arity s2Task2 0)

(preconditionForMethod
  (localAgent ?agent)
  (methodForAction
    (s2Task2)
    (actionSequence
      (TheList
        (doAnnounce "~%s2Task2 running on ~a" (?agent))))))

(isa s2Task2a ComplexActionPredicate)
(arity s2Task2a 0)

(preconditionForMethod
  (localAgent ?agent)
  (methodForAction
    (s2Task2a)
    (actionSequence
      (TheList
        (doAnnounce "~%s2Task2a running on ~a" (?agent))
        (doBusyWaitForUser "Finish 2a?")))))

(isa s2Task2b ComplexActionPredicate)
(arity s2Task2b 0)

(preconditionForMethod
  (localAgent ?agent)
  (methodForAction
    (s2Task2b)
    (actionSequence
      (TheList
        (doAnnounce "~%s2Task2b running on ~a" (?agent))
        (doBusyWaitForUser "Finish 2b?")))))

(isa s2Task3 ComplexActionPredicate)
(arity s2Task3 0)

(preconditionForMethod
  (localAgent ?agent)
  (methodForAction
    (s2Task3)
    (actionSequence
      (TheList
        (doAnnounce "~%s2Task3 running on ~a" (?agent))))))


