The following represents 4 training pairs `InpG#->OutG#`
from ARC shoved onto one grid...```|InpG1  InpG2|
|InpG3  InpG4|
   ^v^v
|OutG1  OutG2|
|OutG3  OutG4|```you then would remove one of the the training pairs like `InpG4->OutG4` and replace the input side with your input side of the testing pair  `EvalI`.  ```|InpG1  InpG2|
|InpG3  EvalI|
   ^v^v
|OutG1  OutG2|
|OutG3  ?Sol?|```From this you want to predict the corresponding sub change in the output side  `?Sol?`   also you can see the  `OutG1` thru `OutG3`  as a sanity check.  i am more or less describing more a NN version than a Transformer version.. i suppose in a transformer the first 7/8ths would be your prompt.. but hell of a long chain ... 25 times 7 to complete the last 25 tokens

%unset_points(AR,B):- 
%  set_local_points(AR,B).
%unset_points(AR,B):- set_local_points(AR,B).


constrain_type(_CheckType,_Grid,G,G):-!.
constrain_type(CheckType,Grid,G,GG):- is_list(G),!,maplist(constrain_type(CheckType,Grid),G,GG).
%constrain_type(CheckType,Grid,G,GG):- is_bg_color(G),constrain_type(CheckType,\+ is_fg_color(GG)),!.
%constrain_type(CheckType,Grid,G,GG):- is_color(G),!,constrain_type(CheckType,G==GG).
constrain_type(CheckType,_Grid,G,GG):- is_bg_color(G), constrain_type(CheckType,G=GG),!.
constrain_type(_CheckType,_Grid,G,G):- is_fg_color(G),!.
constrain_type(CheckType,_Grid,G,GG):- constrain_type(CheckType,G=GG).


/*
expand_color(FG,Was,C,CC):- FG== fg,!,expand_color(C,Was,C,CC).
expand_color(FG,Was,C,CC):- var(C),is_color_no_bgc(FG),!,FG=C.
expand_color(FG,Was,C,CC):- is_color_no_bgc(C),!,CC=C.
expand_color(FG,Was,C,CC):- var(C),is_bgc(FG),!,FG=C.
expand_color(FG,Was,C,CC):- is_bgc(C),!,CC=C.



set_local_points(Points,Grid):-  set_local_points(fg,Points,Grid),!.
set_local_points(_,[],_):-!.
set_local_points(_,_,[]):-!.
set_local_points(C,Obj,Grid):- is_object(Obj), localpoints(Obj,Points),!, set_local_points(C,Points,Grid).
set_local_points(C,Obj,Grid):- is_group(Obj),!, into_grid(Obj,Grid),localpoints(Obj,Points), set_local_points(C,Points,Grid).
set_local_points(C,Obj,Grid):- is_grid(Obj), !, localpoints(Obj,Points),!, set_local_points(C,Points,Grid).

set_local_points(C,[H|T],Grid):- !, set_local_points(C,H,Grid),set_local_points(C,T,Grid).
set_local_points(FG,Point,Grid):- as_hv_point(H,V,C,Point),hv_cg_va lue_or(Grid,Was,H,V,unknown),
   expand_color(FG,Was,C,CC),!,
   must(nb_set_local_point(H,V,CC,Grid)).


   %set_local_points(C,Obj,Grid):- is_grid(Obj), is_grid(Grid), grid_to_grid(C,Obj,Grid)
set_local_points(C,Point,Grid):- throw_missed(set_local_points(C,Point,Grid)).

nb_set_local_point(H,V,C,[]):- break,!.
nb_set_local_point(H,V,C,Obj):- is_group(Obj),!,maplist(nb_set_local_point(H,V,C),Obj).
nb_set_local_point(H,V,C,Obj):- is_object(Obj), get_instance_method(Obj,nb_set_local_point(H,V,C),Method),!,call(Method,Obj,H,V,C).


nb_set_local_point(H,V,C,Obj):- is_object(Obj),!,trace,localpoints(Obj,Points),nb_set_local_point(H,V,C,Points), setq(Obj,localpoints(Points),Res),nop(assertion(same_term(Obj,Res))).

nb_set_local_point(H,V,C, Grid):- maplist(is_cpoint,Grid),!,hv_point(H,V,Point),!, must(nth1(Nth,Grid,_-Point)->nb_set_nth1(Nth,Grid,C-Point);nb_set_insert(Grid,Point)).
nb_set_local_point(H,V,_C,Grid):- maplist(is_nc_point,Grid),!,hv_point(H,V,Point),!, must(nth1(Nth,Grid,Point)->nb_set_nth1(Nth,Grid,Point);nb_set_insert(Grid,Point)).
nb_set_local_point(H,V,C,Obj):-!.
nb_set_local_point(H,V,C,Obj):- throw_missed(nb_set_local_point(H,V,C,Obj)).
*/


object_nb_set_local_point(Obj,LH,LV,C):- object_set_local_point(Obj,LH,LV,C),!.
object_nb_set_local_point(Obj,LH,LV,C):- trace,object_set_local_point(Obj,LH,LV,C).

object_set_local_point(Obj,LH,LV,C):- 
  object_local_to_global_point(Obj,LH,LV,H,V),
  hv_point(H,V,GPoint), hv_point(LH,LV,LPoint), 
 ((
  obtain_prop(Obj,globalpoints(GPoints),NewGPoints),
  (GPoints==[]->NewGPoints=[C-GPoint];NewGPoints=GPoints),
  nb_set_local_point(H,V,C,NewGPoints))),
 ((
  obtain_prop(Obj,localpoints(Points),NewPoints),
  (Points==[]->NewPoints=[C-LPoint];NewPoints=Points),
  nb_set_local_point(LH,LV,C,NewPoints))),
 ((
  obtain_prop(Obj,grid(Grid),Grid),
  nb_set_local_point(LH,LV,C,Grid))),!.


%obtain_prop(Obj,globalpoints(Was),globalpoints(New)):- nth1(N,
obtain_prop(Obj,Was,New):- arg(1,Obj,L), nth1(N,L,Was),nth1(N,L,Found),nb_setarg(1,Found,New).

object_nb_set_global_point(Obj,H,V,C):- object_set_global_point(Obj,H,V,C).
object_set_global_point(Obj,H,V,C):- 
  object_global_to_local_point(H,V,LH,LV),
  object_set_local_point(Obj,LH,LV,C).


object_global_to_local_point(Obj,H,V,LH,LV):- (Obj,OH,OV),
  LH is H - OH + 1, LV is V - OV + 1.

object_local_to_global_point(Obj,H,V,LH,LV):- loc_xy(Obj,OH,OV),
  LH is H + OH - 1, LV is V + OV - 1.




set_global_points(Points,Grid):-  set_global_points(fg,Points,Grid).
set_global_points(_,[],_):-!.
set_global_points(C,Obj,Grid):- is_grid(Obj), !, globalpoints(Obj,Points), set_global_points(C,Points,Grid).
set_global_points(C,[H|T],Grid):- !, set_global_points(C,H,Grid),set_global_points(C,T,Grid).
set_global_points(C,Obj,Grid):- is_object(Obj), globalpoints(Obj,Points),!, set_global_points(C,Points,Grid).
set_global_points(C,Obj,Grid):- is_group(Obj),!, into_grid(Obj,Grid),globalpoints(Obj,Points), set_global_points(C,Points,Grid).
set_global_points(C,Point,Grid):- as_hv_point(H,V,Var,Point), ignore(C=Var), !,nb_set_global_point(H,V,C,Grid).
set_global_points(C,Point,Grid):- throw_missed(set_global_points(C,Point,Grid)).

nb_set_global_point(H,V,C,Grid):- is_grid(Grid),nth1(V,Grid,Row),nb_set_nth1(H,Row,C).
nb_set_global_point(H,V,C,Obj):- is_object(Obj),get_instance_method(Obj,set_global_point(H,V,C),Method),!,call(Method,Obj,H,V,C).
nb_set_global_point(H,V,C,Obj):- is_group(Obj),maplist(nb_set_global_point(H,V,C),Obj).
nb_set_global_point(H,V,C,Obj):- is_object(Obj),globalpoints(Obj,Points),!,nb_set_global_point(H,V,C,Points),
  setq(Obj,globalpoints(Points),Res),nop(assertion(same_term(Obj,Res))).

nb_set_global_point(H,V,_C,Grid):- maplist(is_nc_point,Grid),hv_point(H,V,Point),
  (nth1(Nth,Grid,Point)->nb_set_nth1(Nth,Grid,Point);nb_set_insert(Grid,Point)).
nb_set_global_point(H,V,C,Grid):- maplist(is_cpoint,Grid),hv_point(H,V,Point),
  (nth1(Nth,Grid,_-Point)->nb_set_nth1(Nth,Grid,Point);nb_set_insert(Grid,C-Point)).

nb_set_global_point(H,V,C,Obj):- throw_missed(nb_set_global_point(H,V,C,Obj)).





get_overlaps(NewIndiv1s,Rest,A,B,AR,BR):- 
  select(A,NewIndiv1s,Rest1),
  select(B,Rest1,Rest),
  object_grid(A,AR), object_grid(B,BR).

get_best_overlaps(NewIndiv1s,Rest,A,B,AR,BR):-
  get_overlaps(NewIndiv1s,Rest,A,B,AR,BR), AR==BR,!.
get_best_overlaps(NewIndiv1s,Rest,A,B,AR,BR):-
  get_overlaps(NewIndiv1s,Rest,A,B,AR,BR), 
  show_success(always,confirm_overlap(AR,BR)),!.
get_best_overlaps(NewIndiv1s,Rest,A,B,AR,BR):-
  get_overlaps(NewIndiv1s,Rest,A,B,AR,BR), AR=BR,!.



/*
fix_the_fours(NewIndiv0s,[A,B|Rest]):- 
  predsort(sort_on(colored_pixel_count),NewIndiv0s,NewIndiv1s),
  must_be_free(A),
  get_best_overlaps(NewIndiv1s,Rest,A,B,AR,BR),
  print_side_by_side(AR,BR),
  maplist(fix_the_twos(AR),NewIndiv1s),
  maplist(fix_the_twos(BR),NewIndiv1s),!.
fix_the_fours(IO,IOS):- predsort(sort_on(colored_pixel_count),IO,IOS).
fix_the_twos(AR,B):-
   unset_points(AR,B).
*/




confirm_overlap(AR,BR):- AR==BR,!.
confirm_overlap(AR,BR):- ((\+ \+ BR=[]);(\+ \+ AR=[])),!.
confirm_overlap([A|AR],[B|BR]):-
  confirm_overlap(A,B),!,
  confirm_overlap(AR,BR).




my_call(rot90,Q,Empty):- is_empty_grid(Empty),!,Q=Empty.
my_call(rot90,Q,Arg2):- rot270(Arg2,Q).
my_call(rot180,Q,Arg2):- rot180(Arg2,Q).
my_call(rot270,Q,Arg2):- rot90(Arg2,Q).

cast_votes4([],[]).
cast_votes4([P|PP],[ExpectedQ|VV]):- 
   P=..[F,Arg2],my_call(F,ExpectedQ,Arg2),
   cast_votes4(PP,VV),!.

votes4(Q,Images,Winners):- 
  cast_votes4(Images,Votes),
  tally_some_votes([Q|Votes],Results),
  keep_winners(Results,Winners),!.



keep_winners(Results,Winners):- is_list(Results),maplist(keep_winners,Results,Winners).
keep_winners(W,_):- assertion(ground(W)),fail.
keep_winners(V4-V3-V2-V1,V1):- V1==V2;V1==V3;V1==V4.
keep_winners(V4-V3-V2-V1,V2):- V2==V1;V2==V3;V2==V4.
keep_winners(V4-V3-V2-V1,V3):- V3==V1;V3==V2;V3==V4.
keep_winners(V4-V3-V2-V1,V3):- V4==V1;V4==V2;V4==V3.
keep_winners(V1,V1):- V1 \= (_-_).
keep_winners(W,undecided(W)).

tally_some_votes([I|Images],Q):- 
  tally_votes_list(I,Images,Q).

tally_votes_list(I,[],I).
tally_votes_list(Q,[I|Images],O):-
  tally_votes(Q,I,M),
  tally_votes_list(M,Images,O).

tally_votes(I,V,I):- var(V),!.
tally_votes(I,V,V):- var(I),!.
tally_votes([],I,I):- !.
tally_votes(I,[],I):- !.
tally_votes([I|II],[H|TT],[V|MM]):-  tally_votes(I,H,V),tally_votes(II,TT,MM).
tally_votes(I,V,V-I).


votes_v_h_hv(Q2,Q3,Q1,Q4,Q2R):-     votes4(Q2,[flipV(Q3),flipH(Q1),flipHV(Q4)],Q2R).
votes_90_180_270(CN,CE,CS,CW,CNR):- votes4(CN,[rot90(CE),rot180(CS),rot270(CW)],CNR).

 reassemble(Grid,Repair),
 assemble(Repair,GR).

reassemble(X,X):-!.
reassemble(
   [[Q2,  CN,   Q1],
    [CW,  CC,   CE],
    [Q3,  CS,   Q4]],

  [[Q2R,  CNR,   Q1R],
   [CWR,   CC,   CER],
   [Q3R,  CSR,   Q4R]]):-

 must_det_l((
  votes_v_h_hv(Q2,Q3,Q1,Q4,Q2R),
  votes_v_h_hv(Q1,Q4,Q2,Q3,Q1R),
  votes_v_h_hv(Q3,Q2,Q4,Q1,Q3R),
  votes_v_h_hv(Q4,Q1,Q3,Q2,Q4R),
  votes_90_180_270(CN,CE,CS,CW,CNR),
  votes_90_180_270(CE,CS,CW,CN,CER),
  votes_90_180_270(CS,CW,CN,CE,CSR),
  votes_90_180_270(CW,CN,CE,CS,CWR))).


nb_set_insert(L,E):- arg(2,L,T),(var(T);T==[]),!,nb_setarg(2,L,[E]).
nb_set_insert([_|L],E):-nb_set_insert(L,E).



find_pattern_objects(IndvS1,AllNew):- % stack_check(100),
 must_be_free(AllNew), length(IndvS1,L), L> 70,!,
  dmsg(find_pattern_objects=L),
  into_grid(IndvS1,TempGrid),
  grid_size(TempGrid,H,V),H>5,V>5,
  globalpoints(TempGrid,Points),
  freeze(W,W>8),
  filter_indivs(IndvS1,[mass(W)];[object_shape(rectangluar), object_shape(solid)],KeepIndvS1R),
  length(KeepIndvS1R,KeepIndvS1RLen),
  dmsg(keepIndvS1R=KeepIndvS1RLen),
  globalpoints(KeepIndvS1R,RemovePoints),
  remove_global_points(RemovePoints,Points,Points2),
  points_to_grid(H,V,Points2,NewTempGrid),
  catch(call_with_time_limit(3,grid_to_3x3_objs(NewTempGrid,NewIndiv1s)),_,fail),
  flatten([NewIndiv1s,KeepIndvS1R],AllNew),!.
find_pattern_objects(IndvS1,IndvS1).



/*
assert_IndvS(obj(L)):-
  object_indv_id(obj(L),NamedExampleNum,Iv),
  maplist(assert_IndvS(NamedExampleNum,Iv),L).


globalpoints(NamedExampleNum,Iv,ListOIfColoredPoints).
globalpoint(NamedExampleNum,Iv,Color,Point).
localpoints(NamedExampleNum,Iv,ListOIfColoredPoints).
localpoint(NamedExampleNum,Iv,Color,Point).
shape(NamedExampleNum,Iv,Point).
object_size(NamedExampleNum,Iv,H,V).
object_shape(NamedExampleNum,Iv,ShapName).


assert_IndvS(NamedExampleNum,Iv,P):- P=..[F,List],is_list(List),
  maplist(assert_IndvS_L(NamedExampleNum,Iv,F),List).

assert_IndvS_L(NamedExampleNum,Iv,F),List

assert_IndvS(NamedExampleNum,Iv,P):- P=..[F|Args],
  PP=..[F,NamedExampleNum,Iv|Args],
  assert_IndvS_PP(NamedExampleNum,Iv,PP).
*/

%individuals_common(Reserved,Points,Grid,I):- is_group(Grid),!,I=Grid.
%individuals_common(Reserved,Points,obj(Grid),[obj(Grid)]):-!.


   
:- dynamic(is_group_saved/2).
:- dynamic(reuse_grid_nums/1).


enum_object(S):- is_grid_id(S,_).
enum_object(S):- is_group_saved(_,IndvS),member(S,IndvS).

store_individuals_non_shared(Gridname,Grid):- 
   set_grid_id(Grid,Gridname),
   individuals_non_shared(Grid,IndvS),
   set_named_indivs(Gridname,IndvS).

get_named_indivs(Gridname,IndvS):- 
   is_group_saved(Gridname,IndvS).

set_named_indivs(Gridname,IndvS):- 
   retractall(is_group_saved(Gridname,_)),
   asserta(is_group_saved(Gridname,IndvS)),!.

ensure_individuals_non_shared(Gridname):- is_group_saved(Gridname,_),!.
ensure_individuals_non_shared(Gridname):- is_grid_id(Grid,Gridname),!,
   store_individuals_non_shared(Gridname,Grid),!.
ensure_individuals_non_shared(Gridname):- throw(cannot_find((Gridname))).

:- style_check(+singleton).

grid_shared_with(Gridname*ExampleNum*in,Gridname*ExampleNum*out):-!.
grid_shared_with(Gridname*ExampleNum*out,Gridname*ExampleNum*in):-!.

use_shared_first(W) :- nb_current(grid_shared,W),W\==[],W\==nil.
use_shared_first:- use_shared_first(_).

get_shared_with(IndvS):- use_shared_first(With),
  ensure_individuals_non_shared(With),
  is_group_saved(With,IndvS),!.
get_shared_with([]).


get_unshared(IndvS):- use_shared_first(With),
  grid_shared_with(With,Gridname),
  ensure_individuals_non_shared(Gridname),
  is_group_saved(Gridname,IndvS),!.
get_unshared([]).


unset_nth(I,O):- delq(I,object_indv_id(_,_),O).
set_nth(I,O):- delq(I,object_indv_id(_,_),O).

get_combined(IndvC):- nb_current(test_name_w_type,NamedExampleNum), is_group_saved(NamedExampleNum,IndvC),!.
get_combined(IndvC):- nb_current(test_name_w_type,NamedExampleNum), 
   is_group_saved(NamedExampleNum*in ,IndvS1),
   is_group_saved(NamedExampleNum*out,IndvS2),
   make_combined(IndvS1,IndvS2,IndvC).
get_combined(IndvC):-get_shared_with(IndvS1),get_unshared(IndvS2),make_combined(IndvS1,IndvS2,IndvC).

with_each_indiv(G,I):- individuals(G,I).


individuals(Grid,IndvS):- 
   grid_to_id(Grid,Gridname),
   grid_shared_with(Gridname,With),
   locally(b_setval(grid_shared,With),
            individuals_common(Grid,IndvS)).

individuals_non_shared(Grid,IndvS):- 
   locally(b_setval(grid_shared,nil),
            individuals_common(Grid,IndvS)).



/*
assert_IndvS(obj(L)):-
  object_indv_id(obj(L),NamedExampleNum,Iv),
  maplist(assert_IndvS(NamedExampleNum,Iv),L).


globalpointlist(NamedExampleNum,Iv,ListOIfColoredPoints).
globalpoint(NamedExampleNum,Iv,Color,Point).
localpointlist(NamedExampleNum,Iv,ListOIfColoredPoints).
localpoint(NamedExampleNum,Iv,Color,Point).
localcolorlesspointlist(NamedExampleNum,Iv,Point).
object_size(NamedExampleNum,Iv,H,V).
object_shape(NamedExampleNum,Iv,ShapName).


assert_IndvS(NamedExampleNum,Iv,P):- P=..[F,List],is_list(List),
  maplist(assert_IndvS_L(NamedExampleNum,Iv,F),List).

assert_IndvS_L(NamedExampleNum,Iv,F),List

assert_IndvS(NamedExampleNum,Iv,P):- P=..[F|Args],
  PP=..[F,NamedExampleNum,Iv|Args],
  assert_IndvS_PP(NamedExampleNum,Iv,PP).
*/

individuals_common(Grid,I):- is_objectlist(Grid),!,I=Grid.
individuals_common(obj(Grid),[obj(Grid)]):-!.


maybe_shared_individuals_list(Types,Points,IndvList,Unused):- 
  use_shared_first, mmake,
  get_combined(IndvSC), 
  consume_shared_individual_points(IndvSC,Types,Points,IndvList,Unused).
maybe_shared_individuals_list(_Types,UnusedPoints,[],UnusedPoints):- !.

unraw_inds(IndvS,IndvO):-   
  largest_first(IndvS,Indv1),
  reverse(Indv1,IndvR),
  %test_cond_or(indiv(min(SZ)),1),
  SZ=0,
  check_minsize(SZ,IndvR,Indv),
  unraw_inds2(_,Indv,IndvO),!.

%individuals_list_diamonds(_,Indv,Indv1):-
%  individuals_list(diamonds,ID,Indv,Indv1).


consume_shared_individual_points([],_Types,UnusedPoints,[],UnusedPoints):- !.
consume_shared_individual_points([H|T],Types,Points,[H|IndvList],Unused):-  
  globalpointlist(H,GPoints), remove_gpoints(GPoints,Points,LeftOver),
  consume_shared_individual_points(T,Types,LeftOver,IndvList,Unused).
consume_shared_individual_points([_|T],Types,Points,IndvList,Unused):-  
  consume_shared_individual_points(T,Types,Points,IndvList,Unused).



   

obj1(X,X).

ok_color_with(C,C2):- /* \+ free_cell(C2), */ C==C2.

sameglobalpoints(Points,IndvC,LeftOver,IndvC):-
  globalpointlist(IndvC,GPoints),
  remove_gpoints(GPoints,Points,LeftOver).

remove_gpoints([],Rest,Rest).
remove_gpoints([GPoint|GPoints],Points,Rest):- select(GPoint,Points,Mid),remove_gpoints(GPoints,Mid,Rest).


find_one_individual_from_combined(Types,Points,[Indv1|IndvList],Unused):-
  get_combined(IndvSC),
  maplist(sameglobalpoints(Points,Indv1,LeftOver),IndvSC),
  find_one_individual_from_combined(Types,LeftOver,IndvList,Unused).
find_one_individual_from_combined(_Types,UnusedPoints,[],UnusedPoints).

find_one_individual(Types,Points,Indv,NextScanPoints):- fail,
  use_shared_first,
  find_one_individual_from_combined(Types,Points,Indv,NextScanPoints).

find_one_individual(Types,Points,Indv,NextScanPoints):-
    select(C-HV,Points,Rest), \+ free_cell(C), 
    allow_dirs(Types,Dir),
    adjacent_point_allowed(C,HV,Dir,HV2),select(C2-HV2,Rest,ScanPoints),ok_color_with(C,C2),
  /*  nop((\+ filtered_point(C,HV2), \+ filtered_point(C,HV),
     (\+ is_diag(Dir)-> true ; (turn_left_45(Dir,TR),turn_right_45(Dir,TL),color_of(HV,TL,TLC),color_of(HV,TR,TRC),
      \+ (colors_block_diag(C,TLC,TRC,C2)))))),*/
    all_individuals_near(Types,C,[C-HV,C2-HV2],ScanPoints,NextScanPoints,Indv),
    meets_indiv_criteria(Indv).

color_of(HV,TL,TLC):- t_l:id_cells(_ID,Points), is_adjacent_point(HV,TL,TLHV),member(TLC-TLHV,Points).

colors_block_diag(C,TLC,TRC,_C2):- TLC==TRC, TRC\==0, C \== TRC, \+ free_cell(TRC).

filtered_point(C,HV):- t_l:id_cells(_ID,Points),% select(_-HV,Points,Rest), 
  findall(Dir-HV2,(adjacent_point_allowed(C,HV,Dir,HV2),member(C-HV2,Points)),Used),
  findall(Dir-HV2,(adjacent_disallowed(C,HV,Dir,HV2),member(C-HV2,Points)),Unused),
  shape_has_filtered_use(C,Used,Unused),
  %wdmsg(shape_has_filtered_use(C,HV,Used,Unused)),
  !.

shape_has_filtered_use(_,[],_Unused).
shape_has_filtered_use(C,[_],_):- shape_filter(C,squares),!.

adjacent_groups(C,Grp1,Dir,Grp2):- member(_-P1,Grp1),member(C-P2,Grp2),is_adjacent_point(P1,Dir,P2).
adjacent_point(C,HV,HV2):- adjacent_point_allowed(C,HV,_Dir,HV2).
adjacent_point_allowed(C,HV,Dir,HV2):- is_adjacent_point(HV,Dir,HV2), shape_filter(C,Shape),allow_dir(Shape,DirS),member(Dir,DirS).
adjacent_disallowed(C,HV,Dir,HV2):- is_adjacent_point(HV,Dir,HV2), shape_filter(C,Shape),allow_dir(Shape,DirS), \+ member(Dir,DirS).

allow_dirs(Square,X):- allow_dir(Square,List),member(X,List).
allow_dir(horizs,[e,w]). allow_dir(virtzs,[n,s]). allow_dir(diaguz,[ne,sw]). allow_dir(diagdz,[nw,se]). 
allow_dir(squares,[n,s,e,w]). allow_dir(polygs,[n,s,e,w]).
allow_dir(diamonds,[nw,sw,se,ne]).
%circles, dots, , rays, walls

shape_filter(X,squares):- free_cell(X).
shape_filter(X,polygs):- \+ free_cell(X).


ok_dir(s). ok_dir(e). ok_dir(n). ok_dir(w).
ok_dir(_) :- \+ squares.
squares:-true.


meets_indiv_criteria(_).

all_individuals_near(_Types,_C,NewSet,[],[],[],NewSet):-!.
all_individuals_near(Types,C,Indv,ScanPoints,NewScanPoints,NewSet):-
   individuals_near(Types,C,Indv,ScanPoints,New,NextScanPoints),
   (New == [] -> (NewSet = Indv, NewScanPoints = NextScanPoints)
    ; (append(Indv,New,IndvNew),
        all_individuals_near(Types,C,IndvNew,NextScanPoints,NewScanPoints,NewSet))).

individuals_near(_Types,_C,_From,[],[],[]):-!.
individuals_near(Types,C,From,[E|ScanPoints],[E|Nears],NextScanPoints):- nearby_one(Types,C,E,From),!,
  individuals_near(Types,C,[E|From],ScanPoints,Nears,NextScanPoints).

individuals_near(Types,C,From,[E|ScanPoints],Nears,[E|NextScanPoints]):- 
      individuals_near(Types,C,From,ScanPoints,Nears,NextScanPoints).

nearby_one(Types,C,C2-E,List):- allow_dirs(Types,Dir), adjacent_point_allowed(C,E2,Dir,E), member(C2-E2,List),ok_color_with(C2,C).


check_minsize(Sz,Indv1,Indv):- include(meets_size(Sz),Indv1,Indv).

meets_size(Len,Points):- mass(Points,L),!,L>=Len.

remove_bgs(IndvS,IndvL,BGIndvS):- partition(is_bg_indiv,IndvS,BGIndvS,IndvL).

is_bg_indiv(O):- colors_count(O,[color_count(C,CC)]),CC>0,is_black(C).

smallest_first(IndvS,IndvO):-
  findall(Size-Indv,(member(Indv,IndvS),mass(Indv,Size)),All),
  keysort(All,AllK),
  findall(Indv,member(_-Indv,AllK),IndvO).

largest_first(IndvS,IndvR):-  
  smallest_first(IndvS,IndvO),
  reverse(IndvO,IndvR).

largest_first_nonbg(IndvS,IndvOB):-  
  largest_first(IndvS,IndvO),
  remove_bgs(IndvO,IndvL,BGIndvS),
  append(IndvL,BGIndvS,IndvOB).

finish_grp(C,Grp,Point2,Dir,Rest,NewGroup,RRest):- 
   \+ (is_diag(Dir),is_black(C)),
   is_adjacent_point(Point2,Dir,Point3),
   single_point(C-Point3,Rest,Rest1),
   finish_grp(C,[C-Point3|Grp],Point3,Dir,Rest1,NewGroup,RRest).
finish_grp(_C,Grp,_From,_Dir,Rest,Grp,Rest).


reserved_point(C-Point):- fail, \+ get_shared_with(With), member(Obj,With),
  globalpointlist(Obj,GPoints), \+ (member(CC-Point,GPoints), CC==C).

single_point(C-Point,IndvS,Rest1):-
  single_point0(C-Point,IndvS,Rest1),
   reserved_point(C-Point).

single_point0(C-Point,IndvS,Rest1):-
  select([C-Point],IndvS,Rest1),
  nonvar(C), trace.
single_point0(C-Point,IndvS,Rest1):-
  select(C-Point,IndvS,Rest1),
  nonvar(C), trace.
single_point0(C-Point,IndvS,Rest1):- 
  select(obj(I),IndvS,Rest1), fail, % round 2
  globalpointlist(obj(I),[C-Point]),
  nonvar(C).

/*
unraw_inds2(Types,IndvS,IndvO):- fail,
   largest_first(IndvS,Indv1),
   reverse(Indv1,IndvR), IndvR\=@=IndvS,
   unraw_inds2(Types,IndvR,IndvO).
*/

unraw_inds2(Types,IndvS,IndvO):-   
  single_point(C-Point1,IndvS,Rest1), nonvar(C), % \+ free_cell(C),\+ get_bgc(C),
  is_diag(Dir),
  is_adjacent_point(Point1,Dir,Point2),
  single_point(C-Point2,Rest1,Rest2),
  is_adjacent_point(Point2,Dir,Point3),
  single_point(C-Point3,Rest2,Rest),
  finish_grp(C,[C-Point3,C-Point2,C-Point1],Point3,Dir,Rest,NewGroup1,RRest),
  reverse(NewGroup1,NewGroupR),
  reverse_nav(Dir,RevDir),
  finish_grp(C,NewGroupR,Point1,RevDir,RRest,NewGroup,RRestO),
  unraw_inds2(Types,[NewGroup|RRestO],IndvO).

unraw_inds2(Types,IndvS,IndvO):-  fail,
  single_point(C-Point1,IndvS,Rest1), nonvar(C), \+ free_cell(C),
  single_point(C2-Point2,Rest1,Rest),
  findall(C3-Point3,member([C3-Point3],Rest),CRest),
  subtract(Rest,CRest,IndvM),
  unraw_inds2(Types,IndvM,IndvMO),
  Grp=[C-Point1,C2-Point2|CRest],
  IndvO=[Grp|IndvMO].

unraw_inds2(Types,IndvS,IndvO):- 
  single_point(C-Point1,IndvS,Rest1),
  Grp=[_,C-_,_|_],
  select(Grp,Rest1,Rest),
  is_diag(Dir),
  adjacent_groups(C,[C-Point1],Dir,Grp),
  unraw_inds2(Types,[[C-Point1|Grp]|Rest],IndvO).

/*
unraw_inds2(Types,IndvS,IndvO):-   
  select([C1-Point1],IndvS,Rest),
  nearby_one(Types,C,C1-Point1,Rest),
  select([C-Point2],Rest1,Rest),
  findall(C-Point,member([C-Point],Rest),CRest),
  subtract(Rest,CRest,IndvM),
  unraw_inds2(Types,IndvM,IndvMO),
  Grp=[C-Point1,C-Point2|C-Rest],
  IndvO=[Grp|IndvMO].
*/
unraw_inds2(_,IndvS,IndvS).


:- thread_local(t_l:id_cells/2).

deoffset_points(1,1,Points,Points):-!.
deoffset_points(OH,OV,Point,LPoint):- map_pred(if_point_de_offset(OH,OV),Point,LPoint).
if_point_de_offset(OH,OV,Point,LPoint):- atom(Point), hv_point(H,V,Point),HH is H -OH +1, VV is V - OV +1,hv_point(HH,VV,LPoint).

offset_points(OH,OV,Point,LPoint):- map_pred(if_point_offset(OH,OV),Point,LPoint).
if_point_offset(OH,OV,Point,LPoint):- atom(Point), hv_point(H,V,Point),HH is H +OH -1, VV is V + OV -1,hv_point(HH,VV,LPoint).

grid_to_individual(Grid,OUT):-
  grid_to_id(Grid,GN),
  grid_size(Grid,H,V),
  globalpointlist(Grid,Points),
  embue_points(GN,H,V,1,1,H,V,Points,OUT).

make_embued_points(Grid,H,V,Indv2,IndvS):- 
  grid_to_id(Grid,GN),
  maplist(embue_points(GN,H,V),Indv2,IndvS).

%embue_points(GN,_,_,I,I):-!.
embue_points(_,_,_,obj(Ps),obj(Ps)):-!.
embue_points(GN,H,V,Points,OUT):- 
  points_range(Points,LoH,LoV,HiH,HiV,_HO,_VO),
  embue_points(GN,H,V,LoH,LoV,HiH,HiV,Points,OUT).

embue_points(GN,H,V,LoH,LoV,HiH,HiV,C-HV,OBJ):- !, embue_points(GN,H,V,LoH,LoV,HiH,HiV,[C-HV],OBJ).
embue_points(NamedExampleNum,H,V,LoH,LoV,HiH,HiV,Points,obj(Ps)):-
 assertion(ground(Points)),
 flag(indiv,Iv,Iv+1),
 must_det_l((
  colors_count(Points,CC),
  length(Points,Len),
  Width is HiH-LoH+1,
  Height is HiV-LoV+1,
  %nb_current(test_name_w_type,NamedExampleNum),
  
  %gensym(id_,IID),
  Area is Width * Height,
  Empty is  Area - Len,
  deoffset_points(LoH,LoV,Points,LPoints),
  findall(object_shape(Shape),guess_shape(Ps,Empty,Len,Width,Height,CC,Points,Shape),Shapes),
  remove_color(LPoints,CLPoints),
  append([[
    localcolorlesspointlist(CLPoints),
    colors_count(CC),
    object_size(Width,Height),
    mass(Len)],Shapes,
    %width(Width), height(Height), area(Area),
    %missing(Empty),
    [localpointlist(LPoints)],
    [loc_xy(LoH,LoV)],
    [globalpointlist(Points),
    object_indv_id(NamedExampleNum,Iv),
    grid_size(H,V)]],Ps))).


object_indv_id(I,NamedExampleNum,Iv):- indv_props(I,L),member(object_indv_id(NamedExampleNum,Iv),L),!.
object_indv_id(_,NamedExampleNum,_Iv):- nb_current(test_name_w_type,NamedExampleNum).

mass(_-P,1):- nonvar(P),!.
mass(I,X):- indv_props(I,L),member(mass(X),L),!.
mass(obj(I),Count):- localpointlist(I,Points), length(Points,Count),!.
mass(Points,Count):- is_list(Points),length(Points,Count),!.
remove_color(_-P,P).
remove_color(LPoints,CLPoints):- maplist(remove_color,LPoints,CLPoints).

decl_pt(setq(object,any,object)).

setq(Orig,Todo,Result):- metaq(setq_1,Orig,Todo,Result).
setq_1(_Old,New,Saved):- Saved=New.
delq(Orig,Todo,Result):- metaq(delq_1,Orig,Todo,Result).
delq_1(_Old,_New,Saved):- Saved=delq.


metaq(_,Orig,[],Orig):-!.
metaq(P3,Orig,[New|Todo],Result):- !, metaq(P3,Orig,New,Midway),metaq(P3,Midway,Todo,Result).
metaq(P3,Orig,New,Saved):- functor(New,F,A),functor(Old,F,A),Did=done(nil),map_pred(metaq_1(P3,Did,Old,New),Orig,Saved).
metaq_1(_,done(t),_,_,Orig,Orig):-!.
metaq_1(P3,Did,Old,New,Orig,Saved):- compound(Orig),Orig=Old, call(P3,Old,New,Saved),nb_setarg(1,Did,t).



indv_props(obj(L),L):- is_list(L).
indv_props(obj(L),L):- enum_object(obj(L)).

localpointlist(I,X):- indv_props(I,L),member(localpointlist(X),L).
object_shape(I,X):- indv_props(I,L),member(object_shape(X),L).

hv_cvalue(Grid,Color,H,V):- hv_cg_v alue(Grid,C,H,V),as_cv(C,Color).
as_cv(C,Color):- var(C),color_code(C,Color).
as_cv(C,Color):- integer(C),!,color_code(C,Color).
as_cv(C,Color):- atom(C),!,color_code(C,Color).
as_cv(C-_,Color):- as_cv(C,Color).

globalpointlist(Grid,Points):- is_grid(Grid),!, grid_size(Grid,HH,HV), 
  findall(C-Point,(between(1,HV,V),between(1,HH,H),hv_cvalue(Grid,C,H,V),nonvar(C),hv_point(H,V,Point)),Points),
  assertion(ground(Points)).
%globalpointlist(Grid,Points):- is_object(Grid),!,globalpointlist(Grid,Points).
globalpointlist(Grid,Points):- is_objectlist(Grid),!,maplist(globalpointlist,Grid,MPoints),flatten(MPoints,Points).
globalpointlist(I,X):- indv_props(I,L),member(globalpointlist(X),L).
/*
globalpointlist(ID,Points):- \+ \+ cmem(ID,_,_), findall(-(C,HV),cmem(ID,HV,C),Points).
globalpointlist(Grid,Points):- grid_to_id(Grid,ID),findall(-(C,HV),cmem(ID,HV,C),Points).
:- dynamic(is_grid_id/2).
grid_to_id(Grid,ID):- is_grid_id(Grid,ID),!.
grid_to_id(Grid,ID):- gensym('grid_',ID),assert_id_grid_cells(ID,Grid),assert(is_grid_id(Grid,ID)),!.
*/

colors_count(I,X):- indv_props(I,L),!,member(colors_count(X),L).

colors_count(G,BFO):- pixels(G,GF),sort(GF,GS),count_each(GS,GF,UC),keysort(UC,KS),reverse(KS,SK),into_cc(SK,BFO).

localcolorlesspointlist(I,X):- indv_props(I,L),member(localcolorlesspointlist(X),L).

loc_xy(I,X,Y):- indv_props(I,L),member(loc_xy(X,Y),L).
object_size(I,X,Y):- indv_props(I,L),member(object_size(X,Y),L).
object_size(Points,H,V):- pmember(object_size(H,V),Points),!.
object_size(Points,H,V):- points_range(Points,LoH,LoV,HiH,HiV,_,_), H is HiH-LoH+1, V is HiV-LoV+1.

top(8).

:- style_check(-singleton).
guess_shape(I,Empty,N,1,1,Colors,Points,dot):- !.
guess_shape(I,Empty,N,N,1,Colors,Points,hline).
guess_shape(I,Empty,N,1,N,Colors,Points,vline).
guess_shape(I,Empty,N,H,V,[color_count(Zero,_)],Points,background):- (Zero==0;Zero==black).
guess_shape(I,0,N,HV,HV,Colors,Points,square):- HV>1.
guess_shape(I,0,N,H,V,Colors,Points,solid).
guess_shape(I,O,N,H,V,Colors,Points,nonsolid):- O\==0.

guess_shape(I,E,N,H,V,Colors,Points,subI(InvS)):- E>2, fail,
   once((I.loc_xy=loc_xy(LoH,LoV),
   make_unassigned_grid(H,V,Grid),
   calc_add_points(LoH,LoV,Grid,Points),
   individuals(Grid,InvS))),!,
   InvS=[_,_|_].




/*
points_name(E,Name):- 
 props_of_points(E,Ns),
  ignore((get_grid_nums(Nums),nth0(N,Nums,EE),EE=@=E,i_sym(N,Code),format(atom(Name),' Individual #~w  Code: "~s" ~w',[N,[Code],Ns]))),!.
points_name(E,pop(Ns)):- props_of_points(E,Ns).
*/
/*
print_list_of_points(N,H,V,PL):- 
  length(PL,Len),
  wqnl(N=list_of_points(Len)),!, 
  ignore((nop(debug_indiv),  
    forall(nth1(I,PL,E),print_points(N:I,H,V,E)))).

% print_points(N,H,V,E):- nop(print_points(N,H,V,E)),!.
print_points(N,H,V,E):- 
  dash_char(H,"-"),nl,  
  points_name(E,Name),
  write(Name), write(' from '),writeln(N),
  points_range(E,LoH,LoV,HiH,HiV,H,V),length(E,Len),wqnl(len(Len)->offset_ranges(LoH,LoV,HiH,HiV,H,V)),
  
  print_grid(1,1,LoH,LoV,HiH,HiV,H,V,E),dash_char(H,"-"),!,
  nl.

*/


/*
get_grid_num(C-Point,N):-
  hv_point(X,Y,Point),
  get_grid_num_xyc(X,Y,C,N).

get_grid_num(Point,N):-
  hv_point(X,Y,Point),
  get_grid_num_xyc(X,Y,_C,N).

get_grid_num_xyc(X,Y,C,N):- fail,
  hv_point(X,Y,Point),
  get_grid_nums(GridsN),
  nth0(N,GridsN,E),
  once((((member(C-PPoint,E);member(PPoint,E)),nonvar(PPoint),Point=PPoint);hv_cg _value(E,C,X,Y))).

get_grid_nums(GridNums):-
  nb_current(test_name_w_type,NameType),
  (grid_nums(NameType,Grids1)->true;Grids1=[]),
  (grid_nums(Grids0)->true;Grids0=[]),
  append(Grids1,Grids0,GridNums).


:- thread_local(grid_nums/2).
:- thread_local(grid_nums/1).
dead_set_grid_nums(Gs):- 
   nb_current(test_name_w_type,NameType),
   asserta(grid_nums(NameType,Gs)).
*/

/*
try_arc_io(CName,Name,ExampleNum,In,Out):-
  ignore((CName\==Name,flag(indiv,_,0),dash_char(60,"A"),dash_char(6,"\n"),nl)), 
  grid_info(Name,ExampleNum*in,In), %print_tree_nl(in=UnsharedIn),
  grid_info(Name,ExampleNum*out,Out), %print_tree_nl(out=UnsharedOut),
  !,
  % \+ \+ ignore(((ExampleNum=trn+_), test_config(learn(CProg)),must(training_progs(CProg,In,Out)))),
/*
  compute_diff(UnsharedIn,UnsharedOut,Diffs),!,
  nop(pt(diffs=Diffs)),
*/
    %trace, 
    get_combined(IndvO),
    print_grid(IndvO),
    maybe_confirm_sol(Name,ExampleNum,In,Out),nl,!.
*/
 /*

% Grid pretty printing
grid_info(Name,IO,Grid):- 
  PairName = (Name*IO),
  test_info(Name,InfoF),
  wqnl(fav(PairName,InfoF)),
  set_grid_id(Grid,PairName),
  describe_feature(Grid,[grid_dim,colors_count_size,colors_count,num_objects]),
  compute_shared_indivs(Grid,UnsharedIn),
  colors_count_size(Grid,CCS),
  ignore((sub_var(in,IO),(CCS>4;debug_indiv;true), debug_indiv(UnsharedIn))),
  print_grid(PairName,UnsharedIn,[Grid]),
  ignore((sub_var(out,IO),(CCS>4;debug_indiv;true), debug_indiv(UnsharedIn))),
  nop(describe_feature(Grid,[compute_shared_indivs])),!.
*/
% resize(H,V,Grid1,Grid2):- var(Grid2),grid_size(Grid1,C1),grid_size(Grid2,C2).


make_combined(IndvS1,IndvS2,BetterC):-
  append(IndvS1,IndvS2,IndvSU),list_to_set(IndvSU,IndvS),
  smallest_first(IndvS,IndvC),
  cleanup(IndvC,BetterC),
  nb_current(test_name_w_type,NamedExampleNum),
  set_named_indivs(NamedExampleNum,BetterC),!.

cleanup(IndvC,BetterC):-
  append(Left,[B|Bigger],IndvC),
  append(LeftB,[A|RBigger],Bigger),
  compute_diff(A,B,same_object(_)),!,
  object_indv_id(B,NamedExampleNum,Iv),
  setq(A,object_indv_id(B,NamedExampleNum,Iv),AA),
  append([Left,LeftB,RBigger,[AA]],MissingAB),
  cleanup(MissingAB,BetterC).
cleanup(A,A).



/*
*/
grid_indexer_cache(2,2,3,3,
[_,_,
 [_,_,X1,Y1,Z1|_],
 [_,_,X2,Y2,Z2|_],
 [_,_,X3,Y3,Z3|_]|_],
[[X1,Y1,Z1],
 [X2,Y2,Z2],
 [X3,Y3,Z3]]).


grid_indexer_cache(2,3,3,3,
[_,_,_,
 [_,_,X1,Y1,Z1|_],
 [_,_,X2,Y2,Z2|_],
 [_,_,X3,Y3,Z3|_]|_],
[[X1,Y1,Z1],
 [X2,Y2,Z2],
 [X3,Y3,Z3]]).


:- dynamic(grid_indexer_cache/6).

% make_grid_indexer(H,V,FH,FV,FindRow,Indexer):- grid_indexer_cache(H,V,FH,FV,FindRow,Indexer),!.
make_grid_indexer(H,_V,FH,_FV,_FindRow,_Indexer):- TH is H+FH, TH>30,!.
make_grid_indexer(_H,V,_FH,FV,_FindRow,_Indexer):- TV is V+FV, TV>30,!.
make_grid_indexer(H,V,FH,FV,FindRow,Indexer):-
  length(Above,V),
  make_row(FV,Rows),
  make_rows(FV,H,Rows,FH,FindRow),
  Before = _,
  append(Above,Rows,AR), append(AR,Before,Indexer),!.
  %grid_indexer_cache(H,V,FH,FV,FindRow,Indexer).

make_rows(FV,H,[Row|RO],VH,[FindRow|FRO]):- length(LPad,H),length(FindRow,H),
 append(LPad,FindRow,LPF), append(LPF,_,Row),!, FV1 is FV -1, make_rows(FV1,H,RO,VH,FRO).
make_rows(0,_,[],_,[]):-!.

%make_grid_indexer:- grid_indexer_cache(27,27,27,27,_,_),!.
make_grid_indexer:- 
 tell('gi_cache'),
 writeln(':- module(gi_cache,[igic/6]). \n'),
 forall(between(0,29,H),
  forall(V=0, %between(0,29,V),
   forall(between(1,30,FH),
    forall(between(1,30,FV),
     (make_grid_indexer(H,V,FH,FV,R,L),writeq(igic(H,V,FH,FV,R,L)),writeln('.')))))),
 told.

%:- ensure_loaded(gi_cache).


gr2o(Grid,Obj):- localpoints(Grid,NoisePoints), make_indiv_object(NoisePoints,[object_shape(noise)],Obj),!.
%gr2o(Grid,Obj):- Grid=Obj.

make_indivs(Pred,In,Out,InC,OutC):-
 %locally(i_o_w(In,Out),
  make_indivs1(Pred,In,Out,InC,OutC).

make_indivs1(Pred,In,Out,InC,OutC):-
  mass(Out,OMass), mass(In,IMass), OMass>IMass,
  make_indivs_no_swap(Pred,Out,In,OutC,InC),
  save_off(Pred,In,Out,InC,OutC).

make_indivs1(Pred,In,Out,InC,OutC):- 
  make_indivs_no_swap(Pred,In,Out,InC,OutC),
  nop(save_off(Pred,In,Out,InC,OutC)).

save_off(_Pred,_In,_Out,InC,OutC):-
 ((
  get_training(Training),!,
  pred_intersection(overlap_same_obj,InC,OutC,RetainedIn,_RetainedOut,Removed,Added),!,
  add_shape_lib(pair,Removed),!,  
  add_shape_lib(pair,Added),!,
  add_shape_lib(pair,RetainedIn),!,
  %rtrace,
  % % %  set(Training.grid_in) = In,!,
  %trace,

  % % %  set(Training.grid_out) = Out,
  % % %  set(Training.inC) = InC,
  % % %  set(Training.outC) = OutC,
  % % %  set(Training.added) = Added,
  % % %  set(Training.removed) = Removed,
  % % %  set(Training.kept) = RetainedIn,
  %nortrace,
  nop(set_training(Training)))),!.

make_indivs_no_swap(Pred,In,Out,InC,OutC):-
 must_det_ll((
  writeln(inC(Pred)),
  %rtrace,
  call_indv(Pred,In,InC),
  add_shape_lib(pair,InC),!,
  writeln(outC(Pred)),
  call_indv(Pred,Out,OutC),
  %add_shape_lib(out,OutC),
  writeln(inOutC(Pred)))),!.

call_indv(Pred,Out,OutC):-
 must_det_ll((
  %get_training(Training),
  % % %  set(Training.grid) = Out, % % %  set(Training.grid_o) = Out,
  %% % %  set(Training.objs) = _, % % %  set(Training.points) = _,
  %% % %  set(Training.robjs) = _, % % %  set(Training.points_o) = _,
  %grid_size(Out,H,V), % % %  set(Training.h) = H, % % %  set(Training.v) = V,
  %nortrace,
  call(Pred,Out,OutC))),!.
  %set_training(Training).


/*
show_indivs(IH,IV,OH,OV,Pred,When,PairName,In,Out,SF):-  
  ignore(IH=1),
  LW is (IH * 2 + 12),
  append_term_safe(When,Pred+PairName+in,NameIn),
  append_term_safe(When,Pred+PairName+out,NameOut),
  wots(U1, print_grid(IH,IV,NameIn,In)),
  wots(U2, print_grid(OH,OV,NameOut,Out)),
  print_side_by_side(U1,LW,U2),
  my_append(InC,OutC,InOutC),
  smallest_first(InOutC,SF),
  %largest_first(InOutC,LF),
  %show_pair_no_i(IH,IV,OH,OV,smallest_first(When,Pred),PairName,InC-SF,OutC-SF),
  %wots(U3, print_grid(IH,IV,NameIn,InC-SF)),wots(U4, print_grid(OH,OV,NameOut,OutC-SF)),print_side_by_side(U3,LW,U4),
  %max_min(IH,OH,H,_),max_min(IV,OV,V,_),
  show_pair_no_i(IH,IV,OH,OV,normal(When,Pred),PairName,InC,OutC),
  INFO = [grid_dim,mass,colors_count_size,colors],
  print_side_by_side(
     describe_feature(InC,[call(writeln('IN'))|INFO]),LW,
    describe_feature(OutC,[call(writeln('OUT'))|INFO])),!,
  show_pair_I_info(NameIn,NameOut,InC,OutC).
*/







  /*

  nop((
       show_indivs(IH,IV,OH,OV,individuate_complete,early,PairName,In,Out,SF),
       forall((rtrace_on_error(individualizer_heuristics(PairName,In,Out,IH,IV,OH,OV))),true), 
       add_shape_lib(pairs,SF),
       show_shape_lib(in),show_shape_lib(out),show_shape_lib(pair),show_shape_lib(noise),
       show_indivs(IH,IV,OH,OV,individuate_default,later,PairName,In,Out,_))),!,
       with_named_pair(solve,TestID,PairName,In,Out),
*/
/*
  remove_global_points(UnsharedIn,In,InForgotten),
  remove_global_points(UnsharedOut,Out,OutForgottenM),
  ((mass(OutForgottenM,OM),OM==0) -> OutForgotten=OutC; OutForgotten=OutForgottenM),
  individuate(complete,InForgotten,ForgottenShapesIn),
  individuate(complete,OutForgotten,ForgottenShapesOut),

  % contains_points(InForgotten);contains_points(OutForgotten)
  %show_pair_no_i(IH,IV,OH,OV,forgotten,PairName,ForgottenShapesIn,ForgottenShapesOut),

  show_pair_no_i(IH,IV,IH,IV,forgotten_In,PairName,UnsharedIn,ForgottenShapesIn),
  show_pair_no_i(OH,OV,OH,OV,forgotten_Out,PairName,ForgottenShapesOut,OutC),
*//*
       show_indivs(In,Out),
       individuate(defaults,In,InC),
       individuate(defaults,Out,OutC),  
       writeln(outC),

       clear_shape_lib(out),
       clear_shape_lib(in),
       add_shape_lib(out,OutC),
       writeln(inOutC),
       show_pair_i(IH,IV,OH,OV,early_test,PairName,InC,OutC),
       writeln(inC),
       individuate(defaults,In,UnsharedIn),
       writeln(outC),
       individuate(defaults,Out,UnsharedOut),
       writeln(inUnsharedOut),
       show_pair_i(IH,IV,OH,OV,late_test,PairName,UnsharedIn,UnsharedOut),
       format('~N1-sofar~N1'),!,
       %pt(yellow,in=UnsharedIn),
       pred_intersection(compare_objs1([same]),UnsharedIn,UnsharedOut,_CommonCsIn,_CommonCsOut,_IPCs,_OPCs),
       format('~N1-pred_intersection~N1'),
        individuate(UnsharedOut,Out,SharedInR),
        individuate(UnsharedIn,In,SharedOutR),
        show_pair_no_i(IH,IV,OH,OV,shared,PairName,SharedInR,SharedOutR))), !.*/
  %format('~N1-Rule made from~N1'),
  %show_rules,
/*  RESS =.. [res,unsharedIn=UnsharedIn,
             %onlyIn= IPCs,
            commonIn=CommonCsIn,commonOut=CommonCsOut, %onlyOut=OPCs, 
             unsharedOut=UnsharedOut],
  tersify(RESS,ShortInfo),         
  format('~N1-Stats:~N1'),
  pt(yellow,sol=ShortInfo), !.
  */
	
% =====================================================================
is_fti_step(bg_shapes).
% =====================================================================
bg_shapes(Shape,VM):-
 must_det_ll((
  OldPoints = VM.points,
  OldGrid = VM.grid,  
  get_bgc(Wbg),  
  subst001(OldGrid,black,Wbg,MidGrid),
  as_bgoid(_,Wbg,MidGrid,NewGrid),
  globalpoints_include_bg(NewGrid,NewPoints),
  set(VM.points)=NewPoints,
  set(VM.grid)=NewGrid,
  %print_side_by_side(OldGrid,NewGrid),
  print_side_by_side(OldPoints,NewPoints),
  %print_attvars(np=NewPoints), print_attvars(ng=NewGrid),
  run_fti(VM,Shape),
  wdmsg(bg_shapes=Shape),
  set(VM.points)=OldPoints,
  set(VM.grid)=OldGrid)),
  !.

as_bgoid(Fg,Wbg,Gridoid,BGoid):- into_monochrome(bg_shaped,Gridoid,BGoid).


consider_bg(Wbg,V,WbgO):- consider_bg1(Wbg,V,WbgM),!,WbgM==Wbg,copy_term( Wbg,WbgO).
consider_bg1(Wbg,V,Wbg):- plain_var(V),!,Wbg=V.
consider_bg1(Wbg,V,Wbg):- V == wbg.
consider_bg1(Wbg,V,Wbg):- V == Wbg.
consider_bg1(Wbg,V,Wbg):- is_colorish(V), (is_bg_color(V); \+ is_fg_color(V)),!.

consider_fg(Wfg,V,WfgO):- consider_fg1(Wfg,V,WfgM),!,WfgM==Wfg,copy_term( Wfg,WfgO).
consider_fg1(Wfg,V,Wfg):- plain_var(V),!,Wfg=V.
consider_fg1(Wfg,V,Wfg):- V == wfg.
consider_fg1(Wfg,V,Wfg):- V == Wfg.
consider_fg1(Wfg,V,Wfg):- is_colorish(V), (is_fg_color(V); \+ is_bg_color(V)),!.

/*
  
  nop((reuse_indivs(SharedIn,SharedOut,BetterA,BetterB),
  ( (SharedOut\==BetterB ; SharedIn\== BetterA) ->
    show_pair_i(IH,IV,OH,OV,better,PairName,BetterA,BetterB);
     writeln('nothing better')))),
*/
  


/*
fti(VM,[by_color(Min,[])|set(VM.program_i)]):-!.

fsi(_VM,ReservedIO,Grid,[by_color(Min,Rest)|TODO],H,V,Sofar,ID,[by_color(Min,Options)|TODO],ReservedIO,Points,Grid,NewSofar,NextScanPoints):-
  listify(Options,OptionsL),!,
  select(C,OptionsL,Rest),
  my_partition(=(C-_),Points,ThisGroup,NextScanPoints),
  ((ThisGroup\==[],make_indiv_object(ID,H,V,ThisGroup,[iz(by_color(Min,C))],ColorObj))
    -> NewSofar = [ColorObj|Sofar] 
     ; NewSofar = Sofar).
*/
/*

fsi(_VM,Reserved,Grid,NewOptions,_H,_V,Sofar,_ID,[by_color|TODO], Reserved, Points, Grid,Sofar, Points):- !,
   my_append(
     [(by_color(Min,[(black), (blue),  (red),   (green),(yellow),
                     (silver),(purple),(orange),(cyan), (brown)]))],TODO,NewOptions).
*/
/*

fsi(_VM,Reserved,Grid,TODO,GH,GV,Sofar,ID,[leftover_as_one|TODO], Reserved, Points, Grid,SofarIndvList, []):- !,
   Points==[] -> SofarIndvList = Sofar ;
   make_indiv_object(ID,GH,GV,Points,[iz(combined),iz(leftover_as_one)],LeftOverObj), verify_object(LeftOverObj),
   my_append(Sofar,[LeftOverObj],SofarIndvList).


fsi(_VM,Reserved,Grid,TODO,H,V,Sofar,ID,[into_single|TODO],Reserved,Points,Grid,[Indv],Points):- !,
    maplist(globalpoints,Sofar,IndvPoints), my_append(IndvPoints,IndvPointsL),
    EIndvPoints=[iz(combined),iz(into_single)|IndvPointsL],
    make_indiv_object(ID,H,V,EIndvPoints,Indv),
    meets_indiv_criteria(into_single_hidden,IndvPoints),!.

%  fsi(_VM,NewReserved,NewGrid,NewOptions,H,V,Sofar,ID,TODO,Reserved,Points,Grid,OutInvdivS,NextScanPoints).
*/


/*
make_indiv_object(_ID,_H,_V,IPoints,Obj):- 
  compound(IPoints),IPoints=obj(_),Obj=IPoints,!.
make_indiv_object(ID,H,V,IPoints,Obj):-
  my_partition(is_cpoint,IPoints,Points,Overrides),
  sort_points(GPoints,Points),
  points_range(Points,LoH,LoV,HiH,HiV,_HO,_VO),
  make_indiv_object(ID,H,V,LoH,LoV,HiH,HiV,Points,Overrides,OUT),
  as_obj(OUT,Obj).


make_indiv_object(VM,Points,Overrides,Obj):- 
  globalpoints(Points,RPoints),
  sort_points(RPoints,GPoints),
  points_range(GPoints,LoH,LoV,HiH,HiV,_HO,_VO),
  gensym('indiv_object_',ID),
  make_indiv_object(ID,HiH,HiV,LoH,LoV,HiH,HiV,GPoints,Overrides,OUT),
  as_obj(OUT,Obj).

make_indiv_object(ID,H,V,Points,Overrides,Obj):-
  points_range(Points,LoH,LoV,HiH,HiV,_HO,_VO),
  make_indiv_object(ID,H,V,LoH,LoV,HiH,HiV,Points,Overrides,OUT),!,
  as_obj(OUT,Obj).

make_indiv_object(ID,H,V,LoH,LoV,HiH,HiV,GPoints,Overrides,Obj):-
  validate_points(GPoints), sort_points(GPoints,Points),
  make_indiv_object_s(ID,H,V,LoH,LoV,HiH,HiV,Points,Overrides,Obj).
*/
/*
make_indiv_object_list(ID,H,V,Points,OUT):-
  mapgroup(make_indiv_object(ID,H,V),Points,OUT).
*/

%make_indiv_object(_,_,_,obj(Ps),obj(Ps)):-
%embue_points(ID,_,_,I,I):-!.
%embue_obj_points(ID,H,V,Points,OUT):- make_indiv_object(ID,H,V,Points,OUT).

%embue_obj_points(ID,H,V,LoH,LoV,HiH,HiV,C-HV,OBJ):- !, embue_obj_points(ID,H,V,LoH,LoV,HiH,HiV,[C-HV],OBJ).



  %pt(Image-->Image9x9),
  %grid_to_id(Grid,Gridname),
  %quaderants_and_center_rays(Image9x9,Quads,Centers,Rays),
  %my_append([Quads,Centers,Rays],FourWay1s00),
  %trace,
  %correctify_objs(Gridname,FourWay1s00,FourWay1s),!.


/*correctify_objs(Gridname,FourWay1s00,FourWay1s):- is_list(FourWay1s00),mapgroup(correctify_objs(Gridname),FourWay1s00,FourWay1s).
correctify_objs(Gridname,obj(List),obj(NOBJ)):- is_list(List), 
   member(grid(Grid),List),
   \+ member(globalpoints(_),List),`
   grid_size(Grid,H,V),
   %trace,
   pt(dleaing_with=obj(List)),
   globalpoints(Grid,Points),
   my_assertion(Points\=[]),
   points_range(Points,LoH,LoV,HiH,HiV,_HO,_VO),
   %nb_current(test_pairname,ID),
   embue_points1(Gridname,H,V,LoH,LoV,HiH,HiV,Points,OBJ),
   my_append(List,OBJ,NOBJ),!.
correctify_objs(_Gridname,obj(List),obj(List)):-!.
correctify_objs(_Gridname,Obj,Obj).
   %make_embued_points(Grid,H,V,Points,IndvS)
*/
%  make_indiv_object(VM.id,VM.h,VM.v,RepairedPoints,[iz(symmetric_indiv)],ColorObj),!,

% standalone_dots that have no adjacent points of the same color are gathered first
/*
fsi(_VM,Reserved,Grid,TODO,H,V,Sofar,ID,['standalone_dots'|TODO],Reserved,Points,Grid,SofarOut,[]):-
  maplist(make_point_object(ID,H,V,[iz(leftovers),iz(standalone_dots),iz(dot)]),Points,IndvList),
  my_append(Sofar,IndvList,SofarOut),!.

fsi(_VM,Reserved,Grid,['standalone_dots'|TODO],H,V,Sofar,ID,['standalone_dots'|TODO],Reserved,Points,Grid,[Indv|Sofar],Rest):-
   %( (H < 6; V < 6) ;   
   maybe_multivar(C),
    select(C-HV,Points,Rest),  \+ free_cell(C),
   \+ \+ (( is_adjacent_point(HV,_,HV2),
           member(C2-HV2,Rest),ok_color_with(C,C2))),

   make_indiv_object(ID,H,V,[iz(standalone_dots),C-HV],Indv),

   meets_indiv_criteria(standalone_dots,Indv),!.

% standalone_dots may have adjacent points of the same color (because we are in 'standalone_dots' mode)
fsi(_VM,Reserved,Grid,['standalone_dots'|TODO],H,V,Sofar,ID,['standalone_dots'|TODO],Reserved,Points,Grid,[Indv|Sofar],Rest):- !,
   maybe_multivar(C), select(C-HV,Points,Rest),  \+ free_cell(C),
   make_indiv_object(ID,H,V,[iz(standalone_dots),C-HV],Indv),
   meets_indiv_criteria(standalone_dots,Indv),!.


fsi(VM,ReservedO,GridO,OptionsOut,H,V,Sofar,ID,[full|TODO],ReservedI,Points,Grid,SofarOut,NextScanPoints):-!,
  grid_to_individual(Grid,Obj),
  fsi(VM,ReservedO,GridO,OptionsOut,H,V,[Obj|Sofar],ID,TODO,ReservedI,Points,Grid,SofarOut,NextScanPoints).
*/

  /*
get_new_task_obj(Obj):-
   Obj = _{ original_grid: _ ,unprocessed_grid:_, original_points:_, points:_, options:_, program_i:_,
     objs:_, grid_id:_, in_or_out:_, grid_size:_, reserver_indivs:_  }.
*/


ensure_fti(GH,GV,ID,Grid,Sofar,Reserved,Options,Points,VM):-  

  (plain_var(VM) -> list_to_rbtree_safe([type-fti],VM); true),

  statistics(cputime,X),Timeleft is X+60,
  into_grid_d(Grid,Grid_D),
  max_min(GH,GV,Max,_Min),
 % rb_new(HM),duplicate_term(HM,Hashmap),
  ArgVM = vm{
   % parent VM
   %training:_,
   % Options and TODO List (are actually same things)
   program_i:Options, options:[], roptions:_, %todo_prev:[],
   % how much time is left before we turn on debugger
   timeleft:Timeleft, objs_max_len:Max, objs_min_mass:_, objs_max_mass:_,
     grid_d:Grid_D,
   % Grid and point representations
   grid:Grid, points:Points, points_o:Points, % points_repair:[],

   target:_, props:_, full_grid:_, solution:_, changed:_, repaired:_, supergrid:_, compare:_,
   % Original copies of Grid and point representations
   % grid_o:Grid,    
   % objects found in grid and object that are reserved to not be found
   objs:Sofar,  robjs:Reserved, %objs_prev:[],
   % Notes and debug info
   notes:_, debug:_,
   
   % height width and lookup key for image
   h:GH, v:GV, id:ID},
  % (var(VM) -> (fix_test_name(ID,TestID,_), make_training_hints(TestID,ArgVM,HintedVM), HintedVM = VM) ; true),
   %(nb_current('$vm_pair',Shared)-> transfer_missing(Shared,VM) ; true),
   %b_set_dict(objs,VM,[]),
   %set(VM.current_i) = VM
   %(var(VM) ->ArgVM =VM ; ignore(ArgVM>:<VM)),   
   arc_setval(VM,ArgVM),
   set_vm(VM),
   !.



call_fsi(VM,NewReserved,NewGrid,NewProgramCode,GH,GV,Sofar,ID,ProgramCode,Reserved,Points,Grid,SofarMaybeNew,NextScanPoints):- !,
  %(var(VM)->(ensure_fti(GH,GV,ID,Grid,Sofar,Reserved,ProgramCode,Points,VM));true),
  clause(fti(VM,ProgramCode),Body),
  call((Body,deterministic(YN),true)),
  (YN == true -> ! ; true),
  NewReserved = VM.robjs,
  NewProgramCode = VM.program_i,
  NewGrid = VM.grid,
  NextScanPoints = VM.points,
  SofarMaybeNew = VM.objs .
call_fsi(VM,NewReserved,NewGrid,NewProgramCode,GH,GV,Sofar,ID,ProgramCode,Reserved,Points,Grid,SofarMaybeNew,NextScanPoints):- fail,
  clause(fsi(VM,NewReserved,NewGrid,NewProgramCode,GH,GV,Sofar,ID,ProgramCode,Reserved,Points,Grid,SofarMaybeNew,NextScanPoints),Body),
  call((Body,deterministic(YN),true)),
  (YN == true -> ! ; true).

individuate(VM):- fail,
      individuate(VM.roptions, VM.grid, Objs), 
      %set(VM.objs) = Objs,
      set(VM.objs) = Objs,
      RO = VM.roptions,
      nop(fif(\+ is_list(RO), add_shape_lib(RO,Objs))).

individuals_list(_VM,_GH,_GV,Sofar,_ID,_Options,_Reserved,Points,_Grid,Sofar,PointsO):- Points == [], !,PointsO=[].

individuals_list(VM,GH,GV,Sofar,ID,Options,Reserved,Points,Grid,IndvList,LeftOver):-    
    my_assertion(maplist(is_cpoint,Points)),
    my_assertion(is_list([sofar1(Options)|Sofar])),
    my_assertion(maplist(nonvar_or_ci,[fsi,Grid,Points])),
    my_assertion(maplist(nonvar_or_ci,[fsi2,Reserved,Options,Sofar,GV,GH,ID])),
     length(Sofar,SofarL),
      (((call_fsi(VM,NewReserved,NewGrid,NewOptions,GH,GV,Sofar,ID,Options,Reserved,Points,Grid,SofarMaybeNew,NextScanPoints)))),

          intersection(SofarMaybeNew,Sofar,Unchanged,New,GoneMissing),
          %addCPoints(VM,GoneMissing),
          remCPoints(VM,New),


          intersection(Options,NewOptions,_,Birth,_),
          (last(Birth,Head)-> true; Options = [Head|_]),

          ((\+ (sub_term(E,New), compound(E), E = birth(_))) -> override_object(birth(Head),New,NewUpdated) ; New=NewUpdated),
          my_append(Unchanged,NewUpdated,SofarUpdated),

          length(SofarMaybeNew,SofarMaybeNewL),

          ignore(((NewOptions\==Options;(GoneMissing\==[];SofarMaybeNewL\==SofarL)),
          
          (NextScanPoints\==[]->Second=NextScanPoints;Second=NewGrid),

          nop(ignore((GoneMissing\==[],ptt(goneMissing=GoneMissing)))),
          once( 
                (SofarMaybeNew\== Sofar;NextScanPoints\== Points, %append(SofarMaybeNew,NextScanPoints,DG),
                              format('~N'), print_side_by_side(silver,print_grid(GH,GV,SofarMaybeNew),objs+Head,_,
                                                                print_grid(GH,GV,Second),second));

                     
                
               % (NewGrid\=@= Grid, print_grid(_,_,grid+Head,NewGrid));
                true),
          
             true)),
            

  my_assertion(maplist(nonvar_or_ci,[fsi3,SofarUpdated,NextScanPoints])),
  my_assertion(maplist(nonvar_or_ci,[fsi3a,NewOptions,NewReserved])),
    my_assertion(maplist(is_cpoint,NextScanPoints)),
    my_assertion(is_list([foundSofar1(Options)|SofarUpdated])),
  my_assertion(maplist(nonvar_or_ci,[fsi4,NewGrid])),
  my_assertion(maplist(nonvar_or_ci,[fsi5,GH,GV,ID,NewOptions,NewReserved,NextScanPoints])),
    once( (SofarUpdated\==Sofar) ; (Options\==NewOptions) ; (NextScanPoints\== Points); (NewGrid\=@= Grid); (NewReserved\=@= Reserved)),!,
    %wqnl(indv(Options)=Indv),   
    
    individuals_list(VM,GH,GV,SofarUpdated,ID,NewOptions,NewReserved,NextScanPoints,NewGrid,IndvList,LeftOver),!.

individuals_list(VM,GH,GV,Sofar,ID,Options,Reserved,Points,Grid,IndvList,NextScanPoints):-  
  next_options(Options,Options2),
  %set(VM.objs_prev)=VM.objs,
  %set(VM.todo_prev)=VM.program_i,
  individuals_list(VM,GH,GV,Sofar,ID,Options2,Reserved,Points,Grid,IndvList,NextScanPoints),!.

individuals_list(_VM,GH,GV,Sofar,ID,Options,_Reserved,Points,_Grid,IndvListOut,[]):- 
 %must_det_ll(Options==[]),
 must_be_free(IndvListOut),
  my_assertion(is_list([sofar2(Options)|Sofar])),
  my_assertion(is_list([sofar|Sofar])),
  my_assertion(is_list([points|Points])),
  my_assertion(maplist(is_cpoint,Points)),
   ignore((Points\==[],as_debug(8,print_grid(GH,GV,'leftover_points'+ID,Points)))),
  % maplist(make_point_object(ID,GH,GV,[iz(leftovers)]),Points,IndvList),
  IndvList = [],
  % individuate([just(by_color)],Points,IndvList2),
  IndvList2 = [],
  % make_indiv_object(ID,GH,GV,Points,[iz(combined),iz(leftovers)],LeftOverObj), 
  LeftOverObj = [],
  flatten([Sofar,IndvList,IndvList2,LeftOverObj],IndvListOut),!.

individuals_list(VM,GH,GV,Sofar,ID,Options,Reserved,P,Grid,Sofar,P):-!,
  throw(fail(individuals_list(VM,GH,GV,Sofar,ID,Options,Reserved,P,Grid,Sofar,P))),!.


















list_to_row_mem(ID,N,List, row_mem(ID,N,A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31, A32)):-
  append(List,_,[A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31, A32]).

:- dynamic(row_mem_access/35).

row_mem_access([],ID,N, B01, B02, B03, B04, B05, B06, B07, B08, B09, B10, B11, B12, B13, B14, B15, 
  B16, B17, B18, B19, B20, B21, B22, B23, B24, B25, B26, B27, B28, B29, B30, B31, B32):-!,
  row_mem(ID,N, B01, B02, B03, B04, B05, B06, B07, B08, B09, B10, B11, B12, B13, B14, B15, B16, B17, B18, B19, B20, B21, B22, B23, B24, B25, B26, B27, B28, B29, B30, B31, B32).
 
row_mem_access([post_xform(More,P2)],ID,N, B01, B02, B03, B04, B05, B06, B07, B08, B09, B10, B11, B12, B13, B14, B15, 
 B16, B17, B18, B19, B20, B21, B22, B23, B24, B25, B26, B27, B28, B29, B30, B31, B32):-!,
 row_mem_access(More,ID,N,A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31, A32),
  xform(P2,A01,B01), xform(P2,A02,B02), xform(P2,A03,B03), xform(P2,A04,B04), xform(P2,A05,B05), xform(P2,A06,B06), 
  xform(P2,A07,B07), xform(P2,A08,B08), xform(P2,A09,B09), xform(P2,A10,B10), xform(P2,A11,B11), xform(P2,A12,B12), 
  xform(P2,A13,B13), xform(P2,A14,B14), xform(P2,A15,B15), xform(P2,A16,B16), xform(P2,A17,B17), xform(P2,A18,B18), 
  xform(P2,A19,B19), xform(P2,A20,B20), xform(P2,A21,B21), xform(P2,A22,B22), xform(P2,A23,B23), xform(P2,A24,B24), 
  xform(P2,A25,B25), xform(P2,A26,B26), xform(P2,A27,B27), xform(P2,A28,B28), xform(P2,A29,B29), xform(P2,A30,B30),
  xform(P2,A31,B31), xform(P2,A32,B32).

row_mem_access([xform(P2)|More],ID,N, A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11, A12, A13, A14, A15, 
 A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31, A32):- !,
 xform(P2,A01,B01), xform(P2,A02,B02), xform(P2,A03,B03), xform(P2,A04,B04), xform(P2,A05,B05), xform(P2,A06,B06), 
 xform(P2,A07,B07), xform(P2,A08,B08), xform(P2,A09,B09), xform(P2,A10,B10), xform(P2,A11,B11), xform(P2,A12,B12), 
 xform(P2,A13,B13), xform(P2,A14,B14), xform(P2,A15,B15), xform(P2,A16,B16), xform(P2,A17,B17), xform(P2,A18,B18), 
 xform(P2,A19,B19), xform(P2,A20,B20), xform(P2,A21,B21), xform(P2,A22,B22), xform(P2,A23,B23), xform(P2,A24,B24), 
 xform(P2,A25,B25), xform(P2,A26,B26), xform(P2,A27,B27), xform(P2,A28,B28), xform(P2,A29,B29), xform(P2,A30,B30),
 xform(P2,A31,B31), xform(P2,A32,B32),
 row_mem_access(More,ID,N,B01, B02, B03, B04, B05, B06, B07, B08, B09, B10, B11, B12, B13, B14, B15, B16, B17, B18, B19, B20, B21, B22, B23, B24, B25, B26, B27, B28, B29, B30, B31, B32).

row_mem_access([rev|More],ID,N,A01, A02, A03, A04, A05, A06, A07, A08, A09, A10, A11, A12, A13, A14, A15, 
   A16, A17, A18, A19, A20, A21, A22, A23, A24, A25, A26, A27, A28, A29, A30, A31, A32):-!,
   row_mem_access(More,ID,N,A32, A31, A30, A29, A28, A27, A26, A25, A24, A23, A22, A21, A20, A19, A18, A17, A16, A15, A14, A13, A12, A11, A10, A09, A08, A07, A06, A05, A04, A03, A02, A01).  

store_rowmems:- 
  length(S1,32),length(S2,32),length(MissingH,32),% length(BLANK,32),
  RMA = row_mem_access,
  forall(between(0,31,I),
 ((length(Left,I),length(Gather,I),
   H is I + 1,
   H = W,
   length(USE,W),
   append(Left,S1,All),   
   append(S2,_,All),
   append(USE,_,All),

   append(Gather,[C|Right],S2),
   append(Gather,[_|Right],MissingH),
  AS1=..[row_mem,ID,V|S1],
  AS2=..[row_mem,ID2,V|S2],
  CH=..[row_mem,ID,V|S2],
  BLANKH=..[row_mem,ID,V|MissingH],
  %ASBLANK=..[row_mem,ID,V|BLANK],

  SL2=..[RMA,[shift_l(I)|More],ID,V|S2],
  SA1=..[RMA,More,ID,V|S1],
  assert_if_new((SL2 :- SA1)),
  SR1=..[RMA,[shift_r(I)|More],ID,V|S1],
  SA2=..[RMA,More,ID,V|S2],
  assert_if_new((SR1 :- SA2)),

  assert_if_new((row_mem_len_list(ID,V,W,USE) :- AS1)),  
  assert_if_new((row_mem_shift_match(I,ID,V,ID2):- AS1,AS2)),
  assert_if_new((row_mem_dig(ID,V,W,AS1):- AS1)),
  assert_if_new((row_mem_nth(ID,H,V,C):- AS1)),
  assert_if_new((row_mem_set_nth(ID,H,V,C):- ignore(retract(BLANKH)),pfc_assert(CH))),
  assert_if_new((row_mem_offset(AS1,AS2))),
  true))).
:- store_rowmems.

xform(P2,X,Y):- call(P2,X,Y).

row_mem_get_list(ID,N,USE) :- is_grid_size(ID,H,_),row_mem_len_list(ID,N,H,USE).

