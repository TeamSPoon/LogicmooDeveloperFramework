%unset_points(AR,B):- 
%  set_local_points(AR,B).
%unset_points(AR,B):- set_local_points(AR,B).


constrain_type(_CheckType,_Grid,G,G):-!.
constrain_type(CheckType,Grid,G,GG):- is_list(G),!,maplist(constrain_type(CheckType,Grid),G,GG).
%constrain_type(CheckType,Grid,G,GG):- is_bg_color(G),constrain_type(CheckType,\+ is_fg_color(GG)),!.
%constrain_type(CheckType,Grid,G,GG):- is_color(G),!,constrain_type(CheckType,G==GG).
constrain_type(CheckType,_Grid,G,GG):- is_bg_color(G), constrain_type(CheckType,G=GG),!.
constrain_type(_CheckType,_Grid,G,G):- is_fg_color(G),!.
constrain_type(CheckType,_Grid,G,GG):- constrain_type(CheckType,G=GG).


/*
expand_color(FG,Was,C,CC):- FG== fg,!,expand_color(C,Was,C,CC).
expand_color(FG,Was,C,CC):- var(C),is_color_no_bgc(FG),!,FG=C.
expand_color(FG,Was,C,CC):- is_color_no_bgc(C),!,CC=C.
expand_color(FG,Was,C,CC):- var(C),is_bgc(FG),!,FG=C.
expand_color(FG,Was,C,CC):- is_bgc(C),!,CC=C.



set_local_points(Points,Grid):-  set_local_points(fg,Points,Grid),!.
set_local_points(_,[],_):-!.
set_local_points(_,_,[]):-!.
set_local_points(C,Obj,Grid):- is_object(Obj), localpoints(Obj,Points),!, set_local_points(C,Points,Grid).
set_local_points(C,Obj,Grid):- is_group(Obj),!, into_grid(Obj,Grid),localpoints(Obj,Points), set_local_points(C,Points,Grid).
set_local_points(C,Obj,Grid):- is_grid(Obj), !, localpoints(Obj,Points),!, set_local_points(C,Points,Grid).

set_local_points(C,[H|T],Grid):- !, set_local_points(C,H,Grid),set_local_points(C,T,Grid).
set_local_points(FG,Point,Grid):- as_hv_point(H,V,C,Point),hv_cg_va lue_or(Grid,Was,H,V,unknown),
   expand_color(FG,Was,C,CC),!,
   must(nb_set_local_point(H,V,CC,Grid)).


   %set_local_points(C,Obj,Grid):- is_grid(Obj), is_grid(Grid), grid_to_grid(C,Obj,Grid)
set_local_points(C,Point,Grid):- throw_missed(set_local_points(C,Point,Grid)).

nb_set_local_point(H,V,C,[]):- break,!.
nb_set_local_point(H,V,C,Obj):- is_group(Obj),!,maplist(nb_set_local_point(H,V,C),Obj).
nb_set_local_point(H,V,C,Obj):- is_object(Obj), get_instance_method(Obj,nb_set_local_point(H,V,C),Method),!,call(Method,Obj,H,V,C).


nb_set_local_point(H,V,C,Obj):- is_object(Obj),!,trace,localpoints(Obj,Points),nb_set_local_point(H,V,C,Points), setq(Obj,localpoints(Points),Res),nop(assertion(same_term(Obj,Res))).

nb_set_local_point(H,V,C, Grid):- maplist(is_cpoint,Grid),!,hv_point(H,V,Point),!, must(nth1(Nth,Grid,_-Point)->nb_set_nth1(Nth,Grid,C-Point);nb_set_insert(Grid,Point)).
nb_set_local_point(H,V,_C,Grid):- maplist(is_nc_point,Grid),!,hv_point(H,V,Point),!, must(nth1(Nth,Grid,Point)->nb_set_nth1(Nth,Grid,Point);nb_set_insert(Grid,Point)).
nb_set_local_point(H,V,C,Obj):-!.
nb_set_local_point(H,V,C,Obj):- throw_missed(nb_set_local_point(H,V,C,Obj)).
*/


object_nb_set_local_point(Obj,LH,LV,C):- object_set_local_point(Obj,LH,LV,C),!.
object_nb_set_local_point(Obj,LH,LV,C):- trace,object_set_local_point(Obj,LH,LV,C).

object_set_local_point(Obj,LH,LV,C):- 
  object_local_to_global_point(Obj,LH,LV,H,V),
  hv_point(H,V,GPoint), hv_point(LH,LV,LPoint), 
 ((
  obtain_prop(Obj,globalpoints(GPoints),NewGPoints),
  (GPoints==[]->NewGPoints=[C-GPoint];NewGPoints=GPoints),
  nb_set_local_point(H,V,C,NewGPoints))),
 ((
  obtain_prop(Obj,localpoints(Points),NewPoints),
  (Points==[]->NewPoints=[C-LPoint];NewPoints=Points),
  nb_set_local_point(LH,LV,C,NewPoints))),
 ((
  obtain_prop(Obj,grid(Grid),Grid),
  nb_set_local_point(LH,LV,C,Grid))),!.


%obtain_prop(Obj,globalpoints(Was),globalpoints(New)):- nth1(N,
obtain_prop(Obj,Was,New):- arg(1,Obj,L), nth1(N,L,Was),nth1(N,L,Found),nb_setarg(1,Found,New).

object_nb_set_global_point(Obj,H,V,C):- object_set_global_point(Obj,H,V,C).
object_set_global_point(Obj,H,V,C):- 
  object_global_to_local_point(H,V,LH,LV),
  object_set_local_point(Obj,LH,LV,C).


object_global_to_local_point(Obj,H,V,LH,LV):- (Obj,OH,OV),
  LH is H - OH + 1, LV is V - OV + 1.

object_local_to_global_point(Obj,H,V,LH,LV):- loc_xy(Obj,OH,OV),
  LH is H + OH - 1, LV is V + OV - 1.




set_global_points(Points,Grid):-  set_global_points(fg,Points,Grid).
set_global_points(_,[],_):-!.
set_global_points(C,Obj,Grid):- is_grid(Obj), !, globalpoints(Obj,Points), set_global_points(C,Points,Grid).
set_global_points(C,[H|T],Grid):- !, set_global_points(C,H,Grid),set_global_points(C,T,Grid).
set_global_points(C,Obj,Grid):- is_object(Obj), globalpoints(Obj,Points),!, set_global_points(C,Points,Grid).
set_global_points(C,Obj,Grid):- is_group(Obj),!, into_grid(Obj,Grid),globalpoints(Obj,Points), set_global_points(C,Points,Grid).
set_global_points(C,Point,Grid):- as_hv_point(H,V,Var,Point), ignore(C=Var), !,nb_set_global_point(H,V,C,Grid).
set_global_points(C,Point,Grid):- throw_missed(set_global_points(C,Point,Grid)).

nb_set_global_point(H,V,C,Grid):- is_grid(Grid),nth1(V,Grid,Row),nb_set_nth1(H,Row,C).
nb_set_global_point(H,V,C,Obj):- is_object(Obj),get_instance_method(Obj,set_global_point(H,V,C),Method),!,call(Method,Obj,H,V,C).
nb_set_global_point(H,V,C,Obj):- is_group(Obj),maplist(nb_set_global_point(H,V,C),Obj).
nb_set_global_point(H,V,C,Obj):- is_object(Obj),globalpoints(Obj,Points),!,nb_set_global_point(H,V,C,Points),
  setq(Obj,globalpoints(Points),Res),nop(assertion(same_term(Obj,Res))).

nb_set_global_point(H,V,_C,Grid):- maplist(is_nc_point,Grid),hv_point(H,V,Point),
  (nth1(Nth,Grid,Point)->nb_set_nth1(Nth,Grid,Point);nb_set_insert(Grid,Point)).
nb_set_global_point(H,V,C,Grid):- maplist(is_cpoint,Grid),hv_point(H,V,Point),
  (nth1(Nth,Grid,_-Point)->nb_set_nth1(Nth,Grid,Point);nb_set_insert(Grid,C-Point)).

nb_set_global_point(H,V,C,Obj):- throw_missed(nb_set_global_point(H,V,C,Obj)).





get_overlaps(NewIndiv1s,Rest,A,B,AR,BR):- 
  select(A,NewIndiv1s,Rest1),
  select(B,Rest1,Rest),
  object_grid(A,AR), object_grid(B,BR).

get_best_overlaps(NewIndiv1s,Rest,A,B,AR,BR):-
  get_overlaps(NewIndiv1s,Rest,A,B,AR,BR), AR==BR,!.
get_best_overlaps(NewIndiv1s,Rest,A,B,AR,BR):-
  get_overlaps(NewIndiv1s,Rest,A,B,AR,BR), 
  show_success(always,confirm_overlap(AR,BR)),!.
get_best_overlaps(NewIndiv1s,Rest,A,B,AR,BR):-
  get_overlaps(NewIndiv1s,Rest,A,B,AR,BR), AR=BR,!.



/*
fix_the_fours(NewIndiv0s,[A,B|Rest]):- 
  predsort(sort_on(colored_pixel_count),NewIndiv0s,NewIndiv1s),
  must_be_free(A),
  get_best_overlaps(NewIndiv1s,Rest,A,B,AR,BR),
  print_side_by_side(AR,BR),
  maplist(fix_the_twos(AR),NewIndiv1s),
  maplist(fix_the_twos(BR),NewIndiv1s),!.
fix_the_fours(IO,IOS):- predsort(sort_on(colored_pixel_count),IO,IOS).
fix_the_twos(AR,B):-
   unset_points(AR,B).
*/




confirm_overlap(AR,BR):- AR==BR,!.
confirm_overlap(AR,BR):- ((\+ \+ BR=[]);(\+ \+ AR=[])),!.
confirm_overlap([A|AR],[B|BR]):-
  confirm_overlap(A,B),!,
  confirm_overlap(AR,BR).




my_call(rot90,Q,Empty):- is_empty_grid(Empty),!,Q=Empty.
my_call(rot90,Q,Arg2):- rot270(Arg2,Q).
my_call(rot180,Q,Arg2):- rot180(Arg2,Q).
my_call(rot270,Q,Arg2):- rot90(Arg2,Q).

cast_votes4([],[]).
cast_votes4([P|PP],[ExpectedQ|VV]):- 
   P=..[F,Arg2],my_call(F,ExpectedQ,Arg2),
   cast_votes4(PP,VV),!.

votes4(Q,Images,Winners):- 
  cast_votes4(Images,Votes),
  tally_some_votes([Q|Votes],Results),
  keep_winners(Results,Winners),!.



keep_winners(Results,Winners):- is_list(Results),maplist(keep_winners,Results,Winners).
keep_winners(W,_):- assertion(ground(W)),fail.
keep_winners(V4-V3-V2-V1,V1):- V1==V2;V1==V3;V1==V4.
keep_winners(V4-V3-V2-V1,V2):- V2==V1;V2==V3;V2==V4.
keep_winners(V4-V3-V2-V1,V3):- V3==V1;V3==V2;V3==V4.
keep_winners(V4-V3-V2-V1,V3):- V4==V1;V4==V2;V4==V3.
keep_winners(V1,V1):- V1 \= (_-_).
keep_winners(W,undecided(W)).

tally_some_votes([I|Images],Q):- 
  tally_votes_list(I,Images,Q).

tally_votes_list(I,[],I).
tally_votes_list(Q,[I|Images],O):-
  tally_votes(Q,I,M),
  tally_votes_list(M,Images,O).

tally_votes(I,V,I):- var(V),!.
tally_votes(I,V,V):- var(I),!.
tally_votes([],I,I):- !.
tally_votes(I,[],I):- !.
tally_votes([I|II],[H|TT],[V|MM]):-  tally_votes(I,H,V),tally_votes(II,TT,MM).
tally_votes(I,V,V-I).


votes_v_h_hv(Q2,Q3,Q1,Q4,Q2R):-     votes4(Q2,[flipV(Q3),flipH(Q1),flipHV(Q4)],Q2R).
votes_90_180_270(CN,CE,CS,CW,CNR):- votes4(CN,[rot90(CE),rot180(CS),rot270(CW)],CNR).

 reassemble(Grid,Repair),
 assemble(Repair,GR).

reassemble(X,X):-!.
reassemble(
   [[Q2,  CN,   Q1],
    [CW,  CC,   CE],
    [Q3,  CS,   Q4]],

  [[Q2R,  CNR,   Q1R],
   [CWR,   CC,   CER],
   [Q3R,  CSR,   Q4R]]):-

 must_det_l((
  votes_v_h_hv(Q2,Q3,Q1,Q4,Q2R),
  votes_v_h_hv(Q1,Q4,Q2,Q3,Q1R),
  votes_v_h_hv(Q3,Q2,Q4,Q1,Q3R),
  votes_v_h_hv(Q4,Q1,Q3,Q2,Q4R),
  votes_90_180_270(CN,CE,CS,CW,CNR),
  votes_90_180_270(CE,CS,CW,CN,CER),
  votes_90_180_270(CS,CW,CN,CE,CSR),
  votes_90_180_270(CW,CN,CE,CS,CWR))).


nb_set_insert(L,E):- arg(2,L,T),(var(T);T==[]),!,nb_setarg(2,L,[E]).
nb_set_insert([_|L],E):-nb_set_insert(L,E).



find_pattern_objects(IndvS1,AllNew):- % stack_check(100),
 must_be_free(AllNew), length(IndvS1,L), L> 70,!,
  dmsg(find_pattern_objects=L),
  into_grid(IndvS1,TempGrid),
  grid_size(TempGrid,H,V),H>5,V>5,
  globalpoints(TempGrid,Points),
  freeze(W,W>8),
  filter_indivs(IndvS1,[mass(W)];[object_shape(rectangluar), object_shape(solid)],KeepIndvS1R),
  length(KeepIndvS1R,KeepIndvS1RLen),
  dmsg(keepIndvS1R=KeepIndvS1RLen),
  globalpoints(KeepIndvS1R,RemovePoints),
  remove_global_points(RemovePoints,Points,Points2),
  points_to_grid(H,V,Points2,NewTempGrid),
  catch(call_with_time_limit(3,grid_to_3x3_objs(NewTempGrid,NewIndiv1s)),_,fail),
  flatten([NewIndiv1s,KeepIndvS1R],AllNew),!.
find_pattern_objects(IndvS1,IndvS1).



/*
assert_IndvS(obj(L)):-
  object_indv_id(obj(L),NamedExampleNum,Iv),
  maplist(assert_IndvS(NamedExampleNum,Iv),L).


globalpoints(NamedExampleNum,Iv,ListOIfColoredPoints).
globalpoint(NamedExampleNum,Iv,Color,Point).
localpoints(NamedExampleNum,Iv,ListOIfColoredPoints).
localpoint(NamedExampleNum,Iv,Color,Point).
shape(NamedExampleNum,Iv,Point).
object_size(NamedExampleNum,Iv,H,V).
object_shape(NamedExampleNum,Iv,ShapName).


assert_IndvS(NamedExampleNum,Iv,P):- P=..[F,List],is_list(List),
  maplist(assert_IndvS_L(NamedExampleNum,Iv,F),List).

assert_IndvS_L(NamedExampleNum,Iv,F),List

assert_IndvS(NamedExampleNum,Iv,P):- P=..[F|Args],
  PP=..[F,NamedExampleNum,Iv|Args],
  assert_IndvS_PP(NamedExampleNum,Iv,PP).
*/

%individuals_common(Reserved,Points,Grid,I):- is_group(Grid),!,I=Grid.
%individuals_common(Reserved,Points,obj(Grid),[obj(Grid)]):-!.


   
:- dynamic(is_group_saved/2).
:- dynamic(reuse_grid_nums/1).


enum_object(S):- is_grid_id(S,_).
enum_object(S):- is_group_saved(_,IndvS),member(S,IndvS).

store_individuals_non_shared(Gridname,Grid):- 
   set_grid_id(Grid,Gridname),
   individuals_non_shared(Grid,IndvS),
   set_named_indivs(Gridname,IndvS).

get_named_indivs(Gridname,IndvS):- 
   is_group_saved(Gridname,IndvS).

set_named_indivs(Gridname,IndvS):- 
   retractall(is_group_saved(Gridname,_)),
   asserta(is_group_saved(Gridname,IndvS)),!.

ensure_individuals_non_shared(Gridname):- is_group_saved(Gridname,_),!.
ensure_individuals_non_shared(Gridname):- is_grid_id(Grid,Gridname),!,
   store_individuals_non_shared(Gridname,Grid),!.
ensure_individuals_non_shared(Gridname):- throw(cannot_find((Gridname))).

:- style_check(+singleton).

grid_shared_with(Gridname*ExampleNum*in,Gridname*ExampleNum*out):-!.
grid_shared_with(Gridname*ExampleNum*out,Gridname*ExampleNum*in):-!.

use_shared_first(W) :- nb_current(grid_shared,W),W\==[],W\==nil.
use_shared_first:- use_shared_first(_).

get_shared_with(IndvS):- use_shared_first(With),
  ensure_individuals_non_shared(With),
  is_group_saved(With,IndvS),!.
get_shared_with([]).


get_unshared(IndvS):- use_shared_first(With),
  grid_shared_with(With,Gridname),
  ensure_individuals_non_shared(Gridname),
  is_group_saved(Gridname,IndvS),!.
get_unshared([]).


unset_nth(I,O):- delq(I,object_indv_id(_,_),O).
set_nth(I,O):- delq(I,object_indv_id(_,_),O).

get_combined(IndvC):- nb_current(test_name_w_type,NamedExampleNum), is_group_saved(NamedExampleNum,IndvC),!.
get_combined(IndvC):- nb_current(test_name_w_type,NamedExampleNum), 
   is_group_saved(NamedExampleNum*in ,IndvS1),
   is_group_saved(NamedExampleNum*out,IndvS2),
   make_combined(IndvS1,IndvS2,IndvC).
get_combined(IndvC):-get_shared_with(IndvS1),get_unshared(IndvS2),make_combined(IndvS1,IndvS2,IndvC).

with_each_indiv(G,I):- individuals(G,I).


individuals(Grid,IndvS):- 
   grid_to_id(Grid,Gridname),
   grid_shared_with(Gridname,With),
   locally(b_setval(grid_shared,With),
            individuals_common(Grid,IndvS)).

individuals_non_shared(Grid,IndvS):- 
   locally(b_setval(grid_shared,nil),
            individuals_common(Grid,IndvS)).



/*
assert_IndvS(obj(L)):-
  object_indv_id(obj(L),NamedExampleNum,Iv),
  maplist(assert_IndvS(NamedExampleNum,Iv),L).


globalpointlist(NamedExampleNum,Iv,ListOIfColoredPoints).
globalpoint(NamedExampleNum,Iv,Color,Point).
localpointlist(NamedExampleNum,Iv,ListOIfColoredPoints).
localpoint(NamedExampleNum,Iv,Color,Point).
localcolorlesspointlist(NamedExampleNum,Iv,Point).
object_size(NamedExampleNum,Iv,H,V).
object_shape(NamedExampleNum,Iv,ShapName).


assert_IndvS(NamedExampleNum,Iv,P):- P=..[F,List],is_list(List),
  maplist(assert_IndvS_L(NamedExampleNum,Iv,F),List).

assert_IndvS_L(NamedExampleNum,Iv,F),List

assert_IndvS(NamedExampleNum,Iv,P):- P=..[F|Args],
  PP=..[F,NamedExampleNum,Iv|Args],
  assert_IndvS_PP(NamedExampleNum,Iv,PP).
*/

individuals_common(Grid,I):- is_objectlist(Grid),!,I=Grid.
individuals_common(obj(Grid),[obj(Grid)]):-!.


maybe_shared_individuals_list(Types,Points,IndvList,Unused):- 
  use_shared_first, mmake,
  get_combined(IndvSC), 
  consume_shared_individual_points(IndvSC,Types,Points,IndvList,Unused).
maybe_shared_individuals_list(_Types,UnusedPoints,[],UnusedPoints):- !.

unraw_inds(IndvS,IndvO):-   
  largest_first(IndvS,Indv1),
  reverse(Indv1,IndvR),
  %test_cond_or(indiv(min(SZ)),1),
  SZ=0,
  check_minsize(SZ,IndvR,Indv),
  unraw_inds2(_,Indv,IndvO),!.

%individuals_list_diamonds(_,Indv,Indv1):-
%  individuals_list(diamonds,ID,Indv,Indv1).


consume_shared_individual_points([],_Types,UnusedPoints,[],UnusedPoints):- !.
consume_shared_individual_points([H|T],Types,Points,[H|IndvList],Unused):-  
  globalpointlist(H,GPoints), remove_gpoints(GPoints,Points,LeftOver),
  consume_shared_individual_points(T,Types,LeftOver,IndvList,Unused).
consume_shared_individual_points([_|T],Types,Points,IndvList,Unused):-  
  consume_shared_individual_points(T,Types,Points,IndvList,Unused).



   

obj1(X,X).

ok_color_with(C,C2):- /* \+ free_cell(C2), */ C==C2.

sameglobalpoints(Points,IndvC,LeftOver,IndvC):-
  globalpointlist(IndvC,GPoints),
  remove_gpoints(GPoints,Points,LeftOver).

remove_gpoints([],Rest,Rest).
remove_gpoints([GPoint|GPoints],Points,Rest):- select(GPoint,Points,Mid),remove_gpoints(GPoints,Mid,Rest).


find_one_individual_from_combined(Types,Points,[Indv1|IndvList],Unused):-
  get_combined(IndvSC),
  maplist(sameglobalpoints(Points,Indv1,LeftOver),IndvSC),
  find_one_individual_from_combined(Types,LeftOver,IndvList,Unused).
find_one_individual_from_combined(_Types,UnusedPoints,[],UnusedPoints).

find_one_individual(Types,Points,Indv,NextScanPoints):- fail,
  use_shared_first,
  find_one_individual_from_combined(Types,Points,Indv,NextScanPoints).

find_one_individual(Types,Points,Indv,NextScanPoints):-
    select(C-HV,Points,Rest), \+ free_cell(C), 
    allow_dirs(Types,Dir),
    adjacent_point_allowed(C,HV,Dir,HV2),select(C2-HV2,Rest,ScanPoints),ok_color_with(C,C2),
  /*  nop((\+ filtered_point(C,HV2), \+ filtered_point(C,HV),
     (\+ is_diag(Dir)-> true ; (turn_left_45(Dir,TR),turn_right_45(Dir,TL),color_of(HV,TL,TLC),color_of(HV,TR,TRC),
      \+ (colors_block_diag(C,TLC,TRC,C2)))))),*/
    all_individuals_near(Types,C,[C-HV,C2-HV2],ScanPoints,NextScanPoints,Indv),
    meets_indiv_criteria(Indv).

color_of(HV,TL,TLC):- t_l:id_cells(_ID,Points), is_adjacent_point(HV,TL,TLHV),member(TLC-TLHV,Points).

colors_block_diag(C,TLC,TRC,_C2):- TLC==TRC, TRC\==0, C \== TRC, \+ free_cell(TRC).

filtered_point(C,HV):- t_l:id_cells(_ID,Points),% select(_-HV,Points,Rest), 
  findall(Dir-HV2,(adjacent_point_allowed(C,HV,Dir,HV2),member(C-HV2,Points)),Used),
  findall(Dir-HV2,(adjacent_disallowed(C,HV,Dir,HV2),member(C-HV2,Points)),Unused),
  shape_has_filtered_use(C,Used,Unused),
  %wdmsg(shape_has_filtered_use(C,HV,Used,Unused)),
  !.

shape_has_filtered_use(_,[],_Unused).
shape_has_filtered_use(C,[_],_):- shape_filter(C,squares),!.

adjacent_groups(C,Grp1,Dir,Grp2):- member(_-P1,Grp1),member(C-P2,Grp2),is_adjacent_point(P1,Dir,P2).
adjacent_point(C,HV,HV2):- adjacent_point_allowed(C,HV,_Dir,HV2).
adjacent_point_allowed(C,HV,Dir,HV2):- is_adjacent_point(HV,Dir,HV2), shape_filter(C,Shape),allow_dir(Shape,DirS),member(Dir,DirS).
adjacent_disallowed(C,HV,Dir,HV2):- is_adjacent_point(HV,Dir,HV2), shape_filter(C,Shape),allow_dir(Shape,DirS), \+ member(Dir,DirS).

allow_dirs(Square,X):- allow_dir(Square,List),member(X,List).
allow_dir(horizs,[e,w]). allow_dir(virtzs,[n,s]). allow_dir(diaguz,[ne,sw]). allow_dir(diagdz,[nw,se]). 
allow_dir(squares,[n,s,e,w]). allow_dir(polygs,[n,s,e,w]).
allow_dir(diamonds,[nw,sw,se,ne]).
%circles, dots, , rays, walls

shape_filter(X,squares):- free_cell(X).
shape_filter(X,polygs):- \+ free_cell(X).


ok_dir(s). ok_dir(e). ok_dir(n). ok_dir(w).
ok_dir(_) :- \+ squares.
squares:-true.


meets_indiv_criteria(_).

all_individuals_near(_Types,_C,NewSet,[],[],[],NewSet):-!.
all_individuals_near(Types,C,Indv,ScanPoints,NewScanPoints,NewSet):-
   individuals_near(Types,C,Indv,ScanPoints,New,NextScanPoints),
   (New == [] -> (NewSet = Indv, NewScanPoints = NextScanPoints)
    ; (append(Indv,New,IndvNew),
        all_individuals_near(Types,C,IndvNew,NextScanPoints,NewScanPoints,NewSet))).

individuals_near(_Types,_C,_From,[],[],[]):-!.
individuals_near(Types,C,From,[E|ScanPoints],[E|Nears],NextScanPoints):- nearby_one(Types,C,E,From),!,
  individuals_near(Types,C,[E|From],ScanPoints,Nears,NextScanPoints).

individuals_near(Types,C,From,[E|ScanPoints],Nears,[E|NextScanPoints]):- 
      individuals_near(Types,C,From,ScanPoints,Nears,NextScanPoints).

nearby_one(Types,C,C2-E,List):- allow_dirs(Types,Dir), adjacent_point_allowed(C,E2,Dir,E), member(C2-E2,List),ok_color_with(C2,C).


check_minsize(Sz,Indv1,Indv):- include(meets_size(Sz),Indv1,Indv).

meets_size(Len,Points):- mass(Points,L),!,L>=Len.

remove_bgs(IndvS,IndvL,BGIndvS):- partition(is_bg_indiv,IndvS,BGIndvS,IndvL).

is_bg_indiv(O):- colors_count(O,[color_count(C,CC)]),CC>0,is_black(C).

smallest_first(IndvS,IndvO):-
  findall(Size-Indv,(member(Indv,IndvS),mass(Indv,Size)),All),
  keysort(All,AllK),
  findall(Indv,member(_-Indv,AllK),IndvO).

largest_first(IndvS,IndvR):-  
  smallest_first(IndvS,IndvO),
  reverse(IndvO,IndvR).

largest_first_nonbg(IndvS,IndvOB):-  
  largest_first(IndvS,IndvO),
  remove_bgs(IndvO,IndvL,BGIndvS),
  append(IndvL,BGIndvS,IndvOB).

finish_grp(C,Grp,Point2,Dir,Rest,NewGroup,RRest):- 
   \+ (is_diag(Dir),is_black(C)),
   is_adjacent_point(Point2,Dir,Point3),
   single_point(C-Point3,Rest,Rest1),
   finish_grp(C,[C-Point3|Grp],Point3,Dir,Rest1,NewGroup,RRest).
finish_grp(_C,Grp,_From,_Dir,Rest,Grp,Rest).


reserved_point(C-Point):- fail, \+ get_shared_with(With), member(Obj,With),
  globalpointlist(Obj,GPoints), \+ (member(CC-Point,GPoints), CC==C).

single_point(C-Point,IndvS,Rest1):-
  single_point0(C-Point,IndvS,Rest1),
   reserved_point(C-Point).

single_point0(C-Point,IndvS,Rest1):-
  select([C-Point],IndvS,Rest1),
  nonvar(C), trace.
single_point0(C-Point,IndvS,Rest1):-
  select(C-Point,IndvS,Rest1),
  nonvar(C), trace.
single_point0(C-Point,IndvS,Rest1):- 
  select(obj(I),IndvS,Rest1), fail, % round 2
  globalpointlist(obj(I),[C-Point]),
  nonvar(C).

/*
unraw_inds2(Types,IndvS,IndvO):- fail,
   largest_first(IndvS,Indv1),
   reverse(Indv1,IndvR), IndvR\=@=IndvS,
   unraw_inds2(Types,IndvR,IndvO).
*/

unraw_inds2(Types,IndvS,IndvO):-   
  single_point(C-Point1,IndvS,Rest1), nonvar(C), % \+ free_cell(C),\+ get_bgc(C),
  is_diag(Dir),
  is_adjacent_point(Point1,Dir,Point2),
  single_point(C-Point2,Rest1,Rest2),
  is_adjacent_point(Point2,Dir,Point3),
  single_point(C-Point3,Rest2,Rest),
  finish_grp(C,[C-Point3,C-Point2,C-Point1],Point3,Dir,Rest,NewGroup1,RRest),
  reverse(NewGroup1,NewGroupR),
  reverse_nav(Dir,RevDir),
  finish_grp(C,NewGroupR,Point1,RevDir,RRest,NewGroup,RRestO),
  unraw_inds2(Types,[NewGroup|RRestO],IndvO).

unraw_inds2(Types,IndvS,IndvO):-  fail,
  single_point(C-Point1,IndvS,Rest1), nonvar(C), \+ free_cell(C),
  single_point(C2-Point2,Rest1,Rest),
  findall(C3-Point3,member([C3-Point3],Rest),CRest),
  subtract(Rest,CRest,IndvM),
  unraw_inds2(Types,IndvM,IndvMO),
  Grp=[C-Point1,C2-Point2|CRest],
  IndvO=[Grp|IndvMO].

unraw_inds2(Types,IndvS,IndvO):- 
  single_point(C-Point1,IndvS,Rest1),
  Grp=[_,C-_,_|_],
  select(Grp,Rest1,Rest),
  is_diag(Dir),
  adjacent_groups(C,[C-Point1],Dir,Grp),
  unraw_inds2(Types,[[C-Point1|Grp]|Rest],IndvO).

/*
unraw_inds2(Types,IndvS,IndvO):-   
  select([C1-Point1],IndvS,Rest),
  nearby_one(Types,C,C1-Point1,Rest),
  select([C-Point2],Rest1,Rest),
  findall(C-Point,member([C-Point],Rest),CRest),
  subtract(Rest,CRest,IndvM),
  unraw_inds2(Types,IndvM,IndvMO),
  Grp=[C-Point1,C-Point2|C-Rest],
  IndvO=[Grp|IndvMO].
*/
unraw_inds2(_,IndvS,IndvS).


:- thread_local(t_l:id_cells/2).

deoffset_points(1,1,Points,Points):-!.
deoffset_points(OH,OV,Point,LPoint):- map_pred(if_point_de_offset(OH,OV),Point,LPoint).
if_point_de_offset(OH,OV,Point,LPoint):- atom(Point), hv_point(H,V,Point),HH is H -OH +1, VV is V - OV +1,hv_point(HH,VV,LPoint).

offset_points(OH,OV,Point,LPoint):- map_pred(if_point_offset(OH,OV),Point,LPoint).
if_point_offset(OH,OV,Point,LPoint):- atom(Point), hv_point(H,V,Point),HH is H +OH -1, VV is V + OV -1,hv_point(HH,VV,LPoint).

grid_to_individual(Grid,OUT):-
  grid_to_id(Grid,GN),
  grid_size(Grid,H,V),
  globalpointlist(Grid,Points),
  embue_points(GN,H,V,1,1,H,V,Points,OUT).

make_embued_points(Grid,H,V,Indv2,IndvS):- 
  grid_to_id(Grid,GN),
  maplist(embue_points(GN,H,V),Indv2,IndvS).

%embue_points(GN,_,_,I,I):-!.
embue_points(_,_,_,obj(Ps),obj(Ps)):-!.
embue_points(GN,H,V,Points,OUT):- 
  points_range(Points,LoH,LoV,HiH,HiV,_HO,_VO),
  embue_points(GN,H,V,LoH,LoV,HiH,HiV,Points,OUT).

embue_points(GN,H,V,LoH,LoV,HiH,HiV,C-HV,OBJ):- !, embue_points(GN,H,V,LoH,LoV,HiH,HiV,[C-HV],OBJ).
embue_points(NamedExampleNum,H,V,LoH,LoV,HiH,HiV,Points,obj(Ps)):-
 assertion(ground(Points)),
 flag(indiv,Iv,Iv+1),
 must_det_l((
  colors_count(Points,CC),
  length(Points,Len),
  Width is HiH-LoH+1,
  Height is HiV-LoV+1,
  %nb_current(test_name_w_type,NamedExampleNum),
  
  %gensym(id_,IID),
  Area is Width * Height,
  Empty is  Area - Len,
  deoffset_points(LoH,LoV,Points,LPoints),
  findall(object_shape(Shape),guess_shape(Ps,Empty,Len,Width,Height,CC,Points,Shape),Shapes),
  remove_color(LPoints,CLPoints),
  append([[
    localcolorlesspointlist(CLPoints),
    colors_count(CC),
    object_size(Width,Height),
    mass(Len)],Shapes,
    %width(Width), height(Height), area(Area),
    %missing(Empty),
    [localpointlist(LPoints)],
    [loc_xy(LoH,LoV)],
    [globalpointlist(Points),
    object_indv_id(NamedExampleNum,Iv),
    grid_size(H,V)]],Ps))).


object_indv_id(I,NamedExampleNum,Iv):- indv_props(I,L),member(object_indv_id(NamedExampleNum,Iv),L),!.
object_indv_id(_,NamedExampleNum,_Iv):- nb_current(test_name_w_type,NamedExampleNum).

mass(_-P,1):- nonvar(P),!.
mass(I,X):- indv_props(I,L),member(mass(X),L),!.
mass(obj(I),Count):- localpointlist(I,Points), length(Points,Count),!.
mass(Points,Count):- is_list(Points),length(Points,Count),!.
remove_color(_-P,P).
remove_color(LPoints,CLPoints):- maplist(remove_color,LPoints,CLPoints).

decl_pt(setq(object,any,object)).

setq(Orig,Todo,Result):- metaq(setq_1,Orig,Todo,Result).
setq_1(_Old,New,Saved):- Saved=New.
delq(Orig,Todo,Result):- metaq(delq_1,Orig,Todo,Result).
delq_1(_Old,_New,Saved):- Saved=delq.


metaq(_,Orig,[],Orig):-!.
metaq(P3,Orig,[New|Todo],Result):- !, metaq(P3,Orig,New,Midway),metaq(P3,Midway,Todo,Result).
metaq(P3,Orig,New,Saved):- functor(New,F,A),functor(Old,F,A),Did=done(nil),map_pred(metaq_1(P3,Did,Old,New),Orig,Saved).
metaq_1(_,done(t),_,_,Orig,Orig):-!.
metaq_1(P3,Did,Old,New,Orig,Saved):- compound(Orig),Orig=Old, call(P3,Old,New,Saved),nb_setarg(1,Did,t).



indv_props(obj(L),L):- is_list(L).
indv_props(obj(L),L):- enum_object(obj(L)).

localpointlist(I,X):- indv_props(I,L),member(localpointlist(X),L).
object_shape(I,X):- indv_props(I,L),member(object_shape(X),L).

hv_cvalue(Grid,Color,H,V):- hv_cg_v alue(Grid,C,H,V),as_cv(C,Color).
as_cv(C,Color):- var(C),color_code(C,Color).
as_cv(C,Color):- integer(C),!,color_code(C,Color).
as_cv(C,Color):- atom(C),!,color_code(C,Color).
as_cv(C-_,Color):- as_cv(C,Color).

globalpointlist(Grid,Points):- is_grid(Grid),!, grid_size(Grid,HH,HV), 
  findall(C-Point,(between(1,HV,V),between(1,HH,H),hv_cvalue(Grid,C,H,V),nonvar(C),hv_point(H,V,Point)),Points),
  assertion(ground(Points)).
%globalpointlist(Grid,Points):- is_object(Grid),!,globalpointlist(Grid,Points).
globalpointlist(Grid,Points):- is_objectlist(Grid),!,maplist(globalpointlist,Grid,MPoints),flatten(MPoints,Points).
globalpointlist(I,X):- indv_props(I,L),member(globalpointlist(X),L).
/*
globalpointlist(ID,Points):- \+ \+ cmem(ID,_,_), findall(-(C,HV),cmem(ID,HV,C),Points).
globalpointlist(Grid,Points):- grid_to_id(Grid,ID),findall(-(C,HV),cmem(ID,HV,C),Points).
:- dynamic(is_grid_id/2).
grid_to_id(Grid,ID):- is_grid_id(Grid,ID),!.
grid_to_id(Grid,ID):- gensym('grid_',ID),assert_id_grid_cells(ID,Grid),assert(is_grid_id(Grid,ID)),!.
*/

colors_count(I,X):- indv_props(I,L),!,member(colors_count(X),L).

colors_count(G,BFO):- pixels(G,GF),sort(GF,GS),count_each(GS,GF,UC),keysort(UC,KS),reverse(KS,SK),into_cc(SK,BFO).

localcolorlesspointlist(I,X):- indv_props(I,L),member(localcolorlesspointlist(X),L).

loc_xy(I,X,Y):- indv_props(I,L),member(loc_xy(X,Y),L).
object_size(I,X,Y):- indv_props(I,L),member(object_size(X,Y),L).
object_size(Points,H,V):- pmember(object_size(H,V),Points),!.
object_size(Points,H,V):- points_range(Points,LoH,LoV,HiH,HiV,_,_), H is HiH-LoH+1, V is HiV-LoV+1.

top(8).

:- style_check(-singleton).
guess_shape(I,Empty,N,1,1,Colors,Points,dot):- !.
guess_shape(I,Empty,N,N,1,Colors,Points,hline).
guess_shape(I,Empty,N,1,N,Colors,Points,vline).
guess_shape(I,Empty,N,H,V,[color_count(Zero,_)],Points,background):- (Zero==0;Zero==black).
guess_shape(I,0,N,HV,HV,Colors,Points,square):- HV>1.
guess_shape(I,0,N,H,V,Colors,Points,solid).
guess_shape(I,O,N,H,V,Colors,Points,nonsolid):- O\==0.

guess_shape(I,E,N,H,V,Colors,Points,subI(InvS)):- E>2, fail,
   once((I.loc_xy=loc_xy(LoH,LoV),
   make_unassigned_grid(H,V,Grid),
   calc_add_points(LoH,LoV,Grid,Points),
   individuals(Grid,InvS))),!,
   InvS=[_,_|_].




/*
points_name(E,Name):- 
 props_of_points(E,Ns),
  ignore((get_grid_nums(Nums),nth0(N,Nums,EE),EE=@=E,i_sym(N,Code),format(atom(Name),' Individual #~w  Code: "~s" ~w',[N,[Code],Ns]))),!.
points_name(E,pop(Ns)):- props_of_points(E,Ns).
*/
/*
print_list_of_points(N,H,V,PL):- 
  length(PL,Len),
  wqnl(N=list_of_points(Len)),!, 
  ignore((nop(debug_indiv),  
    forall(nth1(I,PL,E),print_points(N:I,H,V,E)))).

% print_points(N,H,V,E):- nop(print_points(N,H,V,E)),!.
print_points(N,H,V,E):- 
  dash_char(H,"-"),nl,  
  points_name(E,Name),
  write(Name), write(' from '),writeln(N),
  points_range(E,LoH,LoV,HiH,HiV,H,V),length(E,Len),wqnl(len(Len)->offset_ranges(LoH,LoV,HiH,HiV,H,V)),
  
  print_grid(1,1,LoH,LoV,HiH,HiV,H,V,E),dash_char(H,"-"),!,
  nl.

*/


/*
get_grid_num(C-Point,N):-
  hv_point(X,Y,Point),
  get_grid_num_xyc(X,Y,C,N).

get_grid_num(Point,N):-
  hv_point(X,Y,Point),
  get_grid_num_xyc(X,Y,_C,N).

get_grid_num_xyc(X,Y,C,N):- fail,
  hv_point(X,Y,Point),
  get_grid_nums(GridsN),
  nth0(N,GridsN,E),
  once((((member(C-PPoint,E);member(PPoint,E)),nonvar(PPoint),Point=PPoint);hv_cg _value(E,C,X,Y))).

get_grid_nums(GridNums):-
  nb_current(test_name_w_type,NameType),
  (grid_nums(NameType,Grids1)->true;Grids1=[]),
  (grid_nums(Grids0)->true;Grids0=[]),
  append(Grids1,Grids0,GridNums).


:- thread_local(grid_nums/2).
:- thread_local(grid_nums/1).
dead_set_grid_nums(Gs):- 
   nb_current(test_name_w_type,NameType),
   asserta(grid_nums(NameType,Gs)).
*/

/*
try_arc_io(CName,Name,ExampleNum,In,Out):-
  ignore((CName\==Name,flag(indiv,_,0),dash_char(60,"A"),dash_char(6,"\n"),nl)), 
  grid_info(Name,ExampleNum*in,In), %print_tree_nl(in=UnsharedIn),
  grid_info(Name,ExampleNum*out,Out), %print_tree_nl(out=UnsharedOut),
  !,
  % \+ \+ ignore(((ExampleNum=trn+_), test_config(learn(CProg)),must(training_progs(CProg,In,Out)))),
/*
  compute_diff(UnsharedIn,UnsharedOut,Diffs),!,
  nop(pt(diffs=Diffs)),
*/
    %trace, 
    get_combined(IndvO),
    print_grid(IndvO),
    maybe_confirm_sol(Name,ExampleNum,In,Out),nl,!.
*/
 /*

% Grid pretty printing
grid_info(Name,IO,Grid):- 
  PairName = (Name*IO),
  test_info(Name,InfoF),
  wqnl(fav(PairName,InfoF)),
  set_grid_id(Grid,PairName),
  describe_feature(Grid,[grid_dim,colors_count_size,colors_count,num_objects]),
  compute_shared_indivs(Grid,UnsharedIn),
  colors_count_size(Grid,CCS),
  ignore((sub_var(in,IO),(CCS>4;debug_indiv;true), debug_indiv(UnsharedIn))),
  print_grid(PairName,UnsharedIn,[Grid]),
  ignore((sub_var(out,IO),(CCS>4;debug_indiv;true), debug_indiv(UnsharedIn))),
  nop(describe_feature(Grid,[compute_shared_indivs])),!.
*/
% resize(H,V,Grid1,Grid2):- var(Grid2),grid_size(Grid1,C1),grid_size(Grid2,C2).


make_combined(IndvS1,IndvS2,BetterC):-
  append(IndvS1,IndvS2,IndvSU),list_to_set(IndvSU,IndvS),
  smallest_first(IndvS,IndvC),
  cleanup(IndvC,BetterC),
  nb_current(test_name_w_type,NamedExampleNum),
  set_named_indivs(NamedExampleNum,BetterC),!.

cleanup(IndvC,BetterC):-
  append(Left,[B|Bigger],IndvC),
  append(LeftB,[A|RBigger],Bigger),
  compute_diff(A,B,same_object(_)),!,
  object_indv_id(B,NamedExampleNum,Iv),
  setq(A,object_indv_id(B,NamedExampleNum,Iv),AA),
  append([Left,LeftB,RBigger,[AA]],MissingAB),
  cleanup(MissingAB,BetterC).
cleanup(A,A).



/*
*/
grid_indexer_cache(2,2,3,3,
[_,_,
 [_,_,X1,Y1,Z1|_],
 [_,_,X2,Y2,Z2|_],
 [_,_,X3,Y3,Z3|_]|_],
[[X1,Y1,Z1],
 [X2,Y2,Z2],
 [X3,Y3,Z3]]).


grid_indexer_cache(2,3,3,3,
[_,_,_,
 [_,_,X1,Y1,Z1|_],
 [_,_,X2,Y2,Z2|_],
 [_,_,X3,Y3,Z3|_]|_],
[[X1,Y1,Z1],
 [X2,Y2,Z2],
 [X3,Y3,Z3]]).


:- dynamic(grid_indexer_cache/6).

% make_grid_indexer(H,V,FH,FV,FindRow,Indexer):- grid_indexer_cache(H,V,FH,FV,FindRow,Indexer),!.
make_grid_indexer(H,_V,FH,_FV,_FindRow,_Indexer):- TH is H+FH, TH>30,!.
make_grid_indexer(_H,V,_FH,FV,_FindRow,_Indexer):- TV is V+FV, TV>30,!.
make_grid_indexer(H,V,FH,FV,FindRow,Indexer):-
  length(Above,V),
  make_row(FV,Rows),
  make_rows(FV,H,Rows,FH,FindRow),
  Before = _,
  append(Above,Rows,AR), append(AR,Before,Indexer),!.
  %grid_indexer_cache(H,V,FH,FV,FindRow,Indexer).

make_rows(FV,H,[Row|RO],VH,[FindRow|FRO]):- length(LPad,H),length(FindRow,H),
 append(LPad,FindRow,LPF), append(LPF,_,Row),!, FV1 is FV -1, make_rows(FV1,H,RO,VH,FRO).
make_rows(0,_,[],_,[]):-!.

%make_grid_indexer:- grid_indexer_cache(27,27,27,27,_,_),!.
make_grid_indexer:- 
 tell('gi_cache'),
 writeln(':- module(gi_cache,[igic/6]). \n'),
 forall(between(0,29,H),
  forall(V=0, %between(0,29,V),
   forall(between(1,30,FH),
    forall(between(1,30,FV),
     (make_grid_indexer(H,V,FH,FV,R,L),writeq(igic(H,V,FH,FV,R,L)),writeln('.')))))),
 told.

%:- ensure_loaded(gi_cache).


gr2o(Grid,Obj):- localpoints(Grid,NoisePoints), make_indiv_object(NoisePoints,[object_shape(noise)],Obj),!.
%gr2o(Grid,Obj):- Grid=Obj.

make_indivs(Pred,In,Out,InC,OutC):-
 %locally(i_o_w(In,Out),
  make_indivs1(Pred,In,Out,InC,OutC).

make_indivs1(Pred,In,Out,InC,OutC):-
  mass(Out,OMass), mass(In,IMass), OMass>IMass,
  make_indivs_no_swap(Pred,Out,In,OutC,InC),
  save_off(Pred,In,Out,InC,OutC).

make_indivs1(Pred,In,Out,InC,OutC):- 
  make_indivs_no_swap(Pred,In,Out,InC,OutC),
  nop(save_off(Pred,In,Out,InC,OutC)).

save_off(_Pred,_In,_Out,InC,OutC):-
 ((
  get_training(Training),!,
  pred_intersection(overlap_same_obj,InC,OutC,RetainedIn,_RetainedOut,Removed,Added),!,
  add_shape_lib(pair,Removed),!,  
  add_shape_lib(pair,Added),!,
  add_shape_lib(pair,RetainedIn),!,
  %rtrace,
  % % %  set(Training.grid_in) = In,!,
  %trace,

  % % %  set(Training.grid_out) = Out,
  % % %  set(Training.inC) = InC,
  % % %  set(Training.outC) = OutC,
  % % %  set(Training.added) = Added,
  % % %  set(Training.removed) = Removed,
  % % %  set(Training.kept) = RetainedIn,
  %nortrace,
  nop(set_training(Training)))),!.

make_indivs_no_swap(Pred,In,Out,InC,OutC):-
 must_det_ll((
  writeln(inC(Pred)),
  %rtrace,
  call_indv(Pred,In,InC),
  add_shape_lib(pair,InC),!,
  writeln(outC(Pred)),
  call_indv(Pred,Out,OutC),
  %add_shape_lib(out,OutC),
  writeln(inOutC(Pred)))),!.

call_indv(Pred,Out,OutC):-
 must_det_ll((
  %get_training(Training),
  % % %  set(Training.grid) = Out, % % %  set(Training.grid_o) = Out,
  %% % %  set(Training.objs) = _, % % %  set(Training.points) = _,
  %% % %  set(Training.robjs) = _, % % %  set(Training.points_o) = _,
  %grid_size(Out,H,V), % % %  set(Training.h) = H, % % %  set(Training.v) = V,
  %nortrace,
  call(Pred,Out,OutC))),!.
  %set_training(Training).


/*
show_indivs(IH,IV,OH,OV,Pred,When,PairName,In,Out,SF):-  
  ignore(IH=1),
  LW is (IH * 2 + 12),
  append_term_safe(When,Pred+PairName+in,NameIn),
  append_term_safe(When,Pred+PairName+out,NameOut),
  wots(U1, print_grid(IH,IV,NameIn,In)),
  wots(U2, print_grid(OH,OV,NameOut,Out)),
  print_side_by_side(U1,LW,U2),
  my_append(InC,OutC,InOutC),
  smallest_first(InOutC,SF),
  %largest_first(InOutC,LF),
  %show_pair_no_i(IH,IV,OH,OV,smallest_first(When,Pred),PairName,InC-SF,OutC-SF),
  %wots(U3, print_grid(IH,IV,NameIn,InC-SF)),wots(U4, print_grid(OH,OV,NameOut,OutC-SF)),print_side_by_side(U3,LW,U4),
  %max_min(IH,OH,H,_),max_min(IV,OV,V,_),
  show_pair_no_i(IH,IV,OH,OV,normal(When,Pred),PairName,InC,OutC),
  INFO = [grid_dim,mass,colors_count_size,colors],
  print_side_by_side(
     describe_feature(InC,[call(writeln('IN'))|INFO]),LW,
    describe_feature(OutC,[call(writeln('OUT'))|INFO])),!,
  show_pair_I_info(NameIn,NameOut,InC,OutC).
*/







  /*

  nop((
       show_indivs(IH,IV,OH,OV,individuate_complete,early,PairName,In,Out,SF),
       forall((rtrace_on_error(individualizer_heuristics(PairName,In,Out,IH,IV,OH,OV))),true), 
       add_shape_lib(pairs,SF),
       show_shape_lib(in),show_shape_lib(out),show_shape_lib(pair),show_shape_lib(noise),
       show_indivs(IH,IV,OH,OV,individuate_default,later,PairName,In,Out,_))),!,
       with_named_pair(solve,TestID,PairName,In,Out),
*/
/*
  remove_global_points(UnsharedIn,In,InForgotten),
  remove_global_points(UnsharedOut,Out,OutForgottenM),
  ((mass(OutForgottenM,OM),OM==0) -> OutForgotten=OutC; OutForgotten=OutForgottenM),
  individuate(complete,InForgotten,ForgottenShapesIn),
  individuate(complete,OutForgotten,ForgottenShapesOut),

  % contains_points(InForgotten);contains_points(OutForgotten)
  %show_pair_no_i(IH,IV,OH,OV,forgotten,PairName,ForgottenShapesIn,ForgottenShapesOut),

  show_pair_no_i(IH,IV,IH,IV,forgotten_In,PairName,UnsharedIn,ForgottenShapesIn),
  show_pair_no_i(OH,OV,OH,OV,forgotten_Out,PairName,ForgottenShapesOut,OutC),
*//*
       show_indivs(In,Out),
       individuate(defaults,In,InC),
       individuate(defaults,Out,OutC),  
       writeln(outC),

       clear_shape_lib(out),
       clear_shape_lib(in),
       add_shape_lib(out,OutC),
       writeln(inOutC),
       show_pair_i(IH,IV,OH,OV,early_test,PairName,InC,OutC),
       writeln(inC),
       individuate(defaults,In,UnsharedIn),
       writeln(outC),
       individuate(defaults,Out,UnsharedOut),
       writeln(inUnsharedOut),
       show_pair_i(IH,IV,OH,OV,late_test,PairName,UnsharedIn,UnsharedOut),
       format('~N1-sofar~N1'),!,
       %pt(yellow,in=UnsharedIn),
       pred_intersection(compare_objs1([same]),UnsharedIn,UnsharedOut,_CommonCsIn,_CommonCsOut,_IPCs,_OPCs),
       format('~N1-pred_intersection~N1'),
        individuate(UnsharedOut,Out,SharedInR),
        individuate(UnsharedIn,In,SharedOutR),
        show_pair_no_i(IH,IV,OH,OV,shared,PairName,SharedInR,SharedOutR))), !.*/
  %format('~N1-Rule made from~N1'),
  %show_rules,
/*  RESS =.. [res,unsharedIn=UnsharedIn,
             %onlyIn= IPCs,
            commonIn=CommonCsIn,commonOut=CommonCsOut, %onlyOut=OPCs, 
             unsharedOut=UnsharedOut],
  tersify(RESS,ShortInfo),         
  format('~N1-Stats:~N1'),
  pt(yellow,sol=ShortInfo), !.
  */
	
/*
  
  nop((reuse_indivs(SharedIn,SharedOut,BetterA,BetterB),
  ( (SharedOut\==BetterB ; SharedIn\== BetterA) ->
    show_pair_i(IH,IV,OH,OV,better,PairName,BetterA,BetterB);
     writeln('nothing better')))),
*/
  


