<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover" />

	<meta name="description" content="A diagram where each node contains a chart rendered by Chart.js." />

	<title>ARC Challenge Previewer</title>
	<script src="../../samples/assets/require.js"></script>
</head>

<body>
	<!-- Start of GoJS sample code -->
	<script src="../../release/go.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.3/Chart.bundle.min.js"></script>
	<!--div id="allSampleContent" class="p-4 w-full"-->
	<script src="../../extensions/Figures.js"></script>
	<script src="../../extensions/DrawCommandHandler.js"></script>
	<script id="code">
		function init() {

			// Since 2.2 you can also author concise templates with method chaining instead of GraphObject.make
			// For details, see https://gojs.net/latest/intro/buildingObjects.html
			const $ = go.GraphObject.make;

			myDiagram =
				$(go.Diagram, "myDiagramDiv", {
					"grid.visible": true,
					allowCopy: false,
					"draggingTool.dragsTree": true,
					"commandHandler.deletesTree": true,
					"undoManager.isEnabled": true,
					//	initialAutoScale: go.Diagram.Uniform,
					//layout: $(go.LayeredDigraphLayout),
					// layout: $(go.TreeLayout, { angle: 90, arrangement: go.TreeLayout.ArrangementFixedRoots }),
					layout: $(go.TreeLayout),
					padding: 20,	// extra space when scrolled all the way
					grid: $(go.Panel, "Grid",	 // a simple 10x10 grid
						$(go.Shape, "LineH", { stroke: "lightgray", strokeWidth: 0.5 }),
						$(go.Shape, "LineV", { stroke: "lightgray", strokeWidth: 0.5 })
					),
					"draggingTool.isGridSnapEnabled": true,
					handlesDragDropForTopLevelParts: true,
					mouseDrop: e => {
						// when the selection is dropped in the diagram's background,
						// make sure the selected Parts no longer belong to any Group
						var ok = e.diagram.commandHandler.addTopLevelParts(e.diagram.selection, true);
						if (!ok) e.diagram.currentTool.doCancel();
					},
					commandHandler: $(DrawCommandHandler),	 // support offset copy-and-paste
					"clickCreatingTool.archetypeNodeData": { text: "NEW NODE" },	 // create a new node by double-clicking in background
					"PartCreated": e => {
						var node = e.subject;	// the newly inserted Node -- now need to snap its location to the grid
						node.location = node.location.copy().snapToGridPoint(e.diagram.grid.gridOrigin, e.diagram.grid.gridCellSize);
						setTimeout(() => {	// and have the user start editing its text
							e.diagram.commandHandler.editTextBlock();
						}, 20);
					},
					"commandHandler.archetypeGroupData": { isGroup: true, text: "NEW GROUP" },
					"SelectionGrouped": e => {
						var group = e.subject;
						setTimeout(() => {	// and have the user start editing its text
							e.diagram.commandHandler.editTextBlock();
						})
					},
					"LinkRelinked": e => {
						// re-spread the connections of other links connected with both old and new nodes
						var oldnode = e.parameter.part;
						oldnode.invalidateConnectedLinks();
						var link = e.subject;
						if (e.diagram.toolManager.linkingTool.isForwards) {
							link.toNode.invalidateConnectedLinks();
						} else {
							link.fromNode.invalidateConnectedLinks();
						}
					},
					"undoManager.isEnabled": true
				});


			// Node template

			myDiagram.nodeTemplate =
				$(go.Node, "Auto", {
					locationSpot: go.Spot.Center, locationObjectName: "SHAPE",
					desiredSize: new go.Size(120, 60), minSize: new go.Size(40, 40),
					resizable: true, resizeCellSize: new go.Size(20, 20)
				},
					// these Bindings are TwoWay because the DraggingTool and ResizingTool modify the target properties
					new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
					new go.Binding("desiredSize", "size", go.Size.parse).makeTwoWay(go.Size.stringify),
					$(go.Shape, { // the border
						name: "SHAPE", fill: "white",
						portId: "", cursor: "pointer",
						fromLinkable: true, toLinkable: true,
						fromLinkableDuplicates: true, toLinkableDuplicates: true,
						fromSpot: go.Spot.AllSides, toSpot: go.Spot.AllSides
					},
						new go.Binding("figure"),
						new go.Binding("fill"),
						new go.Binding("stroke", "color"),
						new go.Binding("strokeWidth", "thickness"),
						new go.Binding("strokeDashArray", "dash")),
					// this Shape prevents mouse events from reaching the middle of the port
					$(go.Shape, { width: 100, height: 40, strokeWidth: 0, fill: "transparent" }),
					$(go.TextBlock, { margin: 1, textAlign: "center", overflow: go.TextBlock.OverflowEllipsis, editable: true },
						// this Binding is TwoWay due to the user editing the text with the TextEditingTool
						new go.Binding("text").makeTwoWay(),
						new go.Binding("stroke", "color"))
				);

			myDiagram.nodeTemplate.toolTip =
				$("ToolTip",  // show some detailed information
					$(go.Panel, "Vertical", { maxSize: new go.Size(200, NaN) },	 // limit width but not height
						$(go.TextBlock, { font: "bold 10pt sans-serif", textAlign: "center" },
							new go.Binding("text")),
						$(go.TextBlock, { font: "10pt sans-serif", textAlign: "center" },
							new go.Binding("text", "details"))
					)
				);

			// Node selection adornment
			// Include four large triangular buttons so that the user can easily make a copy
			// of the node, move it to be in that direction relative to the original node,
			// and add a link to the new node.

			function makeArrowButton(spot, fig) {
				var maker = (e, shape) => {
					e.handled = true;
					e.diagram.model.commit(m => {
						var selnode = shape.part.adornedPart;
						// create a new node in the direction of the spot
						var p = new go.Point().setRectSpot(selnode.actualBounds, spot);
						p.subtract(selnode.location);
						p.scale(2, 2);
						p.x += Math.sign(p.x) * 60;
						p.y += Math.sign(p.y) * 60;
						p.add(selnode.location);
						p.snapToGridPoint(e.diagram.grid.gridOrigin, e.diagram.grid.gridCellSize);
						// make the new node a copy of the selected node
						var nodedata = m.copyNodeData(selnode.data);
						// add to same group as selected node
						m.setGroupKeyForNodeData(nodedata, m.getGroupKeyForNodeData(selnode.data));
						m.addNodeData(nodedata);	// add to model
						// create a link from the selected node to the new node
						var linkdata = { from: selnode.key, to: m.getKeyForNodeData(nodedata) };
						m.addLinkData(linkdata);	// add to model
						// move the new node to the computed location, select it, and start to edit it
						var newnode = e.diagram.findNodeForData(nodedata);
						newnode.location = p;
						e.diagram.select(newnode);
						setTimeout(() => {
							e.diagram.commandHandler.editTextBlock();
						}, 20);
					});
				};
				return $(go.Shape, {
					figure: fig,
					alignment: spot, alignmentFocus: spot.opposite(),
					width: (spot.equals(go.Spot.Top) || spot.equals(go.Spot.Bottom)) ? 36 : 18,
					height: (spot.equals(go.Spot.Top) || spot.equals(go.Spot.Bottom)) ? 18 : 36,
					fill: "orange", strokeWidth: 0,
					isActionable: true,  // needed because it's in an Adornment
					click: maker, contextClick: maker
				});
			}

			// create a button that brings up the context menu
			function CMButton(options) {
				return $(go.Shape, {
					fill: "orange", stroke: "gray", background: "transparent",
					geometryString: "F1 M0 0 M0 4h4v4h-4z M6 4h4v4h-4z M12 4h4v4h-4z M0 12",
					isActionable: true, cursor: "context-menu",
					click: (e, shape) => {
						e.diagram.commandHandler.showContextMenu(shape.part.adornedPart);
					}
				},
					options || {});
			}

			myDiagram.nodeTemplate.selectionAdornmentTemplate =
				$(go.Adornment, "Spot",
					$(go.Placeholder, { padding: 10 }),
					makeArrowButton(go.Spot.Top, "TriangleUp"),
					makeArrowButton(go.Spot.Left, "TriangleLeft"),
					makeArrowButton(go.Spot.Right, "TriangleRight"),
					makeArrowButton(go.Spot.Bottom, "TriangleDown"),
					CMButton({ alignment: new go.Spot(0.75, 0) })
				);

			// Common context menu button definitions

			// All buttons in context menu work on both click and contextClick,
			// in case the user context-clicks on the button.
			// All buttons modify the node data, not the Node, so the Bindings need not be TwoWay.

			// A button-defining helper function that returns a click event handler.
			// PROPNAME is the name of the data property that should be set to the given VALUE.
			function ClickFunction(propname, value) {
				return (e, obj) => {
					e.handled = true;  // don't let the click bubble up
					e.diagram.model.commit(m => {
						m.set(obj.part.adornedPart.data, propname, value);
					});
				};
			}

			// Create a context menu button for setting a data property with a color value.
			function ColorButton(color, propname) {
				if (!propname) propname = "color";
				return $(go.Shape, {
					width: 16, height: 16, stroke: "lightgray", fill: color,
					margin: 1, background: "transparent",
					mouseEnter: (e, shape) => shape.stroke = "dodgerblue",
					mouseLeave: (e, shape) => shape.stroke = "lightgray",
					click: ClickFunction(propname, color), contextClick: ClickFunction(propname, color)
				});
			}

			function LightFillButtons() {  // used by multiple context menus
				return [
					$("ContextMenuButton",
						$(go.Panel, "Horizontal",
							ColorButton("white", "fill"), ColorButton("beige", "fill"), ColorButton("aliceblue", "fill"), ColorButton("lightyellow", "fill")
						)
					),
					$("ContextMenuButton",
						$(go.Panel, "Horizontal",
							ColorButton("lightgray", "fill"), ColorButton("lightgreen", "fill"), ColorButton("lightblue", "fill"), ColorButton("pink", "fill")
						)
					)
				];
			}

			function DarkColorButtons() {  // used by multiple context menus
				return [
					$("ContextMenuButton",
						$(go.Panel, "Horizontal",
							ColorButton("black"), ColorButton("green"), ColorButton("blue"), ColorButton("red")
						)
					),
					$("ContextMenuButton",
						$(go.Panel, "Horizontal",
							ColorButton("brown"), ColorButton("magenta"), ColorButton("purple"), ColorButton("orange")
						)
					)
				];
			}

			// Create a context menu button for setting a data property with a stroke width value.
			function ThicknessButton(sw, propname) {
				if (!propname) propname = "thickness";
				return $(go.Shape, "LineH", {
					width: 16, height: 16, strokeWidth: sw,
					margin: 1, background: "transparent",
					mouseEnter: (e, shape) => shape.background = "dodgerblue",
					mouseLeave: (e, shape) => shape.background = "transparent",
					click: ClickFunction(propname, sw), contextClick: ClickFunction(propname, sw)
				});
			}

			// Create a context menu button for setting a data property with a stroke dash Array value.
			function DashButton(dash, propname) {
				if (!propname) propname = "dash";
				return $(go.Shape, "LineH", {
					width: 24, height: 16, strokeWidth: 2,
					strokeDashArray: dash,
					margin: 1, background: "transparent",
					mouseEnter: (e, shape) => shape.background = "dodgerblue",
					mouseLeave: (e, shape) => shape.background = "transparent",
					click: ClickFunction(propname, dash), contextClick: ClickFunction(propname, dash)
				});
			}

			function StrokeOptionsButtons() {  // used by multiple context menus
				return [
					$("ContextMenuButton",
						$(go.Panel, "Horizontal",
							ThicknessButton(1), ThicknessButton(2), ThicknessButton(3), ThicknessButton(4)
						)
					),
					$("ContextMenuButton",
						$(go.Panel, "Horizontal",
							DashButton(null), DashButton([2, 4]), DashButton([4, 4])
						)
					)
				];
			}

			// Node context menu

			function FigureButton(fig, propname) {
				if (!propname) propname = "figure";
				return $(go.Shape, {
					width: 32, height: 32, scale: 0.5, fill: "lightgray", figure: fig,
					margin: 1, background: "transparent",
					mouseEnter: (e, shape) => shape.fill = "dodgerblue",
					mouseLeave: (e, shape) => shape.fill = "lightgray",
					click: ClickFunction(propname, fig), contextClick: ClickFunction(propname, fig)
				});
			}

			myDiagram.nodeTemplate.contextMenu =
				$("ContextMenu",
					$("ContextMenuButton",
						$(go.Panel, "Horizontal",
							FigureButton("Rectangle"), FigureButton("RoundedRectangle"), FigureButton("Ellipse"), FigureButton("Diamond")
						)
					),
					$("ContextMenuButton",
						$(go.Panel, "Horizontal",
							FigureButton("Parallelogram2"), FigureButton("ManualOperation"), FigureButton("Procedure"), FigureButton("Cylinder1")
						)
					),
					$("ContextMenuButton",
						$(go.Panel, "Horizontal",
							FigureButton("Terminator"), FigureButton("CreateRequest"), FigureButton("Document"), FigureButton("TriangleDown")
						)
					),
					LightFillButtons(),
					DarkColorButtons(),
					StrokeOptionsButtons()
				);


			// Group template

			myDiagram.groupTemplate =
				$(go.Group, "Spot", {
					layerName: "Background",
					ungroupable: true,
					locationSpot: go.Spot.Center,
					selectionObjectName: "BODY",
					computesBoundsAfterDrag: true,  // allow dragging out of a Group that uses a Placeholder
					handlesDragDropForMembers: true,	// don't need to define handlers on Nodes and Links
					mouseDrop: (e, grp) => {  // add dropped nodes as members of the group
						var ok = grp.addMembers(grp.diagram.selection, true);
						if (!ok) grp.diagram.currentTool.doCancel();
					},
					avoidable: false
				},
					new go.Binding("location", "loc", go.Point.parse).makeTwoWay(go.Point.stringify),
					$(go.Panel, "Auto", { name: "BODY" },
						$(go.Shape, {
							parameter1: 10,
							fill: "white", strokeWidth: 2,
							portId: "", cursor: "pointer",
							fromLinkable: true, toLinkable: true,
							fromLinkableDuplicates: true, toLinkableDuplicates: true,
							fromSpot: go.Spot.AllSides, toSpot: go.Spot.AllSides
						},
							new go.Binding("fill"),
							new go.Binding("stroke", "color"),
							new go.Binding("strokeWidth", "thickness"),
							new go.Binding("strokeDashArray", "dash")),
						$(go.Placeholder, { background: "transparent", margin: 10 })
					),
					$(go.TextBlock, {
						alignment: go.Spot.Top, alignmentFocus: go.Spot.Bottom,
						font: "bold 12pt sans-serif", editable: true
					},
						new go.Binding("text"),
						new go.Binding("stroke", "color"))
				);

			myDiagram.groupTemplate.selectionAdornmentTemplate =
				$(go.Adornment, "Spot",
					$(go.Panel, "Auto",
						$(go.Shape, { fill: null, stroke: "dodgerblue", strokeWidth: 3 }),
						$(go.Placeholder, { margin: 1.5 })
					),
					CMButton({ alignment: go.Spot.TopRight, alignmentFocus: go.Spot.BottomRight })
				);

			myDiagram.groupTemplate.contextMenu =
				$("ContextMenu",
					LightFillButtons(),
					DarkColorButtons(),
					StrokeOptionsButtons()
				);


			// Link template

			myDiagram.linkTemplate =
				$(go.Link, {
					layerName: "Foreground",
					routing: go.Link.AvoidsNodes, corner: 10,
					toShortLength: 4,	 // assume arrowhead at "to" end, need to avoid bad appearance when path is thick
					relinkableFrom: true, relinkableTo: true,
					reshapable: true, resegmentable: true
				},
					new go.Binding("fromSpot", "fromSpot", go.Spot.parse),
					new go.Binding("toSpot", "toSpot", go.Spot.parse),
					new go.Binding("fromShortLength", "dir", dir => dir === 2 ? 4 : 0),
					new go.Binding("toShortLength", "dir", dir => dir >= 1 ? 4 : 0),
					new go.Binding("points").makeTwoWay(),  // TwoWay due to user reshaping with LinkReshapingTool
					$(go.Shape, { strokeWidth: 2 },
						new go.Binding("stroke", "color"),
						new go.Binding("strokeWidth", "thickness"),
						new go.Binding("strokeDashArray", "dash")),
					$(go.Shape, { fromArrow: "Backward", strokeWidth: 0, scale: 4 / 3, visible: false },
						new go.Binding("visible", "dir", dir => dir === 2),
						new go.Binding("fill", "color"),
						new go.Binding("scale", "thickness", t => (2 + t) / 3)),
					$(go.Shape, { toArrow: "Standard", strokeWidth: 0, scale: 4 / 3 },
						new go.Binding("visible", "dir", dir => dir >= 1),
						new go.Binding("fill", "color"),
						new go.Binding("scale", "thickness", t => (2 + t) / 3)),
					$(go.TextBlock, { alignmentFocus: new go.Spot(0, 1, -4, 0), editable: true },
						new go.Binding("text").makeTwoWay(),  // TwoWay due to user editing with TextEditingTool
						new go.Binding("stroke", "color"))
				);

			myDiagram.linkTemplate.selectionAdornmentTemplate =
				$(go.Adornment,	 // use a special selection Adornment that does not obscure the link path itself
					$(go.Shape, { // this uses a pathPattern with a gap in it, in order to avoid drawing on top of the link path Shape
						isPanelMain: true,
						stroke: "transparent", strokeWidth: 6,
						pathPattern: makeAdornmentPathPattern(2)  // == thickness or strokeWidth
					},
						new go.Binding("pathPattern", "thickness", makeAdornmentPathPattern)),
					CMButton({ alignmentFocus: new go.Spot(0, 0, -6, -4) })
				);

			function makeAdornmentPathPattern(w) {
				return $(go.Shape, {
					stroke: "dodgerblue", strokeWidth: 2, strokeCap: "square",
					geometryString: "M0 0 M4 2 H3 M4 " + (w + 4).toString() + " H3"
				});
			}

			// Link context menu
			// All buttons in context menu work on both click and contextClick,
			// in case the user context-clicks on the button.
			// All buttons modify the link data, not the Link, so the Bindings need not be TwoWay.

			function ArrowButton(num) {
				var geo = "M0 0 M16 16 M0 8 L16 8  M12 11 L16 8 L12 5";
				if (num === 0) {
					geo = "M0 0 M16 16 M0 8 L16 8";
				} else if (num === 2) {
					geo = "M0 0 M16 16 M0 8 L16 8  M12 11 L16 8 L12 5  M4 11 L0 8 L4 5";
				}
				return $(go.Shape, {
					geometryString: geo,
					margin: 2, background: "transparent",
					mouseEnter: (e, shape) => shape.background = "dodgerblue",
					mouseLeave: (e, shape) => shape.background = "transparent",
					click: ClickFunction("dir", num), contextClick: ClickFunction("dir", num)
				});
			}

			function AllSidesButton(to) {
				var setter = (e, shape) => {
					e.handled = true;
					e.diagram.model.commit(m => {
						var link = shape.part.adornedPart;
						m.set(link.data, (to ? "toSpot" : "fromSpot"), go.Spot.stringify(go.Spot.AllSides));
						// re-spread the connections of other links connected with the node
						(to ? link.toNode : link.fromNode).invalidateConnectedLinks();
					});
				};
				return $(go.Shape, {
					width: 12, height: 12, fill: "transparent",
					mouseEnter: (e, shape) => shape.background = "dodgerblue",
					mouseLeave: (e, shape) => shape.background = "transparent",
					click: setter, contextClick: setter
				});
			}

			function SpotButton(spot, to) {
				var ang = 0;
				var side = go.Spot.RightSide;
				if (spot.equals(go.Spot.Top)) {
					ang = 270; side = go.Spot.TopSide;
				} else if (spot.equals(go.Spot.Left)) {
					ang = 180; side = go.Spot.LeftSide;
				} else if (spot.equals(go.Spot.Bottom)) {
					ang = 90; side = go.Spot.BottomSide;
				}
				if (!to) ang -= 180;
				var setter = (e, shape) => {
					e.handled = true;
					e.diagram.model.commit(m => {
						var link = shape.part.adornedPart;
						m.set(link.data, (to ? "toSpot" : "fromSpot"), go.Spot.stringify(side));
						// re-spread the connections of other links connected with the node
						(to ? link.toNode : link.fromNode).invalidateConnectedLinks();
					});
				};
				return $(go.Shape, {
					alignment: spot, alignmentFocus: spot.opposite(),
					geometryString: "M0 0 M12 12 M12 6 L1 6 L4 4 M1 6 L4 8",
					angle: ang,
					background: "transparent",
					mouseEnter: (e, shape) => shape.background = "dodgerblue",
					mouseLeave: (e, shape) => shape.background = "transparent",
					click: setter, contextClick: setter
				});
			}

			myDiagram.linkTemplate.contextMenu =
				$("ContextMenu",
					DarkColorButtons(),
					StrokeOptionsButtons(),
					$("ContextMenuButton",
						$(go.Panel, "Horizontal",
							ArrowButton(0), ArrowButton(1), ArrowButton(2)
						)
					),
					$("ContextMenuButton",
						$(go.Panel, "Horizontal",
							$(go.Panel, "Spot",
								AllSidesButton(false),
								SpotButton(go.Spot.Top, false), SpotButton(go.Spot.Left, false), SpotButton(go.Spot.Right, false), SpotButton(go.Spot.Bottom, false)
							),
							$(go.Panel, "Spot", { margin: new go.Margin(0, 0, 0, 2) },
								AllSidesButton(true),
								SpotButton(go.Spot.Top, true), SpotButton(go.Spot.Left, true), SpotButton(go.Spot.Right, true), SpotButton(go.Spot.Bottom, true)
							)
						)
					)
				);

			//  init222();
			//load();
		}

		// Show the diagram's model in JSON format
		function save() {
			document.getElementById("mySavedModel").value = myDiagram.model.toJson();
			myDiagram.isModified = false;
		}
		function load() {
			modelFromJson(document.getElementById("mySavedModel").value);
		}
		function modelFromJson(str) {
			myDiagram.model = go.Model.fromJson(str);
		}
		window.addEventListener('DOMContentLoaded', init);

		function evalText() {
			var Str = document.getElementById("code").innerText + " " + document.getElementById("code222").innerText + " "
			Str = document.getElementById("someJavascript").value;
			console.log(Str);
			alert(Str);
			eval(Str);
		}

		// This Binding conversion function creates a Canvas element for a Picture
		// that has a rendering of a line chart drawn by Chart.js.
		function makeLineChart(datasets, picture) {
			var canvases = document.getElementById("myCanvases");

			canv = document.createElement("canvas");
			canv.width = canv.style.width = "600px";
			canv.height = canv.style.height = "300px";

			// apparently Chart.js expects the Canvas to be in a DIV
			var div = document.createElement("div");
			div.style.position = "absolute";
			div.appendChild(canv);
			// add the DIV/Canvas to the DOM, temporarily
			canvases.appendChild(div);

			var config = {  // Chart.js configuration, including the DATASETS data from the model data
				type: "line",
				data: {
					labels: ["January", "February", "March", "April", "May", "June", "July"],
					datasets: datasets
				},
				options: {
					animation: {
						onProgress: () => picture.redraw(),
						onComplete: () => {
							var canvases = document.getElementById("myCanvases");
							if (canvases) {  // remove the Canvas that was in the DOM for rendering
								canvases.removeChild(div);
							}
							picture.redraw();
						}
					}
				}
			};

			new Chart(canv, config);

			return canv;
		}


		function makeRandomPoints(num, range) {
			if (!num) num = 20;
			if (!range) range = 100;
			var pts = [];
			for (var i = 0; i < num; i++) {
				pts.push(Math.random() * range);
			}
			return pts;
		}

		function addNode() {
			myDiagram.model.commit(m => {
				var firstnode = myDiagram.nodes.first();
				var color = go.Brush.darken(go.Brush.randomColor());
				var data = {
					text: "Node " + (myDiagram.nodes.count + 1),
					color: color,
					datasets: [{
						label: "some data",
						fill: false,
						backgroundColor: color,
						borderColor: color,
						data: makeRandomPoints()
					}]
				};
				m.addNodeData(data);
				if (firstnode) {
					m.addLinkData({ from: firstnode.key, to: m.getKeyForNodeData(data) });
					// new node starts off at same location as the parent node
					var newnode = myDiagram.findNodeForData(data);
					if (newnode) newnode.location = firstnode.location;
				}
			}, "added chart node");
		}

		function modifyNodes() {
			myDiagram.commit(diag => {
				diag.selection.each(node => {
					var oldset = node.data.datasets;
					if (!oldset) return;  // if it's a link, there's no datasets property
					diag.model.set(node.data, "datasets",
						[{
							label: oldset[0].label,
							fill: false,
							backgroundColor: oldset[0].backgroundColor,
							borderColor: oldset[0].borderColor,
							data: makeRandomPoints()
						}]);
				});
			}, "modified selected nodes");
		}

	</script>

	<div id="sample">
		<div id="myDiagramDiv" style="border: solid 1px black; width:100%; height:600px">
		</div>
		<p>
			Double-click in the background to create a new node. Create groups by selecting
			nodes and invoking Ctrl-G; Ctrl-Shift-G to ungroup a selected group. A selected
			node will have four orange triangles that when clicked will automatically copy
			the node and link to it. Use the context menu to change the shape, color,
			thickness, and dashed-ness.
		</p>
		<p>
			Links can be drawn by dragging from the side of each node. A selected link can
			be reconnected by dragging an end handle. Use the context menu to change the
			color, thickness, dashed-ness, and which side the link should connect with.
			Press the F2 key to start editing the label of a selected link.
		</p>
		<div id="buttons">
			<button id="loadModel" onclick="load()">Load</button> <button id="saveModel" onclick="save()">Save</button>
		</div>
		<textarea id="mySavedModel" style="width:100%;height:300px">
	{ "class": "GraphLinksModel",
	  "nodeDataArray": [
	{"key":1, "loc":"0 0", "text":"Alpha", "details":"some information about Alpha and its importance"},
	{"key":2, "loc":"170 0", "text":"Beta", "color":"blue", "thickness":2, "figure":"Procedure"},
	{"key":3, "loc":"0 100", "text":"Gamma", "color":"green", "figure":"Cylinder1"},
	{"key":4, "loc":"80 180", "text":"Delta", "color":"red", "figure":"Terminator", "size":"80 40"},
	{"key":5, "loc":"350 -50", "text":"Zeta", "group":7, "color":"blue", "figure":"CreateRequest"},
	{"key":6, "loc":"350 50", "text":"Eta", "group":7, "figure":"Document", "fill":"lightyellow"},
	{"key":7, "isGroup":true, "text":"Theta", "color":"green", "fill":"lightgreen"},
	{"key":8, "loc":"520 50", "text":"Iota", "fill":"pink"}
	 ],
	  "linkDataArray": [
	{"from":1, "to":2, "dash":[ 6,3 ], "thickness":4},
	{"from":1, "to":3, "dash":[ 2,4 ], "color":"green", "text":"label"},
	{"from":3, "to":4, "color":"red", "text":"a red label", "fromSpot":"RightSide"},
	{"from":2, "to":1},
	{"from":5, "to":6, "text":"in a group"},
	{"from":2, "to":7},
	{"from":6, "to":8, "dir":0},
	{"from":6, "to":8, "dir":1},
	{"from":6, "to":8, "dir":2}
	 ]}
	</textarea>
	</div>
	<button id="saveModel" onclick="evalText()">Eval</button> <textarea id="someJavascript"
		style="width:100%;height:300px">
	const $ = go.GraphObject.make;
		myDiagram.add(
				 $(go.Node, "Auto",
				   $(go.Shape, "Rectangle",	 // the border{ fill: bluefill}),
				   $(go.Panel, "Table",
					 $(go.RowColumnDefinition,{ column: 1, separatorStroke: "black"}),
					 $(go.RowColumnDefinition,{ column: 2, separatorStroke: "black"}),
					 $(go.RowColumnDefinition,{ row: 1, separatorStroke: "black", background: bluefill, coversSeparators: true}),
					 $(go.RowColumnDefinition,{ row: 2, separatorStroke: "black"}),
					 $(go.TextBlock, "Early Start",{ row: 0, column: 0, margin: 5, textAlign: "center"}),
					 $(go.TextBlock, "Length",{ row: 0, column: 1, margin: 5, textAlign: "center"}),
					 $(go.TextBlock, "Early Finish",{ row: 0, column: 2, margin: 5, textAlign: "center"}),

					 $(go.TextBlock, "Activity Name",{
					   row: 1, column: 0, columnSpan: 3, margin: 5,
					   textAlign: "center", font: "bold 14px sans-serif"
					   }),

					 $(go.TextBlock, "Late Start",{ row: 2, column: 0, margin: 5, textAlign: "center"}),
					 $(go.TextBlock, "Slack",{ row: 2, column: 1, margin: 5, textAlign: "center"}),
					 $(go.TextBlock, "Late Finish",{ row: 2, column: 2, margin: 5, textAlign: "center"})
					)  // end Table Panel
				  )));

</textarea
	</div>
<!-- * * * * * * * * * * * * * -->
<!--  End of GoJS sample code  -->
</div>

<script id="code222">

	// This just creates and initializes a Diagram.\
	// The details do not really matter for this demo.
	function init222() {

		//   if (window.goSamples) goSamples();  // init for these samples -- you don't need to call this
		var $ = go.GraphObject.make;  // for conciseness in defining templates
		myDiagram =
			$(go.Diagram, "myDiagramDiv1", {
				"grid.visible": true,
				allowCopy: false,
				"draggingTool.dragsTree": true,
				"commandHandler.deletesTree": true,
				layout: $(go.TreeLayout, { angle: 90, arrangement: go.TreeLayout.ArrangementFixedRoots }),
				"undoManager.isEnabled": true
			});

		// when the document is modified, add a "*" to the title and enable the "Save" button
		myDiagram.addDiagramListener("Modified", function (e) {
			var button = document.getElementById("SaveButton");
			if (button) button.disabled = !myDiagram.isModified;
			var idx = document.title.indexOf("*");
			if (myDiagram.isModified) {
				if (idx < 0) document.title += "*";
			} else {
				if (idx >= 0) document.title = document.title.substr(0, idx);
			}
		});

		var bluegrad = $(go.Brush, "Linear", { 0: "#C4ECFF", 1: "#70D4FF" });
		var greengrad = $(go.Brush, "Linear", { 0: "#B1E2A5", 1: "#7AE060" });

		// each action is represented by a shape and some text
		var actionTemplate =
			$(go.Panel, "Horizontal",
				$(go.Shape, { width: 12, height: 12 },
					new go.Binding("figure"),
					new go.Binding("fill")
				),
				$(go.TextBlock, { font: "10pt Verdana, sans-serif" },
					new go.Binding("text")
				)
			);

		// each regular Node has body consisting of a title followed by a collapsible list of actions,
		// controlled by a PanelExpanderButton, with a TreeExpanderButton underneath the body
		myDiagram.nodeTemplate =  // the default node template
			$(go.Node, "Vertical", { selectionObjectName: "BODY" },
				// the main "BODY" consists of a RoundedRectangle surrounding nested Panels
				$(go.Panel, "Auto", { name: "BODY" },
					$(go.Shape, "Rectangle", { fill: bluegrad, stroke: null }
					),
					$(go.Panel, "Vertical", { margin: 3 },
						// the title
						$(go.TextBlock, {
							stretch: go.GraphObject.Horizontal,
							font: "bold 12pt Verdana, sans-serif"
						},
							new go.Binding("text", "question")
						),
						// the optional list of actions
						$(go.Panel, "Vertical", { stretch: go.GraphObject.Horizontal, visible: false },  // not visible unless there is more than one action
							new go.Binding("visible", "actions", function (acts) {
								return (Array.isArray(acts) && acts.length > 0);
							}),
							// headered by a label and a PanelExpanderButton inside a Table
							$(go.Panel, "Table", { stretch: go.GraphObject.Horizontal },
								$(go.TextBlock, "Choices", {
									alignment: go.Spot.Left,
									font: "10pt Verdana, sans-serif"
								}
								),
								$("PanelExpanderButton", "COLLAPSIBLE",	 // name of the object to make visible or invisible{ column: 1, alignment: go.Spot.Right}
								)
							), // end Table panel
							// with the list data bound in the Vertical Panel
							$(go.Panel, "Vertical", {
								name: "COLLAPSIBLE",  // identify to the PanelExpanderButton
								padding: 2,
								stretch: go.GraphObject.Horizontal,	 // take up whole available width
								background: "white",  // to distinguish from the node's body
								defaultAlignment: go.Spot.Left,	 // thus no need to specify alignment on each element
								itemTemplate: actionTemplate  // the Panel created for each item in Panel.itemArray
							},
								new go.Binding("itemArray", "actions")	// bind Panel.itemArray to nodedata.actions
							)  // end action list Vertical Panel
						)	// end optional Vertical Panel
					)  // end outer Vertical Panel
				),	 // end "BODY"  Auto Panel
				$(go.Panel,	 // this is underneath the "BODY"{ height: 17},	 // always this height, even if the TreeExpanderButton is not visible
					$("TreeExpanderButton")
				)
			);

		// define a second kind of Node:
		myDiagram.nodeTemplateMap.add("Terminal",
			$(go.Node, "Spot",
				$(go.Shape, "Circle", { width: 55, height: 55, fill: greengrad, stroke: null }
				),
				$(go.TextBlock, { font: "10pt Verdana, sans-serif" },
					new go.Binding("text")
				)
			)
		);

		myDiagram.linkTemplate =
			$(go.Link, go.Link.Orthogonal, { deletable: false, corner: 10 },
				$(go.Shape, { strokeWidth: 2 }
				),
				$(go.TextBlock, go.Link.OrientUpright, {
					background: "white",
					visible: false,	 // unless the binding sets it to true for a non-empty string
					segmentIndex: -2,
					segmentOrientation: go.Link.None
				},
					new go.Binding("text", "answer"),
					// hide empty string;
					// if the "answer" property is undefined, visible is false due to above default setting
					new go.Binding("visible", "answer", function (a) { return (a ? true : false); })
				)
			);

		var diagram = myDiagram;

		var nodeDataArray = [
			/*
			{"key":11, "loc":"0 0", "text":"Alpha", "details":"some information about Alpha and its importance"},
			{"key":12, "loc":"170 0", "text":"Beta", "color":"blue", "thickness":2, "figure":"Procedure"},
			{"key":13, "loc":"0 100", "text":"Gamma", "color":"green", "figure":"Cylinder1"},
			{"key":14, "loc":"80 180", "text":"Delta", "color":"red", "figure":"Terminator", "size":"80 40"},
			{"key":15, "loc":"350 -50", "text":"Zeta", "group":7, "color":"blue", "figure":"CreateRequest"},
			{"key":16, "loc":"350 50", "text":"Eta", "group":7, "figure":"Document", "fill":"lightyellow"},
			{"key":17, "isGroup":true, "text":"Theta", "color":"green", "fill":"lightgreen"},
			{"key":18, "loc":"520 50", "text":"Iota", "fill":"pink"},*/

			{

				key: 1, question: "Greeting",
				actions: [
					{ text: "Sales", figure: "ElectricalHazard", fill: "blue" },
					{ text: "Parts and Services", figure: "FireHazard", fill: "red" },
					{ text: "Representative", figure: "IrritationHazard", fill: "yellow" }
				]
			},
			{
				key: 2, question: "Sales",
				actions: [
					{ text: "Compact", figure: "ElectricalHazard", fill: "blue" },
					{ text: "Mid-Size", figure: "FireHazard", fill: "red" },
					{ text: "Large", figure: "IrritationHazard", fill: "yellow" }
				]
			},
			{
				key: 3, question: "Parts and Services",
				actions: [
					{ text: "Maintenance", figure: "ElectricalHazard", fill: "blue" },
					{ text: "Repairs", figure: "FireHazard", fill: "red" },
					{ text: "State Inspection", figure: "IrritationHazard", fill: "yellow" }
				]
			},
			{ key: 4, question: "Representative" },
			{ key: 5, question: "Compact" },
			{ key: 6, question: "Mid-Size" },
			{
				key: 7, question: "Large",
				actions: [
					{ text: "SUV", figure: "ElectricalHazard", fill: "blue" },
					{ text: "Van", figure: "FireHazard", fill: "red" }
				]
			},
			{ key: 8, question: "Maintenance" },
			{ key: 9, question: "Repairs" },
			{ key: 10, question: "State Inspection" },
			{ key: 11, question: "SUV" },
			{ key: 12, question: "Van" },
			{ key: 13, category: "Terminal", text: "Susan" },
			{ key: 14, category: "Terminal", text: "Eric" },
			{ key: 15, category: "Terminal", text: "Steven" },
			{ key: 16, category: "Terminal", text: "Tom" },
			{ key: 17, category: "Terminal", text: "Emily" },
			{ key: 18, category: "Terminal", text: "Tony" },
			{ key: 19, category: "Terminal", text: "Ken" },
			{ key: 20, category: "Terminal", text: "Rachel" }
		];
		var linkDataArray = [
			{ from: 1, to: 2, answer: 1 },
			{ from: 1, to: 3, answer: 2 },
			{ from: 1, to: 4, answer: 3 },
			{ from: 2, to: 5, answer: 1 },
			{ from: 2, to: 6, answer: 2 },
			{ from: 2, to: 7, answer: 3 },
			{ from: 3, to: 8, answer: 1 },
			{ from: 3, to: 9, answer: 2 },
			{ from: 3, to: 10, answer: 3 },
			{ from: 7, to: 11, answer: 1 },
			{ from: 7, to: 12, answer: 2 },
			{ from: 5, to: 13 },
			{ from: 6, to: 14 },
			{ from: 11, to: 15 },
			{ from: 12, to: 16 },
			{ from: 8, to: 17 },
			{ from: 9, to: 18 },
			{ from: 10, to: 19 },
			{ from: 4, to: 20 }
			/*
			{"from":11, "to":12, "dash":[ 6,3 ], "thickness":4},
			{"from":11, "to":13, "dash":[ 2,4 ], "color":"green", "text":"label"},
			{"from":13, "to":14, "color":"red", "text":"a red label", "fromSpot":"RightSide"},
			{"from":12, "to":11},
			{"from":15, "to":16, "text":"in a group"},
			{"from":12, "to":17},
			{"from":16, "to":18, "dir":0},
			{"from":16, "to":18, "dir":1},
			{"from":16, "to":18, "dir":2}*/
		];

		// create the Model with the above data, and assign to the Diagram
		myDiagram.model = $(go.GraphLinksModel, {
			copiesArrays: true,
			copiesArrayObjects: true,
			nodeDataArray: nodeDataArray,
			linkDataArray: linkDataArray
		});

		window.myDiagram = myDiagram;
		window.theA4Game = myDiagram;
		window.linkDataArray = linkDataArray;
		window.nodeDataArray = linkDataArray;

		diagram.groupTemplate =
			$(go.Group, "Auto",
				$(go.Shape, "Rectangle", { fill: "gold" }),
				$(go.Panel, "Vertical", {
					margin: 5,
					defaultAlignment: go.Spot.Left
				},
					$(go.Panel, "Horizontal",
						$("SubGraphExpanderButton", { margin: new go.Margin(0, 3, 5, 0) }),
						$(go.TextBlock, "Group")
					),
					$(go.Placeholder)
				)
			);

	}
	// This common function is called both when showing the PDF in an iframe and when downloading a PDF file.
	// The options include:
	//   "pageSize", either "A4" or "LETTER" (the default)
	//   "layout", either "portrait" (the default) or "landscape"
	//   "margin" for the uniform page margin on each page (default is 36 pt)
	//   "padding" instead of the Diagram.padding when adjusting the Diagram.documentBounds for the area to render
	//   "imgWidth", size of diagram image for one page; defaults to the page width minus margins
	//   "imgHeight", size of diagram image for one page; defaults to the page height minus margins
	//   "imgResolutionFactor" for how large the image should be scaled when rendered for each page;
	//     larger is better but significantly increases memory usage (default is 3)
	//   "parts", "background", "showTemporary", "showGrid", all are passed to Diagram.makeImageData
	function generatePdf(action, diagram, options) {
		if (!(diagram instanceof go.Diagram)) throw new Error("no Diagram provided when calling generatePdf");
		if (!options) options = {};

		var pageSize = options.pageSize || "LETTER";
		pageSize = pageSize.toUpperCase();
		if (pageSize !== "LETTER" && pageSize !== "A4") throw new Error("unknown page size: " + pageSize);
		// LETTER: 612x792 pt == 816x1056 CSS units
		// A4: 595.28x841.89 pt == 793.71x1122.52 CSS units
		var pageWidth = (pageSize === "LETTER" ? 612 : 595.28) * 96 / 72;  // convert from pt to CSS units
		var pageHeight = (pageSize === "LETTER" ? 792 : 841.89) * 96 / 72;

		var layout = options.layout || "portrait";
		layout = layout.toLowerCase();
		if (layout !== "portrait" && layout !== "landscape") throw new Error("unknown layout: " + layout);
		if (layout === "landscape") {
			var temp = pageWidth;
			pageWidth = pageHeight;
			pageHeight = temp;
		}

		var margin = options.margin !== undefined ? options.margin : 36;  // pt: 0.5 inch margin on each side
		var padding = options.padding !== undefined ? options.padding : diagram.padding;  // CSS units

		var imgWidth = options.imgWidth !== undefined ? options.imgWidth : (pageWidth - margin / 72 * 96 * 2);	// CSS units
		var imgHeight = options.imgHeight !== undefined ? options.imgHeight : (pageHeight - margin / 72 * 96 * 2);	// CSS units
		var imgResolutionFactor = options.imgResolutionFactor !== undefined ? options.imgResolutionFactor : 3;

		var pageOptions = {
			size: pageSize,
			margin: margin,	 // pt
			layout: layout
		};

		require(["blob-stream", "pdfkit"], function (blobStream, PDFDocument) {
			var doc = new PDFDocument(pageOptions);
			var stream = doc.pipe(blobStream());
			var bnds = diagram.documentBounds;

			// add some descriptive text
			//doc.text(diagram.nodes.count + " nodes, " + diagram.links.count + " links  Diagram size: " + bnds.width.toFixed(2) + " x " + bnds.height.toFixed(2));

			var db = diagram.documentBounds.copy().subtractMargin(diagram.padding).addMargin(padding);
			var p = db.position;
			// iterate over page areas of document bounds
			for (var j = 0; j < db.height; j += imgHeight) {
				for (var i = 0; i < db.width; i += imgWidth) {

					// if any page has no Parts partially or fully in it, skip rendering that page
					var r = new go.Rect(p.x + i, p.y + j, imgWidth, imgHeight);
					if (diagram.findPartsIn(r, true, false).count === 0) continue;

					if (i > 0 || j > 0) doc.addPage(pageOptions);

					var makeOptions = {};
					if (options.parts !== undefined) makeOptions.parts = options.parts;
					if (options.background !== undefined) makeOptions.background = options.background;
					if (options.showTemporary !== undefined) makeOptions.showTemporary = options.showTemporary;
					if (options.showGrid !== undefined) makeOptions.showGrid = options.showGrid;
					makeOptions.scale = imgResolutionFactor;
					makeOptions.position = new go.Point(p.x + i, p.y + j);
					makeOptions.size = new go.Size(imgWidth * imgResolutionFactor, imgHeight * imgResolutionFactor);
					makeOptions.maxSize = new go.Size(Infinity, Infinity);

					var imgdata = diagram.makeImageData(makeOptions);
					doc.image(imgdata, { scale: 1 / (imgResolutionFactor * 96 / 72) });
				}
			}

			doc.end();
			stream.on('finish', function () { action(stream.toBlob('application/pdf')); });
		});
	}


	// Two different uses of generatePdf: one shows the PDF document in the page,
	// the other downloads it as a file and the user specifies where to save it.

	var pdfOptions =  // shared by both ways of generating PDF
	{
		showTemporary: true,	 // default is false
		// layout: "landscape",  // instead of "portrait"
		// pageSize: "A4"        // instead of "LETTER"
	};

	function showPdf() {
		generatePdf(function (blob) {
			var datauri = window.URL.createObjectURL(blob);
			var frame = document.getElementById("myFrame");
			if (frame) {
				frame.style.display = "block";
				frame.src = datauri;	 // doesn't work in IE 11, but works everywhere else
				setTimeout(function () { window.URL.revokeObjectURL(datauri); }, 1);
			}
		}, myDiagram, pdfOptions);
	}

	function downloadPdf() {
		generatePdf(function (blob) {
			var datauri = window.URL.createObjectURL(blob);
			var a = document.createElement("a");
			a.style = "display: none";
			a.href = datauri;
			a.download = "myDiagram.pdf";

			if (window.navigator.msSaveBlob !== undefined) {	// IE 11 & Edge
				window.navigator.msSaveBlob(blob, a.download);
				window.URL.revokeObjectURL(datauri);
				return;
			}

			document.body.appendChild(a);
			requestAnimationFrame(function () {
				a.click();
				window.URL.revokeObjectURL(datauri);
				document.body.removeChild(a);
			});
		}, myDiagram, pdfOptions);
	}



	function init333() {

		// Since 2.2 you can also author concise templates with method chaining instead of GraphObject.make
		// For details, see https://gojs.net/latest/intro/buildingObjects.html
		const $ = go.GraphObject.make;	// for more concise visual tree definitions

		// colors used, named for easier identification
		var blue = "#0288D1";
		var pink = "#B71C1C";
		var pinkfill = "#F8BBD0";
		var bluefill = "#B3E5FC";

		myDiagram =
			$(go.Diagram, "myDiagramDiv2", {
				initialAutoScale: go.Diagram.Uniform,
				layout: $(go.LayeredDigraphLayout)
			});

		// The node template shows the activity name in the middle as well as
		// various statistics about the activity, all surrounded by a border.
		// The border's color is determined by the node data's ".critical" property.
		// Some information is not available as properties on the node data,
		// but must be computed -- we use converter functions for that.
		myDiagram.nodeTemplate =
			$(go.Node, "Auto",
				$(go.Shape, "Rectangle",	// the border{ fill: "white", strokeWidth: 2},
					new go.Binding("fill", "critical", b => b ? pinkfill : bluefill),
					new go.Binding("stroke", "critical", b => b ? pink : blue)),
				$(go.Panel, "Table", { padding: 0.5 },
					$(go.RowColumnDefinition, { column: 1, separatorStroke: "black" }),
					$(go.RowColumnDefinition, { column: 2, separatorStroke: "black" }),
					$(go.RowColumnDefinition, { row: 1, separatorStroke: "black", background: "white", coversSeparators: true }),
					$(go.RowColumnDefinition, { row: 2, separatorStroke: "black" }),
					$(go.TextBlock,	// earlyStart
						new go.Binding("text", "earlyStart"), { row: 0, column: 0, margin: 5, textAlign: "center" }),
					$(go.TextBlock,
						new go.Binding("text", "length"), { row: 0, column: 1, margin: 5, textAlign: "center" }),
					$(go.TextBlock,	 // earlyFinish
						new go.Binding("text", "",
							d => (d.earlyStart + d.length).toFixed(2)), { row: 0, column: 2, margin: 5, textAlign: "center" }),

					$(go.TextBlock,
						new go.Binding("text", "text"), {
						row: 1, column: 0, columnSpan: 3, margin: 5,
						textAlign: "center", font: "bold 14px sans-serif"
					}),

					$(go.TextBlock,	 // lateStart
						new go.Binding("text", "",
							d => (d.lateFinish - d.length).toFixed(2)), { row: 2, column: 0, margin: 5, textAlign: "center" }),
					$(go.TextBlock,	 // slack
						new go.Binding("text", "",
							d => (d.lateFinish - (d.earlyStart + d.length)).toFixed(2)), { row: 2, column: 1, margin: 5, textAlign: "center" }),
					$(go.TextBlock,	// lateFinish
						new go.Binding("text", "lateFinish"), { row: 2, column: 2, margin: 5, textAlign: "center" })
				)  // end Table Panel
			);	 // end Node

		// The link data object does not have direct access to both nodes
		// (although it does have references to their keys: .from and .to).
		// This conversion function gets the GraphObject that was data-bound as the second argument.
		// From that we can get the containing Link, and then the Link.fromNode or .toNode,
		// and then its node data, which has the ".critical" property we need.
		//
		// But note that if we were to dynamically change the ".critical" property on a node data,
		// calling myDiagram.model.updateTargetBindings(nodedata) would only update the color
		// of the nodes.  It would be insufficient to change the appearance of any Links.
		function linkColorConverter(linkdata, elt) {
			var link = elt.part;
			if (!link) return blue;
			var f = link.fromNode;
			if (!f || !f.data || !f.data.critical) return blue;
			var t = link.toNode;
			if (!t || !t.data || !t.data.critical) return blue;
			return pink;  // when both Link.fromNode.data.critical and Link.toNode.data.critical
		}

		// The color of a link (including its arrowhead) is red only when both
		// connected nodes have data that is ".critical"; otherwise it is blue.
		// This is computed by the binding converter function.
		myDiagram.linkTemplate =
			$(go.Link, { toShortLength: 6, toEndSegmentLength: 20 },
				$(go.Shape, { strokeWidth: 4 },
					new go.Binding("stroke", "", linkColorConverter)),
				$(go.Shape,  // arrowhead{ toArrow: "Triangle", stroke: null, scale: 1.5},
					new go.Binding("fill", "", linkColorConverter))
			);

		// here's the data defining the graph
		var nodeDataArray = [
			{ key: 1, text: "Start", length: 0, earlyStart: 0, lateFinish: 0, critical: true },
			{ key: 2, text: "a", length: 4, earlyStart: 0, lateFinish: 4, critical: true },
			{ key: 3, text: "b", length: 5.33, earlyStart: 0, lateFinish: 9.17, critical: false },
			{ key: 4, text: "c", length: 5.17, earlyStart: 4, lateFinish: 9.17, critical: true },
			{ key: 5, text: "d", length: 6.33, earlyStart: 4, lateFinish: 15.01, critical: false },
			{ key: 6, text: "e", length: 5.17, earlyStart: 9.17, lateFinish: 14.34, critical: true },
			{ key: 7, text: "f", length: 4.5, earlyStart: 10.33, lateFinish: 19.51, critical: false },
			{ key: 8, text: "g", length: 5.17, earlyStart: 14.34, lateFinish: 19.51, critical: true },
			{ key: 9, text: "Finish", length: 0, earlyStart: 19.51, lateFinish: 19.51, critical: true }
		];
		var linkDataArray = [
			{ from: 1, to: 2 },
			{ from: 1, to: 3 },
			{ from: 2, to: 4 },
			{ from: 2, to: 5 },
			{ from: 3, to: 6 },
			{ from: 4, to: 6 },
			{ from: 5, to: 7 },
			{ from: 6, to: 8 },
			{ from: 7, to: 9 },
			{ from: 8, to: 9 }
		];
		myDiagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
	}
	window.addEventListener('DOMContentLoaded', init);
</script>

<button onclick="init111c()">Init 111c</button>
<button onclick="init222()">Init 222</button> <button onclick="init333()">init333</button>
<button onclick="init()">init</button>
</div>

<script src="eval_socket.js?1"></script>

<div id="sample22">
	<div>
		<button onclick="showPdf()">Show PDF</button> <button onclick="downloadPdf()">Download 
		PDF</button>
	</div>
	<iframe id="myFrame" style="display:none; width:1000px; height:1000px">
	</iframe>
</div>
<div id="myDiagramDiv1" style="border: solid 1px black; width:100%; height:400px"></div>
<div id="myDiagramDiv2" style="border: solid 1px black; width:100%; height:600px"></div>
</body>
</html>