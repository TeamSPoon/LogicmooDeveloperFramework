
:- op(1001,xfy, ('...' )).
:- op(1200,xfx, ('--->')).
:- include(xgproc).
%:- push_def(t_l:disable_px).

:-asserta(t_l:disable_px).

:- ignore(( \+(t_l:disable_px),trace,throw((\+(t_l:disable_px))))).
%:-asserta(tlxgproc:do_xg_process_te).

/* Sentences */

:- export(sentence80/5).
:- thread_local(tlclone:np_in_case/1).

xg_w2_len(0,[])---> !, [].
xg_w2_len(1,[W])---> [W], !.
xg_w2_len(1,[])---> !, []. %% missing puncts
xg_w2_len(N,[W|L])---> [W], {N>1, M is N -1},!,xg_w2_len(M,L).


span_s(S) ---> span_as_xg('SBAR',s80,S).
span_s(S) ---> span_as_xg('S',s80,S).
span_vp(S) ---> span_as_xg('VP',imperative80,S).

span_as_xg(Type,P,S) --->  {\+ lctmp:in_sent804(Type+P)}, locally(lctmp:in_sent804(Type+P),span_call_xg(Type,P,S)).

span_call_xg(Type,P,S) ---> span_as_1(Type,Words),{call(P,S,Words,[],[],[])}.

span_as_1(Type,[w(S,L)|Words], [w(S,L)|A], B, Type_X, Type_X) :-
  member(loc(N),L),
  select(link(_, Type, r(Type, seg(N, M))),L,L2),
  \+ member(link(_, Type, r(Type, seg(N, _))),L2),
   Len is M-N,
   (length(Words,Len),append(Words,B,A)),!.



sentence80(S) ---> {b_setval('$prev_w2s', []),b_setval('$prev_spans', [])},!, sentence80e(S).
sentence80e(S) ---> sentence800(S).
%sentence80e(S) ---> sentence800(S1)*->sentence801s(sentence80,S1,S).

sentence800(S) ---> sentence801(S)*->{true};(span_s(S)*->{true};q_sentence800(S)).

q_sentence800(S) ---> startQuotesEnding(E),!,sentence801(S),E,!.

\+ (XG) ---> (XG -> {fail} ; {true}).

sentence801s(_,S1, S1, W, W, C, C) :- W==[], !.
sentence801s(_,S1, \+ (S1)) ---> theText80(is),theText80(false).
sentence801s(_,S1, (S1)) ---> theText80(is),theText80(true).
sentence801s(P,S1,Out) ---> theText80(Means),{join_over_s(S1,Means,S2,Out)},!,call(P,S2).
sentence801s(P,S1,(S1,S2)) --->  !,call(P,S2).


join_over_s(S1,implies,S2,(S1=>S2)).
join_over_s(S1,means,S2,Out):- !, join_over_s(S1,implies,S2,Out).
join_over_s(S1,if,S2,Out):- !, join_over_s(S2,implies,S1,Out).
join_over_s(S1,whenever,S2,Out):- !, join_over_s(S2,implies,S1,Out).
join_over_s(S1,then,S2,Out):- !, join_over_s(S1,implies,S2,Out).

:- dynamic(if_giveup_dcg/0).
sentence801(_) ---> {if_giveup_dcg,!,fail}.
sentence801(S) ---> xg_from_right(the_w2_list(List),theText80(Last)),
  {arg(_,v('?','!','.'),Last)},!,{sentence_typed(Last,S,List)}.
sentence801(S) ---> sentence802(S).

sentence802(S) ---> sentence803(S) *-> {true} ; sentence804(S).

%sentence802(np(Subj)) ---> theText80(there),thePos80(root(be)),subj(Subj,_Agmt,_Type).
%sentence802(np(Subj)) ---> theText80(there),thePos80(root(exist)),subj(Subj,_Agmt,_Type).
sentence803(S) ---> declarative(S).
sentence803(S) ---> question80(S).
sentence803(S) ---> imperative80(S).

sentence804(decl(S)) ---> subj_decl(S).
sentence804(decl(S)) ---> pp_decl(S).

subj_decl( ( s( Subj, verb(main+iv,exist,active,pres+fin,[],[]), [],[]))) ---> subj(Subj,_Agmt,_Type).

pp_decl( ( s( np(_,np_head(_,generic,[adj(info(self,PP))],current_thing),[]),
                         verb(main+iv,exist,active,pres+fin,[],[]),
                         [],
                       [ PP ]))) --->
   xg_prep_phrase(_PPAlowed,PP,_Case,_Set,_Mask).


sentence_typed('?',S,List):- question80(S,List,[],[],[]).
sentence_typed(Punct,Out,List):- s80(S,_,List,[],[],[]),punct_to_sent_type(Punct,S,Out).
sentence_typed(_,S,List):- imperative80(S,List,[],[],[]).
sentence_typed(_,S,List):- sentence804(S,List,[],[],[]).

punct_to_sent_type((?),S,q(S)).
punct_to_sent_type((.),S,decl(S)).
punct_to_sent_type((!),S,decl(S)).
punct_to_sent_type(missing,S,decl(S)).


question80(S)--->wh_question(S).
question80(S)--->yn_question(S).



/* Declarative sentence */

declarative(decl(S)) ---> s80(S). % ,sentence801s(s80,S1,S).

/* Wh-questions */

wh_question(whq(Type_X,S)) --->
   variable_q(Type_X,_,QCase,NPCase),
   question80(QCase,NPCase,S).

variable_q(Type_X,Agmt,QCase,NPCase) ...
      np_11(NP,Agmt,NPCase,_,_,Set,Mask) --->
   whq(Type_X,Agmt,NP,QCase),
   {is_trace82(Set,Mask)}.

variable_q(Type_X,Agmt,compL,CCase) ...
 xg_prep_phrase(_PPAlowed,prep_phrase(_PPType,Prep,NP),compL,Set,Mask) --->
   prep(Prep),
   whq(Type_X,Agmt,NP,_),
   {is_trace82(Set,Mask), is_compl_case(CCase)}.
variable_q(Type_X,Agmt,compL,VCase) ...
      adv_phrase(post,prep_phrase(_PPType,Prep,
                  np(Agmt,
                   np_head(X,
                    wh_det(_Kind,Type_X),[],Noun),[])),
                 Set,Mask) --->
   context_pron(Prep,Noun),
   {is_trace82(Set,Mask), is_verb_case(VCase),Type_X=(_-X)}.
variable_q(Type_X,_,compL,VCase) ...
      pred(adj,value80(Adj,wh(Type_X)),Mask) --->
   theText80(how),  % how big
   adj(quantA,Adj),
   {is_empty_bits(Mask), is_verb_case(VCase)}.

whq(Type_X,Agmt,NP,unDef) --->
   wh_det(_Kind,Type_X,Agmt),
   {is_s_all(SAll)},
   np_11(NP,Agmt,_,_,subjA,SAll,_).
whq(Type_X,3+No,np(3+No,wh(Type_X),[]),Case) ---> wh_pron(Case).

wh_det(_Kind,Type_X,3+Agmt) ---> whose(Type_X,Agmt).
wh_det(Kind,Type_X,3+Agmt) ---> wh_art_6(Kind,Type_X,Agmt).

whose(Type_X,Agmt), np_head0(wh(Type_X),Agmt,proper), gen_marker ---> theText80(whose).

question80(QCase,NPCase,S) --->
   {subj_question(QCase), is_to_role_case(subjA,_,NPCase)},
   s80(S).
question80(QCase,NPCase,S) --->
   fronted_verb(QCase,NPCase),
   s80(S).

wh_art_6(Kind,Type_X,Agmt), det(DX,Agmt,defA) ---> wh_art(Kind,Type_X,Agmt,DX).

subj_question(subjA).
subj_question(unDef).

/* Yes-no questions */

yn_question(q(S)) --->
   fronted_verb(nil,_),
   s80(S).

:- thread_local(unloop_l:looped_1/1).

%unloop(X):- once(unloop1(b(X));unloop1(c(X))).
unloop(X):- unloop(X, 1).
unloop(X, N):- between(1,N,NN),once(unloop1(a(X,NN))),!.
unloop1(X):- \+ unloop_l:looped_1(X), !, assert(unloop_l:looped_1(X),R), undo(erase(R)),!.
test_unloop:- unloop(test_unloop), writeln(doing(test_unloop)), test_unloop.
test_unloop2:- unloop(test_unloop,2), writeln(doing(test_unloop2)), test_unloop2.
test_unloop3:- unloop(test_unloop,3), writeln(doing(test_unloop3)), test_unloop3.


fronted_verb(QCase,NPCase) ...
      verb_form88(ExtraMods,Root,Tense,Agmt,Role), 
         neg_modal_opt(Tense,ExtraMods,Out,Neg) --->
      verb_form88(ExtraMods,Root,Tense,Agmt,_), {verb_type_lex(Root,aux+_), is_to_role_case(QCase,Role,NPCase)},
         neg_modal_opt(Tense,ExtraMods,Out,Neg).

% Can Iran border iraq ?
fronted_verb(_QCase,_NPCase) ...
      neg_modal_opt(Tense,ExtraMods,Out,Neg) ---> {if_search_expanded(4)},
   neg_modal_opt(Tense,ExtraMods,Out,Neg).

/* Imperative sentences */

imperative80(imp(You,V,S)) --->
   imperative_verb(You,V),
   s80(S).

imperative_verb(You,Root),
   theText80(You),
   verb_form88([Inf,SgOrPl|ExtraMods],Root,imp+fin,Pers+SgOrPl,Main) --->
   verb_form88(ExtraMods,Root,Inf,Pers+SgOrPl,Main),
   {pers_pron_lex(You,_,Pers,SgOrPl,_)}.

imperative_verb(You,Root),
   theText80(You),
   verb_form88([X,Y,Z|ExtraMods],Root,imp+fin,X,main) --->
   verb_form88(ExtraMods,Root,X,Y,Z),
   {ignore(You=it)}.



/* Basic sentence (actually, declarative sentence) */




logical_s_word(Var):- var(Var),!,freeze(Var,logical_s_word(Var)).
logical_s_word(Word):- logical_s_word(_,_,Word).

logical_s_word(r,c,durring).
logical_s_word(r,c,after).
logical_s_word(r,c,before).
logical_s_word(r,c,because).
logical_s_word(r,c,when).
logical_s_word(r,c,whenever).
logical_s_word(r,c,unless).

logical_s_word(r,c,if).
logical_s_word(_,_,for).
logical_s_word(c,c,also).
logical_s_word(c,c,eigther).
logical_s_word(c,r,then).
logical_s_word(c,r,else).
logical_s_word(c,r,implies).
logical_s_word(c,r,implied).
logical_s_word(c,r,otherwise).
logical_s_word(c,r,however).
logical_s_word(c,r,therefore).
logical_s_word(X,X,W):- 
  %if_search_expanded(5), 
  logical_o_word(W).
%logical_s_word(X,X,W):-is_sent_adverb(W).
logical_s_word2(r,c,[else,if]).

     logical_o_word(and).
     logical_o_word(or).
     logical_o_word(not):- if_search_expanded(7).
     logical_o_word(except).
     
%logical_s_word(already).
%logical_s_word(but).
%logical_s_word(for).
%logical_s_word(anyways).
%logical_s_word(wanted).


% adp

if_cond(If,S,Mask) ---> logical_word(If),!,s_vp_801(S,Mask).
if_cond(true,S,Mask) ---> s_vp_801(S,Mask).


s80(P) --->  s80(P,_).

s80(s(NP,verb(main+iv,E,[],active,_+fin,[],([])),[],[]),Mask) ---> 
   theText80(there),theText80_W2(_,L),{member(root(E),L),member(upos(verb),L)},verb_arg(np,NP,Mask).

s80(P,Mask) ---> % {retractall(t_l:was_sentence_level(_))},
 s_vp_800(P,Mask).

s_vp_800(SO,Mask) ---> if_cond(IF,S,Mask), s_vp_800s(IF,S,SO,Mask).

s_vp_800s(true,S,SO,Mask) ---> !, from_true(S,SO,Mask).
s_vp_800s(IF,S,SO,Mask) ---> from_if(IF,S,SO,Mask).

s80lf(S1,SLF):- sent_to_prelogic(S1,SLF),!.
s80lf(S1,S1).

from_if(IF,S,SO,_Mask) --->  logical_word(Then),!,
  sentence801(S1),{
    s80lf(S1,SLF),  
    S=s(Subj,Verb,Args,Mods),
    append_cond(Args,IF-Then,SLF,ArgsO),
    SO=s(Subj,Verb,ArgsO,Mods)}.

logical_word(LW) ---> maybeComma,theText80(LW),!, { logical_s_word(LW)}.
logical_word(true) ---> theText80(',').
%from_true(S,SO,_)---> theText80(LW),{logical_s_word(LW)},!, from_if(LW,S,SO,_).
%from_true(S,S,_Mask)---> xg_peek( \+ logical_word(_LW)),!.
from_true(S,SO,Mask)---> from_if(true,S,SO,Mask).
from_true(S,S,_Mask)---> [].

append_cond(Args,true,S,ArgsO):- append(Prev,[(IF)],Args),logical_s_word(IF),!,append(Prev,[cond(IF,S)],ArgsO).
append_cond(Args,true,S,ArgsO):- append(Prev,[cond(IF)],Args),logical_s_word(IF), !,append(Prev,[cond(IF,S)],ArgsO).
append_cond(Args,true,S,ArgsO):- 
   S = s(Subj,Verb,SArgs,Mods), 
  append(Prev,[(IF)],SArgs),logical_s_word(IF),!,
  SS = s(Subj,Verb,Prev,Mods), 
  append(Args,[cond(IF,SS)],ArgsO).
append_cond(Args,IF,S,ArgsO):- append(Args,[cond(IF,S)],ArgsO).


s_vp_801(s(Subj,Verb,Args,Mods),Mask) --->
  {is_subj_case(Case)},
   locally(tlclone:np_in_case(Case),subj(Subj,Agmt,Type)),
   just_vp(Subj,Agmt,Type,Verb,Args,Mods,Mask).

s_vp_801(s(NP,Verb,[],[ arg(arg_pred,adj(true))]),_) --->  ace_var(AceVar), !,
   {Verb = verb(aux+aux(be,[]), aux(be,[]),active,pres+fin,[],[ aux(be,[pres+fin]), root]),
    NP= np(3+sg,np_head(_Var,generic,[adj(ace_var(self,AceVar)),adj(ti(statement,self))],statement),[])}.



no_more_words ---> \+ [_].

% did
just_vp(_Subj,Agmt,_Type,Verb,[ARG],_Mods,_Mask) ---> 
  theText80(W),
  {verb_aux_form_db(W,do,Pastfin,Agmt)},
  {if_search_expanded(5)},
  {Verb = verb(main+tv,performed,[],active,Pastfin,[],[]),
    ARG = arg(dirO,np(Agmt,np_head(_Var2,generic,[],action),[]))},
    no_more_words.

just_vp(Subj,Agmt,Type,Verb,Args,Mods,Mask) --->
  just_vp_1(Subj,Agmt,Type0,Verb0,Args0,Mods0,Mask0),
  more_s_vp1(Subj,Agmt,Type0,Verb0,Args0,Mods0,Mask0,Type,Verb,Args,Mods,Mask).
/*
more_s_vp1(Subj,Agmt,Type0,Verb0,Args0,Mods0,Mask0,
                     Type,Verb,Args,Mods,Mask) ---> 
   just_vp_1(Subj,Agmt,Type1,Verb1,Args1,Mods1,Mask1).
*/
more_s_vp1(_Subj,_Agmt,Type,Verb,Args,Mods,Mask,Type,Verb,Args,Mods,Mask) ---> noText.
just_vp_1(_Subj,Agmt,Type,Verb,Args,Mods,Mask) --->
   verb_with_rest(Verb,Agmt,Type,Voice),
   {is_empty_bits(Nil), is_s_all(SAll)},
   verb_args(Type,Voice,Args,Nil,Mask0),
   {minus_mask(SAll,Mask0,Set), plus_mask(SAll,Mask0,Mask1)},
   verb_mods(post,Mods,Set,Mask1,Mask),
   no_new_obj.

no_new_obj ---> noText,!.
no_new_obj ---> xg_peek(\+ subj(_,_,_)).


subj(Subj,Agmt,Type) ---> subj0(Subj,Agmt,Type).

subj0(there,_Agmt,_+aux(be,_)) ---> theText80(there).
subj0(Subj,Agmt,_) --->
   {is_s_all(SAll), is_subj_case(Case)},
   np_11(Subj,Agmt,Case,_,subjA,SAll,_).



np_11(np(3+sg,np_head(_Var,generic,[adj(ace_var(self,AceVar)),adj(ti(thing,self))],thing),[]),
    _Agmt,_Case,_IndefA,_Role,_Set,_Mask)
  --->   ace_var(AceVar),!,{O=AceVar,nop(freeze(O, \+ ground(O)))}.

np_11(np(Agmt,nameOf(_Var,span_vp(SO),[]),_Mods),Agmt,_Case,_IndefA,_Role,_Set,_Mask) 
  ---> {if_search_expanded(4)}, span_vp(S),{s80lf(S,SO)}.

np_11(np(Agmt,nameOf(_Var,span_s(SO),[]),_Mods),Agmt,_Case,_IndefA,_Role,_Set,_Mask) 
  ---> {if_search_expanded(3)}, span_s(S),{s80lf(S,SO)}.


   /* Noun Phrase */
% to buy a car
% @TODO DMILES

np_11(np(Agmt,nameOf(_Var,span_s(SO),[]),_Mods),Agmt,_Case,_IndefA,_Role,_Set,_Mask) 
  ---> theText80(to),!,
   imperative80(S),!,{s80lf(S,SO)}.

np_11(AgmtKernelModsO,Agmt,Case,Def,Role,Set,Mask) --->
  locally(tlclone:np_in_case(Case),
    np0(AgmtKernelMods,Agmt,Case,Def,Role,Set,Mask)),
    extend_np(_,AgmtKernelMods,AgmtKernelModsO).

np0(AgmtKernelModsO,Agmt,Case,Def,Role,Set,Mask) 
 ---> np1(AgmtKernelModsO,Agmt,Case,Def,Role,Set,Mask).

np1(np(Agmt,Pronoun,[]),Agmt,NPCase,defA,_,Set,Nil) --->
   {is_pp(Set)},
   pers_pron(Pronoun,Agmt,Case),
   {is_empty_bits(Nil), is_to_role_case(Case,decl,NPCase)}.


np1(_AgmtKernelModsO,_Agmt,_Case,_Def,_Role,_Set,_Mask) ---> theText80(W), {logical_o_word(W),!,fail}.
np1(np(Agmt,Kernel,Mods),Agmt,_Case,Def,Role,Set,Mask) --->
   {is_pp(Set)},
   np_head(_Var,Kernel,Agmt,Def+Type,PostMods,Mods),
   {is_np_all(NPAll)},
   np_compls(Type,Agmt,Role,PostMods,NPAll,Mask).

% many of, one of
np1(part(Det,NP),3+Number,_,indefA,Role,Set,Mask) --->
   {is_pp(Set)},
   determiner(Det,Number,indefA), {Det\=generic},
   theText80(of),
   {is_s_all(SAll), is_prep_case(Case)},
   np_expand(NP,3+pl,Case,defA,Role,SAll,Mask).

np_expand(NP,A3+Apl,Case,defA,Role,SAll,Mask) --->
  np_11(NP,A3+Apl,Case,defA,Role,SAll,Mask).
np_expand(NP,_,_Case,defA,Role,SAll,Mask) ---> {if_search_expanded(3)},
  np_11(NP,_,_,defA,Role,SAll,Mask).

np_head(_Var,KernelMods,Agmt,Type,PostMods,Mods) --->
   np_head0(Kernel0,Agmt0,Type0),
   optional_possessive(Kernel0,Agmt0,Type0,Mods0,Mods0,
              Kernel,Agmt,Type,PostMods,Mods),
      maybe_ace_variable(Kernel,KernelMods).

np_compls(proper,_,_,[],_,Nil) ---> {is_empty_bits(Nil)}.
np_compls(common,Agmt,Case,Mods,Set0,Mask) --->
   {is_np_all(NPAll)},
   np_mods(Agmt,Case,Rel,Mods,Set0,Set,NPAll,Mask0),
   optional_relative(Agmt,Rel,Set,Mask0,Mask).

/* Nuclear noun phrase */

np_head0(_,_,_)---> has_trait(pos('.')),!,{fail}.
np_head0(nameOf(_Var,items(AndOr,List),[]),Agmt,Def)---> {if_search_expanded(2)}, nl_list_of_items(AndOr,np_head1(Agmt,Def),List).
np_head0(H,Agmt,Def)---> np_head1(H,Agmt,Def).

np_head1(H,Agmt,Def)--->np_head2(H,Agmt,Def).

np_head2(Pronoun,Agmt,defA+proper), gen_marker --->
   poss_pron(Pronoun,Agmt).
np_head2(np_head(_Var,Det,[],Noun),3+sg,indefA+common) --->
   quantifier_pron(Det,Noun).
np_head2(nameOf(_Var,O,[]),Agmt,Def) ---> np_objbody(O,Agmt,Def).
np_head2(np_head(_Var,Det,AdjsO,Head),3+Number,Def+common) --->
   determiner(Det,Number,Def),
   post_determiner_pre_noun(Adjs),
   noun(Head,Adjs,AdjsO,Number).


maybe_ace_variable(AdjIn,AdjsOut)---> ace_var(AceVar),!,{append_np_mods(AdjIn,(adj(ace_var(self,AceVar))),AdjsOut)}.
maybe_ace_variable(Adjs,Adjs)---> [].

extend_np(Type_X,I,O) ---> np_amend1(Type_X,V), {append_np_mods(I,V,M)},!, extend_np(Type_X,M,O).
extend_np(_,IO,IO)---> [].

np_amend1(Type_X,adj(ace_var(self,AceVar))) ---> {fail},{(\+ \+ Type_X=ace_var),dif(Type_X,ace_var)}, ace_var(AceVar),!.
np_amend1(Type_X,adj(s_vp(self,_Subj,Verb,Args,Mods))) ---> {fail},
 {( \+ \+ Type_X=s_vp),dif(Type_X,s_vp)}, theText80(that),
   verb_with_rest(Verb,_Agmt,Type,Voice),
   {is_empty_bits(Nil), is_s_all(SAll)},
   verb_args(Type,Voice,Args,Nil,Mask0),
   {minus_mask(SAll,Mask0,Set), plus_mask(SAll,Mask0,Mask1)},
   verb_mods(post,Mods,Set,Mask1,_Mask).


append_np_mods(List,W,List):- is_list(List),member(E,List),W=@=E,!.
append_np_mods(List,W,[W|List]):- is_list(List),!.
append_np_mods(Comp,W,Comp):- sub_term(Head,Comp),compound(Head),(functor(Head,F,_),member(F,[np_head,nameOf])),
  N = 3, arg(N,Head,List),is_list(List),!,append_np_mods(List,W,Arg),nb_setarg(N,Head,Arg).
append_np_mods(Comp,_,Comp):-!.

ace_var(_,_).

/* Possessive construction */

optional_possessive(Kernel0,Agmt0,_,[],Mods0,
           Kernel,Agmt,Type,PostMods,Mods) --->
   gen_case,
   np_head0(Kernel1,Agmt1,Type1),
   optional_possessive(Kernel1,Agmt1,Type1,PostMods1,
              [prep_phrase(_PPType,poSS,np(Agmt0,Kernel0,Mods0))|PostMods1],
              Kernel,Agmt,Type,PostMods,Mods).
optional_possessive(Kernel,Agmt,Type,PostMods,Mods,
           Kernel,Agmt,Type,PostMods,Mods) ---> noText.

gen_case, theText80(the) ---> gen_marker.


gen_marker ---> theText80('\'s'),{!}.
gen_marker ---> theText80('\''), an_s.

an_s ---> textOpt([s]).

:- thread_local(lctmp:in_sent801/0).
:- thread_local(lctmp:in_sent802/0).
:- thread_local(lctmp:in_sent803/0).
:- thread_local(lctmp:in_sent804/1). 

of_type(P,H) ---> {P=..[F|List],PH=..[F,H|List]},PH.
nl_list_of_items(AndOr,P, [H,T])---> xg_peek([_,_,_]), of_type(P,H), maybeComma, {member(AndOr,[and,or])}, theText80(AndOr), of_type(P,T),!.
nl_list_of_items(AndOr,P, [H|T])---> xg_peek([_,_,_,_]), of_type(P,H), maybeComma, !, nl_list_of_items(AndOr,P, T).


np_objbody(string(List),3+sg,defA+proper) ---> w2_quoted(List),!.

np_objbody(S,_,_)--->   span_s(S).

%np_objbody(Det,Number,Def) ---> {if_search_expanded(2)}, np_objbody(Det,Number,Def).
np_objbody((Name),3+sg,defA+proper) ---> name_xg(Name).


np_objbody((prep_obj(Word,S)),Agmt,Type) ---> {fail},
  {if_search_expanded(5)},
   prep(Word),
 {is_prep_case(Case)},
  locally(tlclone:np_in_case(Case),subj(S,Agmt,Type)).

%np_objbody(((Int)),3+sg,defA+proper) ---> theText80(Value),{tr_number(Value,Int)}.
%np_objbody((adj(VGood)),_,_) --->   {if_search_expanded(6)},theText80(Good), {clex:adj_itr(Good,VGood)}.
/*
np_objbody(Type_X, Y, Z, A, B, C, D) :-
    \+ lctmp:in_sent801, !, 
     locally(lctmp:in_sent801,np_objbody0(Type_X, Y, Z, A, B, C, D)).
np_objbody(Type_X, Y, Z, A, B, C, D) :-
    \+ lctmp:in_sent802,
     locally(lctmp:in_sent802,np_objbody0(Type_X, Y, Z, A, B, C, D)).

np_objbody0(Det,Number,Def)--->theText80(that),!,np_objbody1(Det,Number,Def).
%np_objbody0((var(Type_X)),3+sg,defA+proper) ---> variable_q(Type_X,_,_QCase,_NPCase).
%np_objbody0(_,_,_,_,_,_,_):- !, fail.
%np_objbody0(Det,Number,Def)--->np_objbody1(Det,Number,Def).

np_objbody0(Type_X, Y, Z, A, B, C, D) :-
    if_search_expanded(2),
    \+ lctmp:in_sent803,
     locally(lctmp:in_sent803,np_objbody1(Type_X, Y, Z, A, B, C, D)).

% test_chat80("How many countries does the danube flow through ?").

np_objbody1((sent0(S)),_,_) ---> xg_peek([_,_]),s80(S,_).
%rel(Agmt,rel(Type_X,S),Mask) 

np_objbody1((sent2(Type_X,S)),_Agmt,_) ---> xg_peek([_,_]),
   mark_island,
   prep(Type_X),
   s80(S,_),   
   mark_dnalsi.
*/

%np_objbody(Type_X,Y,Z) ---> quant_phrase(Type_X,Y,Z).
%np_objbody0(quantV(Op,Quant),Number,Def) ---> quant_p(Op,Def), number(Quant,Number).

/* Determiners */

determiner(Det,Number,Def) ---> det(Det,Number,Def).
determiner(Det,Number,Def) ---> quant_phrase(Det,Number,Def).

% Measure is Type_X
quant_phrase(quantV(Op,Quant),Number,Def) --->
   quant_p(Op,Def),
   number(Quant,Number).

% Measure is more / less than
quant_p(Op,indefA) --->
   neg_adv_opt(Op0,Op),
   comp_adv(Op0),
   theText80(than).

% Measure is at least / most
quant_p(Op,indefA) --->
   theText80(at),
   sup_adv(Adv),
   {sup_op(Adv,Op)}.
   

quant_p(the,defA) ---> theText80(the).
quant_p(same,indefA) ---> noText.

neg_adv_opt(Adv,notP([])+Adv) ---> theText80(not).
neg_adv_opt(Adv,Adv) ---> noText.

sup_op(least,notP([])+less).
sup_op(most,notP([])+more).

/* Noun phrase modifiers */

np_mods(Agmt,Case,Mods0,[Mod|Mods],Set0,Set,_,Mask) --->
   np_mod(Agmt,Case,Mod,Set0,Mask0),
   {is_trace_bits(Trace), plus_mask(Trace,Mask0,Mask1), minus_mask(Set0,Mask1,Set1),
    plus_mask(Mask0,Set0,Mask2)},
   np_mods(Agmt,Case,Mods0,Mods,Set1,Set,Mask2,Mask).
np_mods(_,_,Mods,Mods,Set,Set,Mask,Mask) ---> noText.

np_mod(_,Case,PP,Set,Mask) ---> xg_prep_phrase(_PPAlowed,PP,Case,Set,Mask).
np_mod(Agmt,_Case,WH,Set,Mask) --->
   reduced_relative(Agmt,WH,Set,Mask).

/* Verb modifiers */

maybe_verb_pre_mods(ExtraMods,Set,Mask0,Mask1)--->
  verb_mods(pre,ExtraMods,Set,Mask0,Mask1),!.
  
verb_mods(PrePost,[Mod|Mods],Set0,_,Mask) --->
   verb_mod(PrePost,Mod,Set0,Mask0),
   {ignore((is_trace_bits(Trace), plus_mask(Trace,Mask0,Mask1), minus_mask(Set0,Mask1,Set1),
    plus_mask(Mask0,Set0,Mask2)))},
   verb_mods(PrePost,Mods,Set1,Mask2,Mask).
verb_mods(_,[],_,Mask,Mask) ---> noText.

verb_mod(pre,ExtraMods,_Set,_Mask0)---> maybe_modal(_,[],ExtraMods),!.
verb_mod(pre,Adv,_Set,_Mask) ---> adverb(Adv).
verb_mod(PrePost,Adv,Set,Mask) ---> adv_phrase(PrePost,Adv,Set,Mask).
verb_mod(PrePost,Adv,Set,Nil) --->
   {(is_adv_bits(Set);PrePost==pre)->true},
   adverb(Adv),
   {(is_empty_bits(Nil);PrePost==pre)->true}.
verb_mod(post,PP,Set,Mask) ---> xg_prep_phrase(_PPAlowed,PP,compL,Set,Mask).

adv_phrase(post,prep_phrase(PPType,Prep,NP),Set,Mask) --->
   loc_pred(Of,Prep), % north of
   xg_prep_phrase(_PPAlowed,prep_phrase(PPType,prep(Of),NP),compL,Set,Mask).

/* Adjectival Constructions */

post_determiner_pre_noun([Adj|Adjs]) --->
   post_det_pre_noun(Adj),
   post_determiner_pre_noun(Adjs).
post_determiner_pre_noun([]) ---> noText.

post_det_pre_noun(sup(brightly,shinning)) ---> theText80(brightly),theText80(shinning).
post_det_pre_noun(_Adj) --->  (thePos80((d_;w_;i_));ace_var(_); name_xg(_Name)),!,{fail}.
post_det_pre_noun(Adj) --->  sup_phrase(Adj).
post_det_pre_noun(Adj) ---> adj(_,Adj).
post_det_pre_noun(adj(Adj)) ---> thePos80((jj;jjs;cd),Adj).
post_det_pre_noun(adj(Adj)) ---> xg_peek(thePos80(nn_)),!,theText80(Adj),xg_peek(thePos80((nn_;pn_;jj;jjs),_)).
post_det_pre_noun(adj(involved(self,Verb,Args,ModsOut))) ---> {fail},
   advs_opt(ModsOut,Mods,_Set),
   just_vp_1(_Subj,_Agmt,_Type,Verb,Args,Mods,_Mask) .
% TODO WHY post_det_pre_noun(poSS(Pronoun,Agreement)) ---> poss_pron(Pronoun,Agreement).


sup_phrase(sup(Op,Adj)) --->
   sup_adv(Op), % @DMILES why was Adv ?
   adj(quantA,Adj).
sup_phrase(sup(most,Adj)) ---> sup_adj(Adj).

comp_phrase(comp(Comp,Adj,Arg),Mask) --->
   comp_6(Comp,Adj),
   {is_np_no_trace(NPNT), is_prep_case(Case)},
   np_11(Arg,_,Case,_,compL,NPNT,Mask).

% Measure is Numerically More
comp_6(Comp,Adj) --->
   comp_adv(Comp), % greater
   adj(quantA,Adj),
   theText80(than).

% Measure is NON-Numerically More
comp_6(more,Adj) --->
   comp_adj(Adj), % faster
   theText80(than).
   
% Measure is same = "as big as"  ?
comp_6(same,Adj) --->
   theText80(as),
   adj(quantA,Adj), % lean
   theText80(as).

/* Prepositional Phrase */

prep_arg_vp(vact(V,A,S)) ---> {if_search_expanded(4)},
      imperative_verb(_,_),
      s80(s(_,V,A,S)).

xg_prep_phrase(_PPAlowed,prep_phrase(_PPType,Prep,Arg),_Case,_Set,_Mask) --->
   prep(Prep),
   {is_prep_case(_NPCase)},
   prep_arg_vp(Arg).

xg_prep_phrase(_PPAlowed,prep_phrase(_PPType,Prep,Arg),Case,Set,Mask) --->
   prep(Prep),
   {is_prep_case(NPCase)},
   np_11(Arg,_,NPCase,_,Case,Set,Mask).


xg_prep_phrase(_PPAlowed,prep_phrase(_PPType,Prep,Arg),_Case,_Set,_Mask) --->
   prep(Prep),noText,
   {Arg=np_head(_Var,generic,[],_)}.

/* Relative clause */

optional_relative(Agmt,[Rel],Set,_,Mask) --->
   {is_pred(Set)},
   rel_conj(Agmt,_Conj,Rel,Mask).
optional_relative(_,[],_,Mask,Mask) ---> noText.

rel_conj(Agmt,Conj,Rel,Mask) --->
   rel(Agmt,Rel0,Mask0),
   rel_rest(Agmt,Conj,Rel0,Rel,Mask0,Mask).

rel_rest(Agmt,Conj0,Rel0,Rel,_,Mask) --->
   conj_9(Conj0,Conj,Rel0,Rel1,Rel),
   rel_conj(Agmt,Conj,Rel1,Mask).
rel_rest(_,_,Rel,Rel,Mask,Mask) ---> noText.

rel(Agmt,rel(Type_X,S),Mask) --->
   mark_island,
   variable(Agmt,Type_X),
   s80(S,Mask0),
   {is_trace_bits(Trace), minus_mask(Mask0,Trace,Mask)},
   mark_dnalsi.

variable(Agmt,Type_X) ... np_11(np(Agmt,wh(Type_X),[]),Agmt,_,_,_,Set,Mask) --->
    (theText80(that);theText80(this);theText80(who)),
   {is_trace82(Set,Mask)}.
variable(Agmt0,Type_X) ... np_11(NP,Agmt,NPCase,_,_,Set,Mask) --->
   wh_9(Type_X,Agmt0,NP,Agmt,NPCase),
   {is_trace82(Set,Mask)}.
variable(Agmt0,Type_X) ... xg_prep_phrase(_PPAlowed,prep_phrase(_PPType,Prep,NP),compL,Set,Mask) --->
   prep(Prep),
   wh_9(Type_X,Agmt0,NP,_Agmt,Case),
   {is_trace82(Set,Mask), is_compl_case(Case)}.

wh_9(Type_X,Agmt,np(Agmt,wh(Type_X),[]),Agmt,NPCase) --->
   wh_rel_pron(Case),
   {is_to_role_case(Case,decl,NPCase)}.
wh_9(Type_X,Agmt0,np(Agmt,Kernel,[prep_phrase(_PPType,Prep,NP)]),Agmt,_) --->
   np_head0(Kernel,Agmt,_+common),
   prep(Prep),
   wh_9(Type_X,Agmt0,NP,_,_).
wh_9(Type_X,Agmt0,NP,Agmt,Case) --->
   whose(Type_X,Agmt0),
   {is_s_all(SAll)},
   np_11(NP,Agmt,Case,defA,subjA,SAll,_).

/* Reduced relative clause */

reduced_relative(Agmt,Rel,Set,Mask) --->
   {is_pred(Set)},
   reduced_rel_conj(Agmt,_Conj,Rel,Mask).

reduced_rel_conj(Agmt,Conj,Rel,Mask) --->
   reduced_rel(Agmt,Rel0,Mask0),
   reduced_rel_rest(Agmt,Conj,Rel0,Rel,Mask0,Mask).

reduced_rel_rest(Agmt,Conj0,Rel0,Rel,_,Mask) --->
   conj_9(Conj0,Conj,Rel0,Rel1,Rel),
   reduced_rel_conj(Agmt,Conj,Rel1,Mask).
reduced_rel_rest(_,_,Rel,Rel,Mask,Mask) ---> noText.

reduced_rel(_Agmt,reduced_rel(Type_X,decl(s( np(3+sg,np_head(_Var1,generic,[],Type_X),[]),
                         verb(main+tv,name,[],active,past+fin,[],([])),
                         [ arg(dirO,np(3+sg,np_head(_Var2,generic,[],Name),[]))],
                       []))),_Mask) ---> 
   theText80(named), name_xg(Name).

reduced_rel(Agmt,reduced_rel(Type_X,S),Mask) --->
   mark_island,
   reduced_wh(Agmt,Type_X),
   s80(S,Mask0),
   {is_trace_bits(Trace), minus_mask(Mask0,Trace,Mask)},
   mark_dnalsi.

reduced_wh(Agmt,Type_X),
   np_11(np(Agmt,wh(Type_X),[]),Agmt,NPCase,_,_,Set0,Mask0),
   verb_form88(ExtraMods,aux(be,_),pres+fin,Agmt,main),
   neg_modal_opt(Tense,ExtraMods,_,Neg), pred(Neg,Pred,Mask) 
     --->
   neg_modal_opt(Tense,ExtraMods,_,Neg), pred(Neg,Pred,Mask),
   {is_trace82(Set0,Mask0), is_subj_case(NPCase)}.
reduced_wh(Agmt,Type_X),
   np_11(np(Agmt,wh(Type_X),[]),Agmt,NPCase,_,_,Set,Mask),
   verb_with_rest(Verb,_,Type,Voice) --->
   participle_vt(Verb,Type,Voice),
   {is_trace82(Set,Mask), is_subj_case(NPCase)}.
reduced_wh(AgmtX,Type_X),
   np_11(Subj,Agmt,SCase,Def,_,Set0,Mask0) ...
   np_11(np(AgmtX,wh(Type_X),[]),AgmtX,VCase,_,_,Set,Mask) --->
   {is_s_all(SAll), is_subj_case(SCase), is_verb_case(VCase)},
   np_11(Subj,Agmt,_,Def,subjA,SAll,_),
   {is_trace82(Set0,Mask0), is_trace82(Set,Mask)}.


/*

Passive forms

<> jill <> was <> being <> given <> a key <>
<> jill <> was <> given <> a key <>
<> bob <> was <> giving <> jill <> a key
<> bob <> did <> give <> jill <> a key
<> bob <> gave <> jill <> a key

*/

/* Verb phrase (less the complements) */

verb_form88(ExtraMods,RootVerb,Tense,Agmt,Role) ---> verb_form883(ExtraMods,RootVerb,Tense,Agmt,Role).
/*
verb_form88(ExtraMods,Root,Tense,Agmt,Role) ---> {unloop(verb_form88), fail},
   verb_with_rest(verb(Type,Root,Voice,TimeFin,Aspect,Neg),Agmt,Type,Voice),
   {ExtraMods=[Type,Voice,TimeFin,Aspect,Neg,Agmt,Tense,Agmt,Role]}.
*/
%verb_form88(ExtraMods,RootVerb,Tense,Agmt,Role) ---> verb_form884(ExtraMods,RootVerb,Tense,Agmt,Role).
%verb_form88(List,aux(be,List),_Tense,_Agmt,_Role)---> {unloop(verb_form88)}, scan_segment(verb_m,List).
verb_form882(ExtraMods,RootVerb,Tense,Agmt,Role) ---> verb_form88(ExtraMods,RootVerb,Tense,Agmt,Role).

verb_with_rest(verb(Type,Root,Voice,Timefin,Aspect,Neg),Agmt,Type,Voice) ---> 
     % {is_empty_bits(Nil), is_s_all(SAll)},   
   {Timefin=_Time+fin},   
   maybe_verb_pre_mods(ExtraMods1,_Set,_Mask0,_Mask1),
   verb_form88(ExtraMods2,Root0,Timefin,Agmt,Role),
   {verb_type_lex(Root0,Type0)},
   neg_modal_opt(_Tense1,[],Type0,NegI),
   rest_verb(ExtraMods3,Role,Root0,Root,Voice,Aspect),
   {append_mods([ExtraMods1,ExtraMods2,ExtraMods3],ExtraMods),
    add_extra_to_neg(NegI,ExtraMods,Neg),
    verb_type_lex(Root,Type)}.
    
neg_modal_opt(Tense,ExtraMods,Aux,Neg) --->
  (maybe_modal0(Tense,ExtraMods,ModalInfo);{ExtraMods=ModalInfo}),!,
  neg_modal_opt1(ModalInfo,Aux,Neg).

neg_modal_opt1(ExtraMods,aux+_,negP(ExtraMods)) ---> theText80(not).
neg_modal_opt1(ExtraMods,_,(ExtraMods)) ---> noText .


% carved is quickly
% carved quickly is
% is carved quickly
% is quickly carved
% quickly carved is
% quickly is carved

xg_call(P,List,A,B,C,D):- call(P,List,A,B,C,D). 

scan_segment(P,[H|List]) ---> xg_call(P,H),!,scan_segment0(P,List).
scan_segment0(P,[H|List]) ---> xg_call(P,H),!,scan_segment0(P,List).
scan_segment0(_,[])---> [].

%verb_m(M) ---> adverb(M).
verb_m(waits) ---> theText80(waits). 
verb_m(M) ---> thePos80((aux;vb_;rbr;rbs),M).


verb_form883(ExtraMods,RootVerb,Tense,_Agmt1,_Role) ---> % {fail},
   theText80(W),
   {verb_form_aux(W,RootVerb,Tense,_Agmt2),flatten([RootVerb],ExtraMods)}.

verb_form883(ExtraMods,RootVerb,Tense,Agmt,Role) ---> {unloop(maybe_verb_pre_mods,2)},
   maybe_modal(_Tense1,[],ExtraMods1), !,
   verb_form88(ExtraMods2,RootVerb,Tense,Agmt,Role),
   {append_mods([ExtraMods1,ExtraMods2],ExtraMods)}.

verb_form883(ExtraMods,RootVerbO,Tense,Agmt,_Role) ---> 
   theText80_W2(W,L),
   {verb_form_wlex(L,W,RootVerb,Tense,Agmt)},
   maybe_verb_prep(RootVerb,RootVerbO,ExtraMods).

verb_form884([],adj_prep(P,ToFrom),_Tense,_Agmt,_Role) --->
   {if_search_expanded(2)},
   pre_prep_adj(P),prep(ToFrom).
%verb_form882([],aux(do,[]),Tense,Agmt,_Role) ---> xg_peek(theText80(will)).

pre_prep_adj(P) ---> theText80(W),{(clex:adj_itr(W,P);
 (negprefix:negprefix(a,W1,un,W2),(W=W1;W=W2),P=W);(wnframes:opposite(a,W1,W2,_),(W=W1;W=W2),P=W);clex:tv_pp(W,P))}.
pre_prep_adj(P) ---> adj_phrase(P,_Mask),!.

maybe_verb_prep(RootVerb,RootVerb,[])--->[].
maybe_verb_prep(RootVerb,RootVerb,[prep(Prep)]) ---> {if_search_expanded(7)}, prep(Prep).
maybe_verb_prep(RootVerb,verb_prep(RootVerb,Prep),[]) ---> {if_search_expanded(6)}, prep(Prep).


append_mods([], []).
append_mods([L|Ls], As) :- (var(L)->L1=[];flatten([L],L1)),!, append(L1, Ws, As), append_mods(Ls, Ws).

one_modal(_,not) ---> theText80(not), xg_peek(thePos80(vb_)).
%one_modal(_Tense1,_MODAL1) ---> !,{fail}.
one_modal(_,not) ---> theText80(not), xg_peek(thePos80(vb_)).
one_modal(_Tense1,_MODAL1) ---> {\+ if_search_expanded(2),!,fail}.
one_modal(_Tense1,MODAL1) ---> theText80(W),{modal_verb_form_aux(W,MODAL1,_Tense2,_)}.
one_modal(_Tense1,Modal) ---> thePos80([pos(md),root(Modal)]).


maybe_modal(Tense,In,[M|Out]) ---> one_modal(Tense,M),!,maybe_modal0(Tense,In,Out).

maybe_modal0(Tense,In,[M|Out]) ---> one_modal(Tense,M),!,maybe_modal0(Tense,In,Out).
maybe_modal0(_,ExtraMods, ExtraMods) ---> [].

rest_verb([Pastpart|ExtraMods],aux,aux(have,ExtraMods1),Root,Voice,[perf|Aspect]) ---> 
  verb_form882(ExtraMods2,Root0,Pastpart,_,_), 
  have_vt(ExtraMods3,Root0,Root,Voice,Aspect),{append_mods([ExtraMods1,ExtraMods2,ExtraMods3],ExtraMods)}.
rest_verb(ExtraMods,aux,aux(be,ExtraMods1),Root,Voice,Aspect) ---> verb_form882(ExtraMods2,Root0,Tense0,_,_), be_vt(ExtraMods3,Tense0,Root0,Root,Voice,Aspect),{append_mods([ExtraMods1,ExtraMods2,ExtraMods3],ExtraMods)}.
rest_verb(ExtraMods,aux,aux(do,ExtraMods1),Root,active,[]) ---> verb_form882(ExtraMods2,Root,inf,_,_),{append_mods([ExtraMods1,ExtraMods2],ExtraMods)}.
%rest_verb(ExtraMods,aux,Can,Root,active,[]) ---> {modal_verb_form_aux(_,Can,_,_)},verb_form882(ExtraMods1,Root,inf,_,_),{append([[Can],ExtraMods1],ExtraMods)}.
%rest_verb(ExtraMods,aux,Wont,Root,active,[]) ---> {modal_verb_form_aux(Wont,List,_,_),flatten([List],ListF)},verb_form882(ExtraMods1,Root,inf,_,_),{append([ListF,ExtraMods1],ExtraMods)}.
rest_verb([root],main,Root,Root,active,[]) ---> noText.


% BE
have_vt(ExtraMods,aux(be,_),Root,Voice,Aspect) --->
   verb_form882(ExtraMods1,Root0,Tense0,_,_),
   be_vt(ExtraMods2,Tense0,Root0,Root,Voice,Aspect),
   {append_mods([ExtraMods1,ExtraMods2],ExtraMods)}.
have_vt([],Root,Root,active,[]) ---> noText.

be_vt([],past+part,Root,Root,passive,[]) ---> noText.
be_vt(ExtraMods,pres+part,Root0,Root,Voice,[prog]) --->
   passive_vt(ExtraMods,Root0,Root,Voice).

% BE
passive_vt([EM|ExtraMods],aux(be,EM),Root,passive) --->
   verb_form882(ExtraMods1,Root,past+part,_,_),
   {verb_type_lex(Root,Type), passive_vt(ExtraMods2,Type), append_mods([ExtraMods1,ExtraMods2],ExtraMods)}.
passive_vt([],Root,Root,active) ---> noText.

participle_vt(verb(Type,Root,Voice,inf,Aspect,Neg),Type,Voice) --->
   neg_modal_opt(Tense,[],ExtraMods,Neg),
   verb_form882(ExtraMods,Root,Tense,_,_),
   {participle_vt(Tense,Voice,Aspect), verb_type_lex(Root,Type)}.

passive_vt([],_+tv).
passive_vt([],_+dv(_Prep)).

participle_vt(pres+part,active,[prog]).
participle_vt(past+part,passive,[]).

/* Extraposition brackets */

mark_island ... mark_dnalsi ---> noText.

/* Verb Arguments */

verb_args(_+Type,Voice,AdvArgs,Mask0,Mask) --->
   advs_opt(AdvArgs,Args,_),
   verb_args(Type,Voice,Args,Mask0,Mask).

verb_args(tv,active,[arg(dirO,Dir)],_,Mask) --->
   verb_arg(np,Dir,Mask).
verb_args(dv(_Prep),_,[arg(Case,NP)|Type_X],_,Mask) --->
   verb_arg(np,NP,Mask0),
   object_opt(Case,Type_X,Mask0,Mask).
% BE
verb_args(aux(be,_),_,[voidQ],Mask,Mask) ---> theText80(there).
verb_args(aux(be,_),_,[arg(arg_pred,P)],_,Mask) --->
   pred_conj(_,P,Mask).
verb_args(aux(be,_),_,[arg(dirO,P)],_,Mask) ---> verb_arg(np,P,Mask).
% HAVE
verb_args(aux(have,_),active,[arg(dirO,P)],_,Mask) ---> verb_arg(np,P,Mask).
verb_args(Type,_,[],Mask,Mask) ---> {no_args_vt(Type)}.

object_opt(Case,AdvArg,Mask0,Mask) --->
   {adv_bits(Adv), minus_mask(Adv,Mask0,Mask1)},
   advs_opt(AdvArg,Type_X,Mask1),
   obj_opt(Case,Type_X,Mask0,Mask).

obj_opt(indO,[arg(dirO,NP)],_,Mask) ---> verb_arg(np,NP,Mask).
obj_opt(dirO,[],Mask,Mask) ---> noText.

pred_conj(Conj,Arg,Mask) --->
   pred(_,Arg0,Mask0),
   pred_rest(Conj,Arg0,Arg,Mask0,Mask).

pred_rest(Conj0,Arg0,Arg,_,Mask) --->
   conj_9(Conj0,Conj,Arg0,Arg1,Arg),
   pred_conj(Conj,Arg1,Mask).
pred_rest(_,Arg,Arg,Mask,Mask) ---> noText.

verb_arg(np,NP,Mask) --->
   {is_s_all(SAll), is_verb_case(VCase)},
   np_11(NP,_,VCase,_,compL,SAll,Mask).

pred(_,Adj,Mask) ---> adj_phrase(Adj,Mask).
pred(negP(_Modal),PP,Mask) --->
   {is_s_all(SAll)},
   xg_prep_phrase(_PPAlowed,PP,compL,SAll,Mask).
pred(_,Adv,Mask) --->
   {is_s_all(SAll)},
   adv_phrase(post,Adv,SAll,Mask).

advs_opt([Adv|R0],R,Set) --->
   {is_adv_bits(Set)},
   adverb(Adv),
   advs_opt(R0,R,Set).
advs_opt(R,R,_) ---> noText.

adj_phrase(P,Nil) ---> adj(_,P), { is_empty_bits(Nil) }.
adj_phrase(P,Mask) --->  comp_phrase(P,Mask).

adverb(adv(W)) ---> theText80(W), {atom(W),atom_concat(_,'ly',W)}.
adverb(adv(Adv)) ---> theText80_W2(W,W2), {adv_lex_w2(W,W2,Adv)}, may_adverb(W).
adverb(adj(Adj)) ---> {if_search_expanded(3)},theText80_W2(W,W2), {adj_lex_w2(W,W2,Adj,_Type)}.
adverb(adv(W)) ---> theText80(W), {adverb_lex(W)}, may_adverb(W).
adverb(adv(t(A,B,C))) ---> theText80(W), {modal_verb_form_aux(W,A,B,C)}, may_adverb(W).

may_adverb(W)---> {\+ logical_s_word(W),\+ logical_o_word(W)}.
may_adverb(_)---> xg_peek( \+ [_]).
   
no_args_vt(tv).
no_args_vt(dv(_Prep)).
no_args_vt(iv).

/* Conjunctions */

conj_9(conj(Conj,Ctx0),
     conj(Conj,Ctx),Left,Right,
     conj(Conj,Left,Right)) --->
   conj_xg(Conj,Ctx0,Ctx).

%:-retract(tlxgproc:do_xg_process_te).

:-retract(t_l:disable_px).

/* @(#)clotab.pl	24.1 2/23/88 */

 
/* 
	Copyright 1986, Fernando C.N. Pereira and David H.D. Warren,

			   All Rights Reserved
*/
/*
 _________________________________________________________________________
|       Copyright (C) 1982                                                |
|                                                                         |
|       David Warren,                                                     |
|               SRI International, 333 Ravenswood Ave., Menlo Park,       |
|               California 94025, USA;                                    |
|                                                                         |
|       Fernando Pereira,                                                 |
|               Dept. of Architecture, University of Edinburgh,           |
|               20 Chambers St., Edinburgh EH1 1JZ, Scotland              |
|                                                                         |
|       This program may Be used, copied, altered or included in other    |
|       programs only for academic purposes and provided that the         |
|       authorship of the initial program is aknowledged.                 |
|       Use for commercial purposes without the previous written          |
|       agreement of the authors is forbidden.                            |
|_________________________________________________________________________|

*/
% Normal form masks

is_pp(#(1,_,_,_)).

is_pred(#(_,1,_,_)).

is_trace(#(_,_,1,_)).

is_adv_bits(#(_,_,_,1)).

is_trace82(#(_,_,1,_),#(0,0,0,0)).

is_trace_bits(#(0,0,1,0)).

adv_bits(#(0,0,0,1)).

is_empty_bits(#(0,0,0,0)).

is_np_all(#(1,1,1,0)).

is_s_all(#(1,0,1,1)).

is_np_no_trace(#(1,1,0,0)).

% Mask operations

plus_mask(#(B1,B2,B3,B4),#(C1,C2,C3,C4),#(D1,D2,D3,D4)) :-
   or_xmask(B1,C1,D1),
   or_xmask(B2,C2,D2),
   or_xmask(B3,C3,D3),
   or_xmask(B4,C4,D4).

minus_mask(#(B1,B2,B3,B4),#(C1,C2,C3,C4),#(D1,D2,D3,D4)) :-
   anot_xmask(B1,C1,D1),
   anot_xmask(B2,C2,D2),
   anot_xmask(B3,C3,D3),
   anot_xmask(B4,C4,D4).

or_xmask(1,_,1).
or_xmask(0,1,1).
or_xmask(0,0,0).

anot_xmask(X,0,X).
anot_xmask(_X,1,0).

% Noun phrase position features

is_to_role_case(subjA,_,#(1,0,0)).
is_to_role_case(compL,_,#(0,_,_)).
is_to_role_case(unDef,main,#(_,0,_)).
is_to_role_case(unDef,aux,#(0,_,_)).
is_to_role_case(unDef,decl,_).
is_to_role_case(nil,_,_).

is_any_case(#(_,_,_)).
is_subj_case(#(1,0,0)).
is_verb_case(#(0,1,0)).
is_prep_case(#(0,0,1)).
is_compl_case(#(0,_,_)).

:- op(100,fx,?).

user:portray(C):- notrace(fail), compound(C), \+ \+ (arg(_,C,E),nonvar(E)), portray_bits(C).
user:portray_bits('#'(PP,Pred,Trace,Adv)) :-
   portray_bit(prep_phrase,PP,S0,S1),
   portray_bit(pred,Pred,S1,S2),
   portray_bit(trace,Trace,S2,S3),
   portray_bit(adverb,Adv,S3,[]),
   write(S0).

portray_bit(Bit,Value,[?Bit|Bits],Bits) :- var(Value), !.
portray_bit(Bit,1,[+Bit|Bits],Bits).
portray_bit(Bit,0,[-Bit|Bits],Bits).
portray_bit(Bit,What,[Bit=What|Bits],Bits).
portray_bit(Bit,1,[Bit|Bits],Bits).
portray_bit(_Bit,0,Bits,Bits).
portray_bit(_,_,Bits,Bits).

end_of_file.
