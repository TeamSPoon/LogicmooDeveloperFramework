
:- op(1001,xfy, ('...' )).
:- op(1200,xfx, ('--->')).

%:- push_def(t_l:disable_px).

:-asserta(t_l:disable_px).

:- ignore(( \+(t_l:disable_px),trace,throw((\+(t_l:disable_px))))).
%:-asserta(tlxgproc:do_xg_process_te).

/* Sentences */

:- export(sentence80/5).
:- thread_local(tlclone:np_in_case/1).

xg_w2_len(0,[])---> !, [].
xg_w2_len(1,[W])---> [W], !.
xg_w2_len(1,[])---> !, []. %% missing puncts
xg_w2_len(N,[W|L])---> [W], {N>1, M is N -1},!,xg_w2_len(M,L).


link_s(S) --->
 { \+ lctmp:in_sent804 }, !, 
     locally(lctmp:in_sent804,link_s_1(S)),
     xg_peek(link_s_w(_)).

link_s_w(Words) ---> link_t_1('S',Words),!.
link_s_w(Words) ---> link_t_1('SBAR',Words),!.

link_s_1(S) ---> link_s_w(Words), !,{sentence801(S,Words,[],[],[])}.

link_t_1(Type,[w(S,L)|Words], [w(S,L)|A], B, X, X) :-
  member(loc(N),L),
  select(link(_, Type, r(Type, seg(N, M))),L,L2),
  \+ member(link(_, Type, r(Type, seg(N, _))),L2),
   Len is M-N,
   (length(Words,Len),append(Words,B,A)),!.



sentence80(S) ---> {b_setval('$prev_w2s', []),b_setval('$prev_spans', [])},!, sentence80e(S).
sentence80e(S) ---> sentence800(S).
%sentence80e(S) ---> sentence800(S1)*->sentence801s(sentence80,S1,S).

sentence800(S) ---> sentence801(S)*->{true};(link_s(S)*->{true};q_sentence800(S)).

q_sentence800(S) ---> startQuotesEnding(E),!,sentence801(S),E,!.

\+ (X) ---> (X -> {fail} ; {true}).

sentence801s(_,S1, S1, W, W, C, C) :- W==[], !.
sentence801s(_,S1, \+ (S1)) ---> theText80(is),theText80(false).
sentence801s(_,S1, (S1)) ---> theText80(is),theText80(true).
sentence801s(P,S1,Out) ---> theText80(Means),{join_over_s(S1,Means,S2,Out)},!,call(P,S2).
sentence801s(P,S1,(S1,S2)) --->  !,call(P,S2).


join_over_s(S1,implies,S2,(S1=>S2)).
join_over_s(S1,means,S2,Out):- !, join_over_s(S1,implies,S2,Out).
join_over_s(S1,if,S2,Out):- !, join_over_s(S2,implies,S1,Out).
join_over_s(S1,whenever,S2,Out):- !, join_over_s(S2,implies,S1,Out).
join_over_s(S1,then,S2,Out):- !, join_over_s(S1,implies,S2,Out).

:- dynamic(if_giveup_dcg/0).
sentence801(_) ---> {if_giveup_dcg,!,fail}.
sentence801(S) ---> xg_from_right(the_w2_list(List),theText80(Last)),{arg(_,v('?','!','.'),Last)},!,{sentence_typed(Last,S,List)}.
sentence801(S) ---> sentence802(S).

sentence802(S) ---> sentence803(S) *-> {true} ; sentence804(S).

%sentence802(np(Subj)) ---> theText80(there),thePos80(root(be)),subj(Subj,_Agmt,_Type).
%sentence802(np(Subj)) ---> theText80(there),thePos80(root(exist)),subj(Subj,_Agmt,_Type).
sentence803(S) ---> declarative(S).
sentence803(S) ---> question80(S).
sentence803(S) ---> imperative80(S).

sentence804(np(Subj)) ---> {fail}, subj(Subj,_Agmt,_Type).

sentence_typed('?',S,List):- question80(S,List,[],[],[]).
sentence_typed(Punct,Out,List):- s80(S,_,List,[],[],[]),punct_to_sent_type(Punct,S,Out).
sentence_typed(_,S,List):- imperative80(S,List,[],[],[]).

punct_to_sent_type((?),S,q(S)).
punct_to_sent_type((.),S,decl(S)).
punct_to_sent_type((!),S,decl(S)).
punct_to_sent_type(missing,S,decl(S)).


question80(S)--->wh_question(S).
question80(S)--->yn_question(S).



/* Declarative sentence */

declarative(decl(S)) ---> s80(S). % ,sentence801s(s80,S1,S).

/* Wh-questions */

wh_question(whq(X,S)) --->
   variable_q(X,_,QCase,NPCase),
   question80(QCase,NPCase,S).

variable_q(X,Agmt,QCase,NPCase) ...
      np(NP,Agmt,NPCase,_,_,Set,Mask) --->
   whq(X,Agmt,NP,QCase),
   {is_trace82(Set,Mask)}.

variable_q(X,Agmt,compl,CCase) ...
 xg_prep_phrase(_PPAlowed,prep_phrase(_PPType,Prep,NP),compl,Set,Mask) --->
   prep(Prep),
   whq(X,Agmt,NP,_),
   {is_trace82(Set,Mask), is_compl_case(CCase)}.
variable_q(X,Agmt,compl,VCase) ...
      adv_phrase(post,prep_phrase(_PPType,Prep,
                  np(Agmt,
                   np_head(_Var,
                    wh_det(_Kind,X),[],Noun),[])),
                 Set,Mask) --->
   context_pron(Prep,Noun),
   {is_trace82(Set,Mask), is_verb_case(VCase)}.
variable_q(X,_,compl,VCase) ...
      pred(adj,value80(Adj,wh(X)),Mask) --->
   theText80(how),  % how big
   adj(quantV,Adj),
   {is_empty_bits(Mask), is_verb_case(VCase)}.

whq(X,Agmt,NP,undef) --->
   wh_det(_Kind,X,Agmt),
   {is_s_all(SAll)},
   np(NP,Agmt,_,_,subJ(_ArgInfo1),SAll,_).
whq(X,3+No,np(3+No,wh(X),[]),Case) ---> wh_pron(Case).

wh_det(_Kind,X,3+Agmt) ---> whose(X,Agmt).
wh_det(Kind,X,3+Agmt) ---> wh_art_6(Kind,X,Agmt).

whose(X,Agmt), np_head0(wh(X),Agmt,proper), gen_marker ---> theText80(whose).

question80(QCase,NPCase,S) --->
   {subj_question(QCase), is_to_role_case(subJ(_ArgInfo1),_,NPCase)},
   s80(S).
question80(QCase,NPCase,S) --->
   fronted_verb(QCase,NPCase),
   s80(S).

wh_art_6(Kind,X,Agmt), det(DX,Agmt,def) ---> wh_art(Kind,X,Agmt,DX).

subj_question(subJ(_ArgInfo1)).
subj_question(undef).

/* Yes-no questions */

yn_question(q(S)) --->
   fronted_verb(nil,_),
   s80(S).


fronted_verb(QCase,NPCase) ...
      verb_form88(ExtraMods,Root,Tense,Agmt,Role), neg_modal_opt(Tense,_,_,Neg) --->
   verb_form88(ExtraMods,Root,Tense,Agmt,_),
   {verb_type_lex(Root,aux+_),
    is_to_role_case(QCase,Role,NPCase)},
   neg_modal_opt(Tense,ExtraMods,_,Neg).

/* Imperative sentences */

imperative80(imp(You,V,S)) --->
   imperative_verb(You,V),
   s80(S).

imperative_verb(You,Root),
   theText80(you),
   verb_form88(ExtraMods,Root,imp+fin,2+sg,main) --->
   verb_form88(ExtraMods,Root,inf,_,_),
   {You=you}.

/* Basic sentence (actually, declarative sentence) */




logical_s_word(Var):- var(Var),!,freeze(Var,logical_s_word(Var)).
logical_s_word(X):- logical_s_word(_,_,X).
logical_s_word(X):- if_search_expanded(5), logical_n_word(X).

logical_s_word(r,c,durring).
logical_s_word(r,c,after).
logical_s_word(r,c,before).
logical_s_word(r,c,because).
logical_s_word(r,c,when).
logical_s_word(r,c,whenever).
logical_s_word(r,c,unless).

logical_s_word(r,c,if).
logical_s_word(c,c,also).
logical_s_word(c,c,eigther).
logical_s_word(c,r,then).
logical_s_word(c,r,else).
logical_s_word(c,r,implies).
logical_s_word(c,r,otherwise).
logical_s_word(c,r,therefore).

logical_s_word2(r,c,[else,if]).

     logical_n_word(and).
     logical_n_word(or).
     logical_n_word(not).
     logical_n_word(except).
%logical_s_word(already).
%logical_s_word(but).
%logical_s_word(for).
%logical_s_word(anyways).
%logical_s_word(wanted).


% adp
is_sent_adverb(X):- member(X,[actually, apparently, basically, briefly, certainly, clearly, conceivably, confidentially,
  curiously, evidently, fortunately, hopefully, however, ideally, incidentally, indeed, 
  interestingly, ironically, naturally, predictably, presumably, regrettably, seriously, strangely,
   surprisingly, thankfully, theoretically, therefore, truthfully, ultimately, wisely]).

if_then(if,then).
if_then(when,do).
if_then(If,Then):- logical_s_word(If),logical_s_word(Then).

%if_cond(If,S,Then) ---> theText80(If),{if_then(If,Then)},s80(S),theText80(Then).
if_cond(If,S,Mask) ---> theText80(If),{logical_s_word(If)},!,s_vp_801(S,Mask).
if_cond(true,S,Mask) ---> s_vp_801(S,Mask).

s80(P) --->  s80(P,_).

s80(s(NP,verb(main+iv,E,[],active,_+fin,[],posP([])),[],[]),Mask) ---> 
   theText80(there),theText80_W2(_,L),{member(root(E),L),member(upos(verb),L)},verb_arg(np,NP,Mask).

s80(P,Mask) ---> s_vp_800(P,Mask).

s_vp_800(SO,Mask) ---> if_cond(IF,S,Mask), s_vp_800s(IF,S,SO,Mask).

s_vp_800s(true,S,SO,Mask) ---> !, from_true(S,SO,Mask).
s_vp_800s(IF,S,SO,Mask) ---> from_if(IF,S,SO,Mask).

s80lf(S1,SLF):- sent_to_prelogic(S1,SLF),!.
s80lf(S1,S1).

from_if(IF,S,SO,Mask) --->  theText80(Then),{logical_s_word(Then)},!,
  s80(S1,Mask),{s80lf(S1,SLF),  S=s(Subj,Verb,Args,Mods),append_cond(Args,IF-Then,SLF,ArgsO),SO=s(Subj,Verb,ArgsO,Mods)}.

from_true(S,S,_Mask)---> xg_peek(theText80(LW)),{ \+ logical_s_word(LW)},!.
from_true(S,SO,Mask)---> from_if(true,S,SO,Mask).
from_true(S,S,_Mask)---> [].

append_cond(Args,true,S,ArgsO):- append(Prev,[(IF)],Args),logical_s_word(IF),!,append(Prev,[cond(IF,S)],ArgsO).
append_cond(Args,true,S,ArgsO):- append(Prev,[cond(IF)],Args),logical_s_word(IF), !,append(Prev,[cond(IF,S)],ArgsO).
append_cond(Args,true,S,ArgsO):- 
   S = s(Subj,Verb,SArgs,Mods), 
  append(Prev,[(IF)],SArgs),logical_s_word(IF),!,
  SS = s(Subj,Verb,Prev,Mods), 
  append(Args,[cond(IF,SS)],ArgsO).
append_cond(Args,IF,S,ArgsO):- append(Args,[cond(IF,S)],ArgsO).


s_vp_801(s(Subj,Verb,Args,Mods),Mask) --->
  {is_subj_case(Case)},
   locally(tlclone:np_in_case(Case),
   subj(Subj,Agmt,Type)),
   just_vp(Subj,Agmt,Type,Verb,Args,Mods,Mask).

s_vp_801(s(NP,Verb,[],[]),_) --->  ace_var(AceVar), !,
   {Verb = verb(main+iv,action1,[],active,pres+fin,[],posP([])),
    NP= np(3+sg,np_head(_Var,generic(_),[adj(ace_var(self,AceVar)),adj(ti(statement,self))],statement),[])}.

/*
s_vp_801(NP,Verb,[],[],_) --->  ace_var(AceVar), !,
   {Verb = verb(main+iv,'action1:tell',[],active,pres+fin,[],posP(_)),
    NP= np(3+sg,np_head(_Var,generic(_),[adj(ace_var(self,AceVar)),adj(ti(statement,self))],statement),[])}.

s_vp_801(NP,Verb,[],[],_) --->  [],!,
   {Verb = verb(main+iv,tell,[],active,pres+fin,[],posP(_)),
    NP= np(3+sg,np_head(_Var,generic(_),[adj(ti(statement,self))],statement),[])}.
*/
just_vp(Subj,Agmt,Type,Verb,Args,Mods,Mask) --->
  s_vp1(Subj,Agmt,Type0,Verb0,Args0,Mods0,Mask0),
  more_s_vp1(Subj,Agmt,Type0,Verb0,Args0,Mods0,Mask0,Type,Verb,Args,Mods,Mask).
/*
more_s_vp1(Subj,Agmt,Type0,Verb0,Args0,Mods0,Mask0,
                     Type,Verb,Args,Mods,Mask) ---> 
   s_vp1(Subj,Agmt,Type1,Verb1,Args1,Mods1,Mask1).
*/
more_s_vp1(_Subj,_Agmt,Type,Verb,Args,Mods,Mask,Type,Verb,Args,Mods,Mask) ---> noText.
s_vp1(_Subj,Agmt,Type,Verb,Args,Mods,Mask) --->
   verb(Verb,Agmt,Type,Voice),
   {is_empty_bits(Nil), is_s_all(SAll)},
   verb_args(Type,Voice,Args,Nil,Mask0),
   {minus_mask(SAll,Mask0,Set), plus_mask(SAll,Mask0,Mask1)},
   verb_mods(post,Mods,Set,Mask1,Mask),
   no_new_obj.

no_new_obj ---> noText,!.
no_new_obj ---> xg_peek(\+ subj(_,_,_)).


subj(Subj,Agmt,Type) ---> subj0(Subj,Agmt,Type).

subj0(there,_Agmt,_+be(_)) ---> theText80(there).
subj0(Subj,Agmt,_) --->
   {is_s_all(SAll), is_subj_case(Case)},
   np(Subj,Agmt,Case,_,subJ(_ArgInfo1),SAll,_).



/* Noun Phrase */

np(AgmtKernelModsO,Agmt,Case,Def,Role,Set,Mask) --->
  locally(tlclone:np_in_case(Case),
    np0(AgmtKernelMods,Agmt,Case,Def,Role,Set,Mask)),
    extend_np(AgmtKernelMods,AgmtKernelModsO).


np0(np(Agmt,Pronoun,[]),Agmt,NPCase,def,_,Set,Nil) --->
   {is_pp(Set)},
   pers_pron(Pronoun,Agmt,Case),
   {is_empty_bits(Nil), is_to_role_case(Case,decl,NPCase)}.

np0(np(Agmt,Kernel,Mods),Agmt,_Case,Def,Role,Set,Mask) --->
   {is_pp(Set)},
   np_head(_Var,Kernel,Agmt,Def+Type,PostMods,Mods),
   {is_np_all(NPAll)},
   np_compls(Type,Agmt,Role,PostMods,NPAll,Mask).

% many of, one of
np0(part(Det,NP),3+Number,_,indef,Role,Set,Mask) --->
   {is_pp(Set)},
   determiner(Det,Number,indef), {Det\=generic(_)},
   theText80(of),
   {is_s_all(SAll), is_prep_case(Case)},
   np_expand(NP,3+pl,Case,def,Role,SAll,Mask).

np_expand(NP,A3+Apl,Case,def,Role,SAll,Mask) --->
  np(NP,A3+Apl,Case,def,Role,SAll,Mask).
np_expand(NP,_,_Case,def,Role,SAll,Mask) ---> {if_search_expanded(3)},
  np(NP,_,_,def,Role,SAll,Mask).

np_head(_Var,Kernel,Agmt,Type,PostMods,Mods) --->
   np_head0(Kernel0,Agmt0,Type0),
   optional_possessive(Kernel0,Agmt0,Type0,Mods0,Mods0,
              Kernel,Agmt,Type,PostMods,Mods).

np_compls(proper,_,_,[],_,Nil) ---> {is_empty_bits(Nil)}.
np_compls(common,Agmt,Case,Mods,Set0,Mask) --->
   {is_np_all(NPAll)},
   np_mods(Agmt,Case,Rel,Mods,Set0,Set,NPAll,Mask0),
   optional_relative(Agmt,Rel,Set,Mask0,Mask).

/* Nuclear noun phrase */

np_head0(_,_,_)---> has_trait(pos('.')),!,{fail}.
np_head0(nameOf(_Var,items(AndOr,List),[]),Agmt,Def)---> {if_search_expanded(2)}, nl_list_of_items(AndOr,np_head1(Agmt,Def),List).
np_head0(H,Agmt,Def)---> np_head1(H,Agmt,Def).

np_head1(H,Agmt,Def)--->np_head2(H,Agmt,Def).

np_head2(Pronoun,Agmt,def+proper), gen_marker --->
   poss_pron(Pronoun,Agmt).
np_head2(np_head(_Var,Det,[],Noun),3+sg,indef+common) --->
   quantifier_pron(Det,Noun).
np_head2(nameOf(_Var,O,[]),Agmt,Def) ---> np_objbody(O,Agmt,Def).
np_head2(np_head(_Var,Det,AdjsO,Head),3+Number,Def+common) --->
   determiner(Det,Number,Def),
   adjs_opt(Adjs),
   noun(Head,Adjs,AdjsO,Number).


extend_np(I,O) ---> np_amend(V), {append_np_mods(I,V,M)},!, extend_np(M,O).
extend_np(IO,IO)---> [].

np_amend(adj(ace_var(self,AceVar))) ---> ace_var(AceVar),!.
np_amend(adj(s_vp(self,Subj,Verb,Args,Mods,Mask))) ---> theText80(that),!,just_vp(Subj,_Agmt,_Type,Verb,Args,Mods,Mask).


append_np_mods(List,W,List):- is_list(List),member(E,List),W=@=E,!.
append_np_mods(List,W,[W|List]):- is_list(List),!.
append_np_mods(Comp,W,Comp):- sub_term(Head,Comp),compound(Head),(functor(Head,F,_),member(F,[np_head,nameOf])),
  N = 3, arg(N,Head,List),is_list(List),!,append_np_mods(List,W,Arg),nb_setarg(N,Head,Arg).
append_np_mods(Comp,_,Comp):-!.

ace_var(_,_).

/* Possessive construction */

optional_possessive(Kernel0,Agmt0,_,[],Mods0,
           Kernel,Agmt,Type,PostMods,Mods) --->
   gen_case,
   np_head0(Kernel1,Agmt1,Type1),
   optional_possessive(Kernel1,Agmt1,Type1,PostMods1,
              [prep_phrase(_PPType,poss(_ArgInfoP),np(Agmt0,Kernel0,Mods0))|PostMods1],
              Kernel,Agmt,Type,PostMods,Mods).
optional_possessive(Kernel,Agmt,Type,PostMods,Mods,
           Kernel,Agmt,Type,PostMods,Mods) ---> noText.

gen_case, theText80(the) ---> gen_marker.


gen_marker ---> theText80('\'s'),{!}.
gen_marker ---> theText80('\''), an_s.

an_s ---> textOpt([s]).

:- thread_local(lctmp:in_sent801/0).
:- thread_local(lctmp:in_sent802/0).
:- thread_local(lctmp:in_sent803/0).
:- thread_local(lctmp:in_sent804/0). 

of_type(P,H) ---> {P=..[F|List],PH=..[F,H|List]},PH.
maybeComma ---> (theText80(',');[]),!.
nl_list_of_items(AndOr,P, [H,T])---> xg_peek([_,_,_]), of_type(P,H), maybeComma, {member(AndOr,[and,or])}, theText80(AndOr), of_type(P,T),!.
nl_list_of_items(AndOr,P, [H|T])---> xg_peek([_,_,_,_]), of_type(P,H), maybeComma, !, nl_list_of_items(AndOr,P, T).




%np_objbody(Det,Number,Def) ---> {if_search_expanded(2)}, np_objbody(Det,Number,Def).
np_objbody((Name),3+sg,def+proper) ---> name_xg(Name).

np_objbody(S,_,_)--->  {if_search_expanded(6)}, {tlclone:np_in_case(Case), \+ is_subj_case(Case)}, link_s(S).
np_objbody(string(List),3+sg,def+proper) ---> w2_quoted(List),!.

np_objbody((prep_obj(X,S)),Agmt,Type) ---> {fail},
  {if_search_expanded(5)},
   prep(X),
 {is_prep_case(Case)},
  locally(tlclone:np_in_case(Case),subj(S,Agmt,Type)).

np_objbody((num(Int)),3+sg,def+proper) ---> theText80(Value),{tr_number(Value,Int)}.
%np_objbody((adj(VGood)),_,_) --->   {if_search_expanded(6)},theText80(Good), {clex:adj_itr(Good,VGood)}.
/*
np_objbody(X, Y, Z, A, B, C, D) :-
    \+ lctmp:in_sent801, !, 
     locally(lctmp:in_sent801,np_objbody0(X, Y, Z, A, B, C, D)).
np_objbody(X, Y, Z, A, B, C, D) :-
    \+ lctmp:in_sent802,
     locally(lctmp:in_sent802,np_objbody0(X, Y, Z, A, B, C, D)).

np_objbody0(Det,Number,Def)--->theText80(that),!,np_objbody1(Det,Number,Def).
%np_objbody0((var(X)),3+sg,def+proper) ---> variable_q(X,_,_QCase,_NPCase).
%np_objbody0(_,_,_,_,_,_,_):- !, fail.
%np_objbody0(Det,Number,Def)--->np_objbody1(Det,Number,Def).

np_objbody0(X, Y, Z, A, B, C, D) :-
    if_search_expanded(2),
    \+ lctmp:in_sent803,
     locally(lctmp:in_sent803,np_objbody1(X, Y, Z, A, B, C, D)).

% test_chat80("How many countries does the danube flow through ?").

np_objbody1((sent0(S)),_,_) ---> xg_peek([_,_]),s80(S,_).
%rel(Agmt,rel(X,S),Mask) 

np_objbody1((sent2(X,S)),_Agmt,_) ---> xg_peek([_,_]),
   mark_island,
   prep(X),
   s80(S,_),   
   mark_dnalsi.
*/

%np_objbody(X,Y,Z) ---> quant_phrase(X,Y,Z).
%np_objbody0(quantV(Op,Quant),Number,Def) ---> quantV(Op,Def), number(Quant,Number).

/* Determiners */

determiner(Det,Number,Def) ---> det(Det,Number,Def).
determiner(Det,Number,Def) ---> quant_phrase(Det,Number,Def).

% Measure is X
quant_phrase(quantV(Op,Quant),Number,Def) --->
   quantV(Op,Def),
   number(Quant,Number).

% Measure is more / less than
quantV(Op,indef) --->
   neg_adv_opt(Op0,Op),
   comp_adv(Op0),
   theText80(than).

% Measure is at least / most
quantV(Op,indef) --->
   theText80(at),
   sup_adv(Adv),
   {sup_op(Adv,Op)}.
   

quantV(the,def) ---> theText80(the).
quantV(same,indef) ---> noText.

neg_adv_opt(Adv,notP+Adv) ---> theText80(not).
neg_adv_opt(Adv,Adv) ---> noText.

sup_op(least,notP+less).
sup_op(most,notP+more).

/* Noun phrase modifiers */

np_mods(Agmt,Case,Mods0,[Mod|Mods],Set0,Set,_,Mask) --->
   np_mod(Agmt,Case,Mod,Set0,Mask0),
   {is_trace_bits(Trace), plus_mask(Trace,Mask0,Mask1), minus_mask(Set0,Mask1,Set1),
    plus_mask(Mask0,Set0,Mask2)},
   np_mods(Agmt,Case,Mods0,Mods,Set1,Set,Mask2,Mask).
np_mods(_,_,Mods,Mods,Set,Set,Mask,Mask) ---> noText.

np_mod(_,Case,PP,Set,Mask) ---> xg_prep_phrase(_PPAlowed,PP,Case,Set,Mask).
np_mod(Agmt,_Case,WH,Set,Mask) --->
   reduced_relative(Agmt,WH,Set,Mask).

/* Verb modifiers */

maybe_verb_pre_mods(ExtraMods,Set,Mask0,Mask1)--->
  verb_mods(pre,ExtraMods,Set,Mask0,Mask1).
maybe_verb_pre_mods([],_Set,_Mask0,_Mask1)---> noText.
  
verb_mods(PrePost,[Mod|Mods],Set0,_,Mask) --->
   verb_mod(PrePost,Mod,Set0,Mask0),
   {is_trace_bits(Trace), plus_mask(Trace,Mask0,Mask1), minus_mask(Set0,Mask1,Set1),
    plus_mask(Mask0,Set0,Mask2)},
   verb_mods(PrePost,Mods,Set1,Mask2,Mask).
verb_mods(_,[],_,Mask,Mask) ---> noText.

verb_mod(PrePost,Adv,Set,Mask) ---> adv_phrase(PrePost,Adv,Set,Mask).
verb_mod(_,Adv,Set,Nil) --->
   {is_adv_bits(Set)},
   adverb(Adv),
   {is_empty_bits(Nil)}.
verb_mod(post,PP,Set,Mask) ---> xg_prep_phrase(_PPAlowed,PP,compl,Set,Mask).

adv_phrase(post,prep_phrase(PPType,Prep,NP),Set,Mask) --->
   loc_pred(Of,Prep), % north of
   xg_prep_phrase(_PPAlowed,prep_phrase(PPType,prep(Of),NP),compl,Set,Mask).

/* Adjectival Constructions */

adjs_opt([Adj|Adjs]) --->
   pre_adj(Adj),
   adjs_opt(Adjs).
adjs_opt([]) ---> noText.

pre_adj(Adj) --->  sup_phrase(Adj).
pre_adj(Adj) ---> adj(_,Adj).
% TODO WHY pre_adj(poss(_ArgInfoP)(Pronoun,Agreement)) ---> poss_pron(Pronoun,Agreement).


sup_phrase(sup(Op,Adj)) --->
   sup_adv(Op), % @DMILES why was Adv ?
   adj(quantV,Adj).
sup_phrase(sup(most,Adj)) ---> sup_adj(Adj).

comp_phrase(comp(Comp,Adj,Arg),Mask) --->
   comp(Comp,Adj),
   {is_np_no_trace(NPNT), is_prep_case(Case)},
   np(Arg,_,Case,_,compl,NPNT,Mask).

% Measure is Numerically More
comp(Comp,Adj) --->
   comp_adv(Comp), % greater
   adj(quantV,Adj),
   theText80(than).

% Measure is NON-Numerically More
comp(more,Adj) --->
   comp_adj(Adj), % faster
   theText80(than).
   
% Measure is same = "as big as"  ?
comp(same,Adj) --->
   theText80(as),
   adj(quantV,Adj), % lean
   theText80(as).

/* Prepositional Phrase */

prep_arg_vp(vact(V,A,S)) --->
   imperative_verb808(_,_),
   s80(s(_,V,A,S)).

imperative_verb808(You,Root),
   theText80(you),
   verb_form88(ExtraMods,Root,imp+fin,2+sg,main) --->
   verb_form88(ExtraMods,Root,inf,_,_),
   {You=you}.

xg_prep_phrase(_PPAlowed,prep_phrase(_PPType,Prep,Arg),_Case,_Set,_Mask) --->
   prep(Prep),
   {is_prep_case(_NPCase)},
   prep_arg_vp(Arg).

xg_prep_phrase(_PPAlowed,prep_phrase(_PPType,Prep,Arg),Case,Set,Mask) --->
   prep(Prep),
   {is_prep_case(NPCase)},
   np(Arg,_,NPCase,_,Case,Set,Mask).


xg_prep_phrase(_PPAlowed,prep_phrase(_PPType,Prep,Arg),_Case,_Set,_Mask) --->
   prep(Prep),noText,
   {Arg=np_head(_Var,generic(_),[],_)}.

/* Relative clause */

optional_relative(Agmt,[Rel],Set,_,Mask) --->
   {is_pred(Set)},
   rel_conj(Agmt,_Conj,Rel,Mask).
optional_relative(_,[],_,Mask,Mask) ---> noText.

rel_conj(Agmt,Conj,Rel,Mask) --->
   rel(Agmt,Rel0,Mask0),
   rel_rest(Agmt,Conj,Rel0,Rel,Mask0,Mask).

rel_rest(Agmt,Conj0,Rel0,Rel,_,Mask) --->
   conj(Conj0,Conj,Rel0,Rel1,Rel),
   rel_conj(Agmt,Conj,Rel1,Mask).
rel_rest(_,_,Rel,Rel,Mask,Mask) ---> noText.

rel(Agmt,rel(X,S),Mask) --->
   mark_island,
   variable(Agmt,X),
   s80(S,Mask0),
   {is_trace_bits(Trace), minus_mask(Mask0,Trace,Mask)},
   mark_dnalsi.

variable(Agmt,X) ... np(np(Agmt,wh(X),[]),Agmt,_,_,_,Set,Mask) --->
    (theText80(that);theText80(this);theText80(who)),
   {is_trace82(Set,Mask)}.
variable(Agmt0,X) ... np(NP,Agmt,NPCase,_,_,Set,Mask) --->
   wh(X,Agmt0,NP,Agmt,NPCase),
   {is_trace82(Set,Mask)}.
variable(Agmt0,X) ... xg_prep_phrase(_PPAlowed,prep_phrase(_PPType,Prep,NP),compl,Set,Mask) --->
   prep(Prep),
   wh(X,Agmt0,NP,_Agmt,Case),
   {is_trace82(Set,Mask), is_compl_case(Case)}.

wh(X,Agmt,np(Agmt,wh(X),[]),Agmt,NPCase) --->
   wh_rel_pron(Case),
   {is_to_role_case(Case,decl,NPCase)}.
wh(X,Agmt0,np(Agmt,Kernel,[prep_phrase(_PPType,Prep,NP)]),Agmt,_) --->
   np_head0(Kernel,Agmt,_+common),
   prep(Prep),
   wh(X,Agmt0,NP,_,_).
wh(X,Agmt0,NP,Agmt,Case) --->
   whose(X,Agmt0),
   {is_s_all(SAll)},
   np(NP,Agmt,Case,def,subJ(_ArgInfo1),SAll,_).

/* Reduced relative clause */

reduced_relative(Agmt,Rel,Set,Mask) --->
   {is_pred(Set)},
   reduced_rel_conj(Agmt,_Conj,Rel,Mask).

reduced_rel_conj(Agmt,Conj,Rel,Mask) --->
   reduced_rel(Agmt,Rel0,Mask0),
   reduced_rel_rest(Agmt,Conj,Rel0,Rel,Mask0,Mask).

reduced_rel_rest(Agmt,Conj0,Rel0,Rel,_,Mask) --->
   conj(Conj0,Conj,Rel0,Rel1,Rel),
   reduced_rel_conj(Agmt,Conj,Rel1,Mask).
reduced_rel_rest(_,_,Rel,Rel,Mask,Mask) ---> noText.

reduced_rel(_Agmt,reduced_rel(X,decl(s( np(3+sg,np_head(X,generic(_),[],X),[]),
                         verb(main+tv,name,[],active,past+fin,[],posP([])),
                         [ arg(dirO(_),np(3+sg,np_head(_Var,generic(_),[],Name),[]))],
                       []))),_Mask) ---> 
   theText80(named), name_xg(Name).

reduced_rel(Agmt,reduced_rel(X,S),Mask) --->
   mark_island,
   reduced_wh(Agmt,X),
   s80(S,Mask0),
   {is_trace_bits(Trace), minus_mask(Mask0,Trace,Mask)},
   mark_dnalsi.

reduced_wh(Agmt,X),
   np(np(Agmt,wh(X),[]),Agmt,NPCase,_,_,Set0,Mask0),
   verb_form88(ExtraMods,be(_),pres+fin,Agmt,main),
   neg_modal_opt(Tense,ExtraMods,_,Neg), pred(Neg,Pred,Mask) 
     --->
   neg_modal_opt(Tense,ExtraMods,_,Neg), pred(Neg,Pred,Mask),
   {is_trace82(Set0,Mask0), is_subj_case(NPCase)}.
reduced_wh(Agmt,X),
   np(np(Agmt,wh(X),[]),Agmt,NPCase,_,_,Set,Mask),
   verb(Verb,_,Type,Voice) --->
   participle_vt(Verb,Type,Voice),
   {is_trace82(Set,Mask), is_subj_case(NPCase)}.
reduced_wh(AgmtX,X),
   np(Subj,Agmt,SCase,Def,_,Set0,Mask0) ...
   np(np(AgmtX,wh(X),[]),AgmtX,VCase,_,_,Set,Mask) --->
   {is_s_all(SAll), is_subj_case(SCase), is_verb_case(VCase)},
   np(Subj,Agmt,_,Def,subJ(_ArgInfo1),SAll,_),
   {is_trace82(Set0,Mask0), is_trace82(Set,Mask)}.

/* Verb phrase (less the complements) */

verb(verb(Type,Root,Voice,Time+fin,Aspect,Neg),Agmt,Type,Voice) --->
     % {is_empty_bits(Nil), is_s_all(SAll)},      
   maybe_verb_pre_mods(ExtraMods,_Set,_Mask0,_Mask1),
   verb_form88(ExtraMods,Root0,Time+fin,Agmt,Role),
   {verb_type_lex(Root0,Type0)},
   neg_modal_opt(_Tense,ExtraMods,Type0,Neg),
   rest_verb(ExtraMods,Role,Root0,Root,Voice,Aspect),
   {verb_type_lex(Root,Type)}.
   
verb(verb(Type,Root,Voice,Time+fin,Aspect,Neg),Agmt,Type,Voice) --->
     % {is_empty_bits(Nil), is_s_all(SAll)},      
   maybe_verb_pre_mods(ExtraMods1,_Set,_Mask0,_Mask1),
   verb_form88(ExtraMods2,Root0,Time+fin,Agmt,Role),
   {ignore(ExtraMods2=[])},
   {verb_type_lex(Root0,Type0)},
   neg_modal_opt1(ExtraMods,Type0,Neg),
   rest_verb(ExtraMods3,Role,Root0,Root,Voice,Aspect),
   {verb_type_lex(Root,Type),
    append([ExtraMods1,ExtraMods2,ExtraMods3],ExtraMods)}.
    
neg_modal_opt(Tense,ExtraMods,Aux,Neg) --->
  maybe_modal0(Tense,ExtraMods,ModalInfo),
  neg_modal_opt1(ModalInfo,Aux,Neg).

neg_modal_opt1(ExtraMods,aux+_,negP(ExtraMods)) ---> theText80(not).
neg_modal_opt1(ExtraMods,_,posP(ExtraMods)) ---> noText .

verb_form88(ExtraMods,RootVerb,Tense,Agmt,Role) --->
   maybe_modal(Tense2,[],ExtraMods1),!,
   verb_form88(ExtraMods2,RootVerb,Tense,Agmt,Role),
  {append(ExtraMods1,ExtraMods2,ExtraMods),ignore(Tense2=Tense)}.
verb_form88([],RootVerb,Tense,Agmt,_Role) --->
   theText80_W2(W,L),
   {verb_form_wlex(L,W,RootVerb,Tense,Agmt)}.

one_modal(Tense,MODAL1) ---> theText80(W),{modal_verb_form_aux(W,MODAL1,Tense,_)}.
% one_modal(_,not) ---> theText80(not).

maybe_modal(Tense,In,[M|Out]) ---> one_modal(Tense,M),maybe_modal0(Tense,In,Out).

maybe_modal0(Tense,In,[M|Out]) ---> one_modal(Tense,M),maybe_modal(Tense,In,Out).
maybe_modal0(_,ExtraMods, ExtraMods) ---> [].

rest_verb(ExtraMods,aux,have(_),Root,Voice,[perf|Aspect]) ---> verb_form88(ExtraMods1,Root0,past+part,_,_), have_vt(ExtraMods2,Root0,Root,Voice,Aspect),{append(ExtraMods1,ExtraMods2,ExtraMods)}.
rest_verb(ExtraMods,aux,be(_),Root,Voice,Aspect) ---> verb_form88(ExtraMods1,Root0,Tense0,_,_), be_vt(ExtraMods2,Tense0,Root0,Root,Voice,Aspect),{append(ExtraMods1,ExtraMods2,ExtraMods)}.
rest_verb(ExtraMods,aux,do(_),Root,active,[]) ---> verb_form88(ExtraMods,Root,inf,_,_).
%rest_verb(ExtraMods,aux,can,Root,active,[]) ---> verb_form88(ExtraMods,Root,inf,_,_).
%rest_verb(ExtraMods,aux,will,Root,active,[]) ---> verb_form88(ExtraMods,Root,inf,_,_).
rest_verb([],main,Root,Root,active,[]) ---> noText.


% BE
have_vt(ExtraMods,be(_),Root,Voice,Aspect) --->
   verb_form88(ExtraMods1,Root0,Tense0,_,_),
   be_vt(ExtraMods2,Tense0,Root0,Root,Voice,Aspect),
   {append(ExtraMods1,ExtraMods2,ExtraMods)}.
have_vt([],Root,Root,active,[]) ---> noText.

be_vt([],past+part,Root,Root,passive,[]) ---> noText.
be_vt(ExtraMods,pres+part,Root0,Root,Voice,[prog]) --->
   passive_vt(ExtraMods,Root0,Root,Voice).

% BE
passive_vt(ExtraMods,be(_),Root,passive) --->
   verb_form88(ExtraMods1,Root,past+part,_,_),
   {verb_type_lex(Root,Type), passive_vt(ExtraMods2,Type), append(ExtraMods1,ExtraMods2,ExtraMods)}.
passive_vt([],Root,Root,active) ---> noText.

participle_vt(verb(Type,Root,Voice,inf,Aspect,Neg),Type,Voice) --->
   neg_modal_opt(Tense,ExtraMods,_,Neg),
   verb_form88(ExtraMods,Root,Tense,_,_),
   {participle_vt(Tense,Voice,Aspect), verb_type_lex(Root,Type)}.

passive_vt([],_+tv).
passive_vt([],_+dv(_Prep)).

participle_vt(pres+part,active,[prog]).
participle_vt(past+part,passive,[]).

/* Extraposition brackets */

mark_island ... mark_dnalsi ---> noText.

/* Verb Arguments */

verb_args(_+Type,Voice,AdvArgs,Mask0,Mask) --->
   advs_opt(AdvArgs,Args,_),
   verb_args(Type,Voice,Args,Mask0,Mask).

verb_args(tv,active,[arg(dirO(_ArgInfo),Dir)],_,Mask) --->
   verb_arg(np,Dir,Mask).
verb_args(dv(_Prep),_,[arg(Case,NP)|X],_,Mask) --->
   verb_arg(np,NP,Mask0),
   object_opt(Case,X,Mask0,Mask).
% BE
verb_args(be(_),_,[voidQ(_ArgInfo)],Mask,Mask) ---> theText80(there).
verb_args(be(_),_,[arg(arg_pred(Conj),P)],_,Mask) --->
   pred_conj(Conj,P,Mask).
verb_args(be(_),_,[arg(dirO(_ArgInfo),P)],_,Mask) ---> verb_arg(np,P,Mask).
% HAVE
verb_args(have(_),active,[arg(dirO(_ArgInfo),P)],_,Mask) ---> verb_arg(np,P,Mask).
verb_args(Type,_,[],Mask,Mask) ---> {no_args_vt(Type)}.

object_opt(Case,AdvArg,Mask0,Mask) --->
   {adv_bits(Adv), minus_mask(Adv,Mask0,Mask1)},
   advs_opt(AdvArg,X,Mask1),
   obj_opt(Case,X,Mask0,Mask).

obj_opt(indO(ArgInfo),[arg(dirO(ArgInfo),NP)],_,Mask) ---> verb_arg(np,NP,Mask).
obj_opt(dirO(_ArgInfo),[],Mask,Mask) ---> noText.

pred_conj(Conj,Arg,Mask) --->
   pred(_,Arg0,Mask0),
   pred_rest(Conj,Arg0,Arg,Mask0,Mask).

pred_rest(Conj0,Arg0,Arg,_,Mask) --->
   conj(Conj0,Conj,Arg0,Arg1,Arg),
   pred_conj(Conj,Arg1,Mask).
pred_rest(_,Arg,Arg,Mask,Mask) ---> noText.

verb_arg(np,NP,Mask) --->
   {is_s_all(SAll), is_verb_case(VCase)},
   np(NP,_,VCase,_,compl,SAll,Mask).

pred(_,Adj,Mask) ---> adj_phrase(Adj,Mask).
pred(negP(_Modal),PP,Mask) --->
   {is_s_all(SAll)},
   xg_prep_phrase(_PPAlowed,PP,compl,SAll,Mask).
pred(_,Adv,Mask) --->
   {is_s_all(SAll)},
   adv_phrase(post,Adv,SAll,Mask).

advs_opt([Adv|R0],R,Set) --->
   {is_adv_bits(Set)},
   adverb(Adv),
   advs_opt(R0,R,Set).
advs_opt(R,R,_) ---> noText.

adj_phrase(P,Nil) ---> adj(_,P), { is_empty_bits(Nil) }.
adj_phrase(P,Mask) --->  comp_phrase(P,Mask).

adverb(adv(Adv)) ---> theText80_W2(W,W2), {adv_lex_w2(W,W2,Adv)}.
adverb(adj(Adj)) ---> {if_search_expanded(3)},theText80_W2(W,W2), {adj_lex_w2(W,W2,Adj,_Type)}.
adverb(adv(W)) ---> theText80(W), {adverb_lex(W)}.
adverb(adv(t(A,B,C))) ---> theText80(W), {modal_verb_form_aux(W,A,B,C)}.
   
no_args_vt(tv).
no_args_vt(dv(_Prep)).
no_args_vt(iv).

/* Conjunctions */

conj(conj(Conj,Ctx0),
     conj(Conj,Ctx),Left,Right,
     conj(Conj,Left,Right)) --->
   conj(Conj,Ctx0,Ctx).

%:-retract(tlxgproc:do_xg_process_te).

:-retract(t_l:disable_px).

/* @(#)clotab.pl	24.1 2/23/88 */

 
/* 
	Copyright 1986, Fernando C.N. Pereira and David H.D. Warren,

			   All Rights Reserved
*/
/*
 _________________________________________________________________________
|       Copyright (C) 1982                                                |
|                                                                         |
|       David Warren,                                                     |
|               SRI International, 333 Ravenswood Ave., Menlo Park,       |
|               California 94025, USA;                                    |
|                                                                         |
|       Fernando Pereira,                                                 |
|               Dept. of Architecture, University of Edinburgh,           |
|               20 Chambers St., Edinburgh EH1 1JZ, Scotland              |
|                                                                         |
|       This program may Be used, copied, altered or included in other    |
|       programs only for academic purposes and provided that the         |
|       authorship of the initial program is aknowledged.                 |
|       Use for commercial purposes without the previous written          |
|       agreement of the authors is forbidden.                            |
|_________________________________________________________________________|

*/
% Normal form masks

is_pp(#(1,_,_,_)).

is_pred(#(_,1,_,_)).

is_trace(#(_,_,1,_)).

is_adv_bits(#(_,_,_,1)).

is_trace82(#(_,_,1,_),#(0,0,0,0)).

is_trace_bits(#(0,0,1,0)).

adv_bits(#(0,0,0,1)).

is_empty_bits(#(0,0,0,0)).

is_np_all(#(1,1,1,0)).

is_s_all(#(1,0,1,1)).

is_np_no_trace(#(1,1,0,0)).

% Mask operations

plus_mask(#(B1,B2,B3,B4),#(C1,C2,C3,C4),#(D1,D2,D3,D4)) :-
   or_xmask(B1,C1,D1),
   or_xmask(B2,C2,D2),
   or_xmask(B3,C3,D3),
   or_xmask(B4,C4,D4).

minus_mask(#(B1,B2,B3,B4),#(C1,C2,C3,C4),#(D1,D2,D3,D4)) :-
   anot_xmask(B1,C1,D1),
   anot_xmask(B2,C2,D2),
   anot_xmask(B3,C3,D3),
   anot_xmask(B4,C4,D4).

or_xmask(1,_,1).
or_xmask(0,1,1).
or_xmask(0,0,0).

anot_xmask(X,0,X).
anot_xmask(_X,1,0).

% Noun phrase position features

is_to_role_case(subJ(_ArgInfo1),_,#(1,0,0)).
is_to_role_case(compl,_,#(0,_,_)).
is_to_role_case(undef,main,#(_,0,_)).
is_to_role_case(undef,aux,#(0,_,_)).
is_to_role_case(undef,decl,_).
is_to_role_case(nil,_,_).

is_any_case(#(_,_,_)).
is_subj_case(#(1,0,0)).
is_verb_case(#(0,1,0)).
is_prep_case(#(0,0,1)).
is_compl_case(#(0,_,_)).

:- op(100,fx,?).

user:portray(C):- notrace(fail), compound(C), \+ \+ (arg(_,C,E),nonvar(E)), portray_bits(C).
user:portray_bits('#'(PP,Pred,Trace,Adv)) :-
   portray_bit(prep_phrase,PP,S0,S1),
   portray_bit(pred,Pred,S1,S2),
   portray_bit(trace,Trace,S2,S3),
   portray_bit(adverb,Adv,S3,[]),
   write(S0).

portray_bit(Bit,Value,[?Bit|Bits],Bits) :- var(Value), !.
portray_bit(Bit,1,[+Bit|Bits],Bits).
portray_bit(Bit,0,[-Bit|Bits],Bits).
portray_bit(Bit,What,[Bit=What|Bits],Bits).
portray_bit(Bit,1,[Bit|Bits],Bits).
portray_bit(_Bit,0,Bits,Bits).
portray_bit(_,_,Bits,Bits).

end_of_file.
