reach(CurAgent, Init1Step, Positions, Paths, Winner):- 
  sublist(CurAgent,1, Positions, [XYs] ), 
  init(CurAgent, InitPos), InitPos=XYs,!, 
  initStep(Paths, Init1Step),
  Winner=CurAgent,
  mdraw(Paths). 

reach(CurAgent, NewStep12s, Positions, Paths, Winner):- 
  aritySlice(( sublist(CurAgent,1,Positions,[XYs] ) )),
  next_reach(CurAgent, XYs, ( Steps, Positions, Paths), Winner), 
  sublist(CurAgent, 1, Steps, [Step_] ),
  inc(Step_, Step),
  list_replace([Step], CurAgent, 1, Steps, NewStep12s).
  next_reach(CurAgent, XYsin, ( Step12s, Positions,Paths ), Winner ):-
  aritySlice(( sublist(CurAgent,1,Paths,[Path] ) )), 
  dir(CurAgent,XYsin, XYs),
  processConstraints(CurAgent, XYs, Path), 
  aritySlice(( append(Path, [XYs], NewPath) ,
  list_replace( [NewPath], CurAgent,1, Paths, Path12s),
 list_replace( [XYs], CurAgent,1, Positions, XY12s) )),
nextAg(CurAgent, NextAgent, Positions), 
reach(NextAgent, Step12s, XY12s, Path12s, Winner).
nextAg(CurAgent, NextAgent, Poss):- len(Poss, NAgents),
ifthenelse(CurAgent<NAgents-1, 
NextAgent is CurAgent+1, NextAgent is 0).

initStep(Paths, Init1Step):- % 10 agents max
len(Paths, NAgents), 
sublist(0, NAgents, [0,0,0,0,0,0,0,0,0,0], InitStep),
list_replace([1], NextAgent,1, InitStep, Init1Step).
qtyAgents(N):- findall(A, agent(A), As), len(As, N).
initPositions(Agent, AgentPos, Positions):- % 10 agents max
qtyAgents(NAgents),
sublist(0, NAgents, [(X0,Y0),(X1,Y1)], InitPoss),
list_replace([AgentPos], Agent,1, InitPoss, Positions).

:- op(300,xfx,(=\=)).

processConstraints(NextAgent, Positions, Path):-
 not member( Positions, Path), 
 not ( member(Coord, Positions), ((Coord<0) ; (Coord>9)) ), 
 not ( agent(AnyAgent), AnyAgent =\= NextAgent, 
 step(AnyAgent, Positions )),
 not wallMd(Positions), 
 asserta(step(NextAgent, Positions)). 

wallMd(Positions):- member(Proj,[1,2,3,4]), member(Proj, Positions). 
dir(Agent, XYsin, XYs):-member(Coord, [0,1,2,3,4,5,6,7,8,9]),
member(Delta, [-1, 1]), 
sublist(Coord,1, XYsin,[X] ),
X1 is X + Delta, 
list_replace([X1], Coord, 1, XYsin, XYs),
writeln(dir(Agent, XYsin, XYs)).
see(Agent1, Agent2) :- step(Agent1, Pos1), step(Agent2, Pos2),!,
not ( wall(X, Y), 
Thr is (abs(X-X1)/abs(Y-Y1)) /(abs(X-X2)/abs(Y-Y2)), 
Thr < 1.3, Thr > 0.7 ).

lock(Agent1, Agent2, (X, Y)) :- init,
 initPositions(Agent1, (X,Y), Positions1),
 reach(Agent1,_, Positions1,[[],[],[]], Agent1),!,
 initPositions(Agent2, (X,Y), Positions2),
 not reach(Agent2,_, Positions2,[[],[],[]], _).

mdraw(Paths) :- ifthen( (member(Path, Paths), member(Point, Path),
len(Point,2) ), not fail),
not (member(V, [0,1,2,3,4,5,6,7,8,9]), writeln(``),
member(U, [0,1,2,3,4,5,6,7,8,9]),
get(El, U, V), 
ifthen( ( step(Agent, [U, V]), write(Agent)),
ifthenelse(
( sublist(Agent,1,Paths,[AgentPass]),
member( [U,V], AgentPass ) ),
( write(`P`),fail),
( write(`V`),fail)
)
), 
ifthenelse( El=:= 0, write(` `),write(`##`)), 
fail ), writeln(``).

/* addition from MAZE.ari
mymaze([[0,0,1,0,0,0,0,0,1,0],
        [0,0,1,0,1,1,1,0,1,0],
        [0,1,1,0,0,1,0,0,1,0],
        [0,0,1,1,0,1,0,1,1,0],
        [0,1,0,0,0,1,0,0,0,0],
        [0,0,1,0,0,1,0,0,1,0],
        [1,0,1,1,0,1,0,1,1,0],
        [0,0,0,0,0,1,0,0,0,0],
        [0,1,0,0,0,0,0,0,1,0],
        [0,0,0,1,0,1,0,1,1,0],
        [1,0,1,0,0,1,0,0,0,0],
        [1,0,0,0,1,1,1,0,1,0] ]).

draw(Path) :- not 
              (member(V, [0,1,2,3,4,5,6,7,8,9]), writeln(``),
              member(U, [0,1,2,3,4,5,6,7,8,9]),
             get(El, U, V), 
	     ifthenelse( member((U,V),Path),
                write(*), write(El) ),
             fail ), writeln(``).
d:-draw(3,3),
 

mask( [ [A1,B1,C1,D1,E1,F1,G1,H1],
        [A2,B2,C2,D2,E2,F2,G2,H2],
        [A3,B3,C3,D3,E3,F3,G3,H3],
        [A4,B4,C4,D4,E4,F4,G4,H4],
        [A5,B5,C5,D5,E5,F5,G5,H5],
        [A6,B6,C6,D6,E6,F6,G6,H6] ]).

sign(Unit, To, Number) :- ifthen(var(Number), writeln(`var for sign`) ),
                      ifthen( ( To-Number<1), Unit is Number-1),  
                      ifthen( (To-Number>0), Unit is Number+1).
                     % ifthen( (To-Number =:= 0), Unit is Number), 
                     %                          writeln(sign(Unit, To, Number)).
             

get(El,X,Y) :- mymaze(Mymaze), sublist(Y,1,Mymaze, [Row]), %            writeln(Row),
               sublist(X, 1, Row, [El]).   

wall(X, Y):- get(1, X, Y).

stepped(1,X,Y):- mask(Mask), sublist(Y, 1, Mask, [Row]),
                             sublist(X, 1, Row, [A]), A=1.   

isStepped(X, Y):-  mask(Mask), sublist(Y,1,Mask, Row), sublist(X, 1, Row, [A]), A==1.   


init(9,9).
init:- abolish(step / 2),  init(A, B), assert(step(A, B)).
%init:- init(A, B), assert(step(A, B)).

reach(Step,X, Y, Path):- Step=1, init(A, B), A=:=X, B=:=Y,!. %writeln((`found:`, A, B, `Step=`, Step)), 
                       %  draw(Path).



% try:-init, reach(40 , 7,5,[]).
% try:-init, reach(Step , 7,0,[]), writeln(Step).
 try:-init, reach(Step , 9,9,[]), writeln(Step), fail.
chk:- not (name_clause(reach_next, _, Cl), writeln(Cl), fail).
ab:-rules(Rules),  list_abolish(Rules).



*/