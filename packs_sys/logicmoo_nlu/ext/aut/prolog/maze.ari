mymaze([[0,0,1,0,0,0,0,0,1,0],
        [0,0,1,0,1,1,1,0,1,0],
        [0,1,1,0,0,1,0,0,1,0],
        [0,0,1,1,0,1,0,1,1,0],
        [0,1,0,0,0,1,0,0,0,0],
        [0,0,1,0,0,1,0,0,1,0],
        [1,0,1,1,0,1,0,1,1,0],
        [0,0,0,0,0,1,0,0,0,0],
        [0,1,0,0,0,0,0,0,1,0],
        [0,0,0,1,0,1,0,1,1,0],
        [1,0,1,0,0,1,0,0,0,0],
        [1,0,0,0,1,1,1,0,1,0] ]).

draw(Path) :- not 
              (member(V, [0,1,2,3,4,5,6,7,8,9]), writeln($$),
              member(U, [0,1,2,3,4,5,6,7,8,9]),
             get(El, U, V), 
	     ifthenelse( member((U,V),Path),
                write(*), write(El) ),
             fail ), writeln($$).
d:-draw(3,3),
 

mask( [ [A1,B1,C1,D1,E1,F1,G1,H1],
        [A2,B2,C2,D2,E2,F2,G2,H2],
        [A3,B3,C3,D3,E3,F3,G3,H3],
        [A4,B4,C4,D4,E4,F4,G4,H4],
        [A5,B5,C5,D5,E5,F5,G5,H5],
        [A6,B6,C6,D6,E6,F6,G6,H6] ]).

sign(Unit, To, Number) :- ifthen(var(Number), writeln($var for sign$) ),
                      ifthen( ( To-Number<1), Unit is Number-1),  
                      ifthen( (To-Number>0), Unit is Number+1).
                     % ifthen( (To-Number =:= 0), Unit is Number), 
                     %                          writeln(sign(Unit, To, Number)).
             

get(El,X,Y) :- mymaze(Mymaze), sublist(Y,1,Mymaze, [Row]), %            writeln(Row),
               sublist(X, 1, Row, [El]).   

wall(X, Y):- get(1, X, Y).

stepped(1,X,Y):- mask(Mask), sublist(Y, 1, Mask, [Row]),
                             sublist(X, 1, Row, [A]), A=1.   

isStepped(X, Y):-  mask(Mask), sublist(Y,1,Mask, Row), sublist(X, 1, Row, [A]), A==1.   


init(9,9).
init:- abolish(step / 2),  init(A, B), assert(step(A, B)).
%init:- init(A, B), assert(step(A, B)).

reach(Step,X, Y, Path):- Step=1, init(A, B), A=:=X, B=:=Y,!. %writeln(($found:$, A, B, $Step=$, Step)), 
                       %  draw(Path).

reach(Step, X,Y,Path):- (X >=0) , (Y>=0) , (9>=X), (9>=Y),
                         not step(X, Y),
                         not wall(X, Y),  
                         assert(step(X, Y)),              
                                  %%     writeln(next_reach(X,Y,  Step1)),
                         next_reach(X,Y,  Step1, Path),   
                        
                         inc(Step1, Step).            
                               %writeln(($reached$, X, Y)). 

next_reach(X,Y,  Step1, Path):- %%write(3),
                   init(Xinit, Yinit),
                   sign(X1, Xinit,X), XX1 is X+X-X1, append(Path, [(XX1,Y)], Path3),
                   reach(Step1, XX1, Y, Path3).
next_reach(X,Y,  Step1, Path):- %%write(4),
                   init(Xinit, Yinit),
                   sign(Y1, Yinit,Y), YY1 is Y+Y-Y1, append(Path, [(X,YY1)], Path4),
                   reach(Step1, X, YY1, Path4).
next_reach(X,Y,  Step1, Path):- %%write(1),
                   init(Xinit, Yinit), 
	             sign(X1, Xinit,X), append(Path, [(X1,Y)], Path1),
                   reach(Step1, X1, Y, Path1 ).
next_reach(X,Y,  Step1, Path):- %%write(2),
                   init(Xinit, Yinit), 
                   sign(Y1, Yinit,Y), append(Path, [(X,Y1)], Path2),
                   reach(Step1, X, Y1, Path2).


rules([ (next_reach(X,Y,  Step1, Path):- %%write(3),
                   init(Xinit, Yinit),
                   sign(X1, Xinit,X), XX1 is X+X-X1, append(Path, [(XX1,Y)], Path3),
                   reach(Step1, XX1, Y, Path3)
),(next_reach(X,Y,  Step1, Path):- %%write(4),
                   init(Xinit, Yinit),
                   sign(Y1, Yinit,Y), YY1 is Y+Y-Y1, append(Path, [(X,YY1)], Path4),
                   reach(Step1, X, YY1, Path4)
),(next_reach(X,Y,  Step1, Path):- %%write(1),
                   init(Xinit, Yinit), 
	             sign(X1, Xinit,X), append(Path, [(X1,Y)], Path1),
                   reach(Step1, X1, Y, Path1 )
),(next_reach(X,Y,  Step1, Path):- %%write(2),
                   init(Xinit, Yinit), 
                   sign(Y1, Yinit,Y), append(Path, [(X,Y1)], Path2),
                   reach(Step1, X, Y1, Path2)
),(next_reach(X,Y,  Step1, Path):- %%write(5),
                   init(Xinit, Yinit), 
                   last(Path, (Xl,Yl)),
                   X1 is 2*X-Xl;  Y1 is 2*Y-Yl;
                   append(Path, [(X1,Y1)], Path5),
                   reach(Step1, X1, Y1, Path5)
  ) ]).


% try:-init, reach(40 , 7,5,[]).
% try:-init, reach(Step , 7,0,[]), writeln(Step).
 try:-init, reach(Step , 9,9,[]), writeln(Step), fail.
chk:- not (name_clause(reach_next, _, Cl), writeln(Cl), fail).
ab:-rules(Rules),  list_abolish(Rules).


%ar(A).
train:- 
   rules(Rules),            %sublist_assertz(Rules, [0,1]), writeln(Rules).

   findall( (Comb,Step), (
                           subcombination([0,1,2,3,4], Comb),        %write($======$),writeln(Combs), 
                           [! list_abolish(Rules) ,              % writeln($abol!$),
                           init,
                           sublist_assertz(Rules, Comb)       %writeln($before reach$)
                           !] ,
                          
                           reach(Step, 1,1, []),
                           findall(S, step(S,_), Ss), len(Ss, Step1)
                         ),     
         (CombsSteps)
       ),                    writeln( (CombsSteps)),

 

   findall(M, member( (_,M), (CombsSteps) ), ToSorts),
         [!
           quicksort(ToSorts, Sorteds),                writeln(Sorteds),

           sublist(0,1,Sorteds,[Max]),
           member((BestSeqs,Max),  (CombsSteps) ) !], writeln(BestSeqs),
           sublist_assertz(Rules, BestSeqs).
  

