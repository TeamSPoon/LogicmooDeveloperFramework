# Syntax of LPS

The current syntax of LPS uses a flexible mixture of explicit and implicit time. However, most of the top-level of an LPS “program” does not depend upon time and has the following,  mostly optional components.

### Comments						

```
% 	written either in this form
/* or in this form, which is convenient if they occupy several lines.
*/
```


### Declarations:					

```

maxTime(_).
fluents 		…  .	
events   	…  .
actions 	…  .	
```


### Inputs							  	

```

initially 	…  .	
observe  	…   .

```


### Reactive rules					

```

if …  then …  .
```


### Clauses								

```

… if …  .
… :- …  .
```


### Causal laws						

```

… initiates … if …  .
… terminates … if …  .
false …  .
```

## Declarations.


```
#!

maxTime(_).	
```

This is an optional declaration of the maximum number of states. If the declaration is not present, the maximum is currently set at 20 by default.


```
#!

fluents    fluent1, fluent2, …, fluentn.	% n >= 1
```


Fluents are time-dependent atomic sentences. Here they are specified by giving the name of the fluent followed by its arguments. For example, a two-argument fluent named location could be specified by any one of location/2, location(_,_),  or location(_object, _place), where _, _object, and _place are “anonymous variables”. 

Fluents can be “extensional” if they are represented by “facts” and updated by events or “intensional” if they are represented by clauses that mirror changes of the extensional fluents.


```
#!

events    event1, event2, … , eventn.	% n >= 1.
```

Events can be external, given by observations, or generated by the system. They can be “atomic”, taking place instantaneously from one state to the next, or “composite”, taking place over a series of zero or more states. For example, say/2, say(_,_) or say(_agent, _expression). 


```
#!

actions    action1, action2, …, actionn.	% n >= 1.
```

Actions are “atomic”, taking place instantaneously, and are generated by the system. They have the same syntax as events, and can also be declared as events, which may be external. 




Let us have fun documenting the syntax of LPS. Actually, we are working with two syntaxes for the time being. A higher level one, which follows and the lower level or Wei's syntax. Please, beware: 

* * *

## LPS Higher level syntax ##

Files have the .lps extension and (more or less) the following structure: 

```
#!Prolog

  spec ::= statement 
  statement ::= settings rules 
  settings ::= max_time actions fluents initial_state observations 
  rules ::= if_rules if_then_rules initiate_rules terminate_rules constraints 
  if_rules ::= if_rule | if_rule if_rules
  if_rule ::= literal "." | literal "if" conjunction "." 
  if_then_rules ::= if_then_rule | if_then_rule if_then_rules
  if_then_rule ::= "if" conjunction "then" conjunction "." 
  constraints ::= constraint | constraint constraints
  constraint ::= "false" conjunction "." 
  conjunction ::= "true" | literal | literal "," conjunction
  
```
where

### Observations

observed events can be written in any of the forms:

```
#!Prolog

   event from T1 to T2
   event from T1
   event to T2

```

* * *

## Wei's syntax ##
  
Files have the .lpsw extension and (more or less) the following structure: 

```
#!Prolog

  spec ::= statement 
  statement ::= settings rules 
  settings ::= max_time  actions  fluents  initial_state  observations  events
  rules ::= if_rules reactive_rules initiate_rules terminate_rules constraints 
  if_rules ::= if_rule | if_rule if_rules
  if_rule ::= timeless_rule | event_rule 
  timeless_rule ::= "l_timeless(" literal "," conjunction ")."
  event_rule ::= "l_events(" happens_literal "," hold_conjunction_list ")."
  reactive_rules ::= if_then_rule | if_then_rule if_then_rules
  if_then_rule ::=  "reactive_rule(" conjunction "," conjunction ")."
  constraints ::= constraint | constraint constraints
  constraint ::= "d_pre(" conjunction ")."
  conjunction ::= "true" | literal | literal "," conjunction
```