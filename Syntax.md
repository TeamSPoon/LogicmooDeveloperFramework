# Syntax of LPS

The current syntax of LPS uses a flexible mixture of explicit and implicit time. However, most of the top-level of an LPS “program” does not depend upon time and has the following,  mostly optional components.

### Comments						

```
% 	written either in this form
/* or in this form, which is convenient if they occupy several lines.
*/
```


### Declarations:					

```

maxTime(_).
fluents 		…  .	
events   	…  .
actions 	…  .	
```


### Inputs							  	

```

initially 	…  .	
observe  	…   .

```


### Reactive rules					

```

if …  then …  .
```


### Clauses								

```

… if …  .
… :- …  .
```


### Causal laws						

```

… initiates … if …  .
… terminates … if …  .
false …  .
```

## Declarations.


```
#!

maxTime(_).	
```

This is an optional declaration of the maximum number of states. If the declaration is not present, the maximum is currently set at 20 by default.


```
#!

fluents    fluent1, fluent2, …, fluentn.	% n >= 1
```


Fluents are time-dependent atomic sentences. Here they are specified by giving the name of the fluent followed by its arguments. For example, a two-argument fluent named location could be specified by any one of location/2, location(_,_),  or location(_object, _place), where _, _object, and _place are “anonymous variables”. 

Fluents can be “extensional” if they are represented by “facts” and updated by events or “intensional” if they are represented by clauses that mirror changes of the extensional fluents.


```
#!

events    event1, event2, … , eventn.	% n >= 1.
```

Events can be external, given by observations, or generated by the system. They can be “atomic”, taking place instantaneously from one state to the next, or “composite”, taking place over a series of zero or more states. For example, say/2, say(_,_) or say(_agent, _expression). 


```
#!

actions    action1, action2, …, actionn.	% n >= 1.
```

Actions are “atomic”, taking place instantaneously, and are generated by the system. They have the same syntax as events, and can also be declared as events, which may be external. 

## Inputs.


```
#!

initially   fluent1, fluent2, … , fluentn.	% n >= 1.
```

This specifies the extensional fluents that are true in the initial state at time 0.


```
#!

observe  event1, event2, … , eventn from time1 to time2.	% n >= 1.
```

time1 and time2 should be successive positive integers, e.g. from 2 to 3.  The program can have multiple observe statements with different times.

## Reactive rules.


```
#!

if literal1, … , literaln then literaln+1, … , literaln+m.	% n >= 1 and m >= 1.
```


Each literal is a timed or untimed atomic formula or the negation of an atomic formula. (See below.) Implicitly all times after then are later than or equal to the latest time before then. Also, no time after a comma is earlier than any time before the same comma.


## Clauses. 


```
#!

atomic formula if literal1, … , literaln.  	% n > 1.
```


```
#!

atomic formula.  				% n = 0.
```

These clauses are used to define:

1. 1) time-independent predicates, including temporal inequalities, e.g. philosopher(hume) and  T1 < T2.

1. 2) intensional predicates, which change as a consequence of changes to extensional predicates. For example (with explicit time) 

```
#!

location(Object, Place) at T if holding(Agent, Object) at T,  location(Agent, Place) at T. 
```

These can also be written without explicit time: 

```
#!

location(Object, Place) if holding(Agent, Object), location(Agent, Place).
```
 
1. 3) composite actions and events, which can take place over zero or more state transitions. For example (with explicit time):


```
#!

makeAt(Agent, Place) from T to T if location(Agent, Place) at T.
makeAt(Agent, Place) from T1 to T2 if not location(Agent, Place) at T1,
move(Agent, Place) from T1 to T2.
```

Those are clauses with if (with the implicit and explicit time advantages). Traditional clauses in Prolog are also allowed: 


```
#!prolog

atomic formula :- literal1, … , literaln.     	% n  0.
```

These clauses can be used to define time-independent predicates directly in Prolog.	For example, 

```
#!prolog

parent(X,Y) :- mother(X,Y) ; father(X,Y).
```

Causal laws

event initiates fluent if literal1, … , literaln.	% n  0.
	Here event is an external event or an atomic (non-composite) action.
	event, fluent and literals can all be written without explicit time. Implicitly, if the event takes place from T to T+1 then fluent is true at time T+1 and if all the literals are true at time T.
Do we allow the literals be events? I don’t think so.

event terminates fluent if literal1, … , literal. 	% n  0.
	Like initiates, implicitly, if the event takes place from T to T+1 then the fluent at time T is terminated. It is possible for a fluent to be initiated and terminated at the same time, but by different events, as for example, when a subscription runs out, but is renewed at the same time.

We should call this one Constraints.
false   literal1, literal2, … , literaln.   % n  1
	These are used to constrain candidate actions, say from T to T+1. So one of the literals must be an action. Other literals can be actions or external events that also occur from T to T+1. They can also be fluents that are true at time T. Because of these restrictions on time, these constraints can be written without explicit time.






Let us have fun documenting the syntax of LPS. Actually, we are working with two syntaxes for the time being. A higher level one, which follows and the lower level or Wei's syntax. Please, beware: 

* * *

## LPS Higher level syntax ##

Files have the .lps extension and (more or less) the following structure: 

```
#!Prolog

  spec ::= statement 
  statement ::= settings rules 
  settings ::= max_time actions fluents initial_state observations 
  rules ::= if_rules if_then_rules initiate_rules terminate_rules constraints 
  if_rules ::= if_rule | if_rule if_rules
  if_rule ::= literal "." | literal "if" conjunction "." 
  if_then_rules ::= if_then_rule | if_then_rule if_then_rules
  if_then_rule ::= "if" conjunction "then" conjunction "." 
  constraints ::= constraint | constraint constraints
  constraint ::= "false" conjunction "." 
  conjunction ::= "true" | literal | literal "," conjunction
  
```
where

### Observations

observed events can be written in any of the forms:

```
#!Prolog

   event from T1 to T2
   event from T1
   event to T2

```

* * *

## Wei's syntax ##
  
Files have the .lpsw extension and (more or less) the following structure: 

```
#!Prolog

  spec ::= statement 
  statement ::= settings rules 
  settings ::= max_time  actions  fluents  initial_state  observations  events
  rules ::= if_rules reactive_rules initiate_rules terminate_rules constraints 
  if_rules ::= if_rule | if_rule if_rules
  if_rule ::= timeless_rule | event_rule 
  timeless_rule ::= "l_timeless(" literal "," conjunction ")."
  event_rule ::= "l_events(" happens_literal "," hold_conjunction_list ")."
  reactive_rules ::= if_then_rule | if_then_rule if_then_rules
  if_then_rule ::=  "reactive_rule(" conjunction "," conjunction ")."
  constraints ::= constraint | constraint constraints
  constraint ::= "d_pre(" conjunction ")."
  conjunction ::= "true" | literal | literal "," conjunction
```