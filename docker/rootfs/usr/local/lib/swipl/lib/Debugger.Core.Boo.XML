<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Debugger.Core.Boo</name>
    </assembly>
    <members>
        <member name="T:Debugger.Eval">
            <summary>
            This class holds information about function evaluation.
            </summary>
        </member>
        <member name="P:Debugger.Eval.Result">
            <exception cref="T:Debugger.GetValueException">Evaluating...</exception>
        </member>
        <member name="M:Debugger.Eval.CreateCorEval(Debugger.Process)">
            <exception cref="T:Debugger.GetValueException">Can not evaluate because no thread is selected</exception>
        </member>
        <member name="M:Debugger.Eval.CreateEval(Debugger.Process,System.String,Debugger.Eval.EvalStarter)">
            <exception cref="T:Debugger.GetValueException">Can not evaluate in optimized code</exception>
        </member>
        <member name="M:Debugger.Eval.WaitForResult">
            <exception cref="T:Debugger.DebuggerException">Evaluation can not be stopped</exception>
            <exception cref="T:Debugger.GetValueException">Process exited</exception>
        </member>
        <member name="M:Debugger.Eval.InvokeMethod(Debugger.Process,System.Nullable{System.UInt32},System.Type,System.String,Debugger.Value,Debugger.Value[])">
            <summary> Synchronously calls a function and returns its return value </summary>
        </member>
        <member name="M:Debugger.Eval.InvokeMethod(Debugger.MetaData.MethodInfo,Debugger.Value,Debugger.Value[])">
            <summary> Synchronously calls a function and returns its return value </summary>
        </member>
        <member name="M:Debugger.Eval.MethodInvokeStarter(Debugger.Eval,Debugger.MetaData.MethodInfo,Debugger.Value,Debugger.Value[])">
            <exception cref="T:Debugger.GetValueException"><c>GetValueException</c>.</exception>
        </member>
        <member name="M:Debugger.Eval.CreateValue(Debugger.Process,System.Object)">
            <exception cref="T:Debugger.DebuggerException">Can not create string this way</exception>
        </member>
        <member name="M:Debugger.Module.GetDefinedTypes">
            <summary> Get all non-generic types defined in this module </summary>
        </member>
        <member name="M:Debugger.Module.GetNamesOfDefinedTypes">
            <summary> Get names of all generic and non-generic types defined in this module </summary>
        </member>
        <member name="M:Debugger.Module.LoadSymbols(System.String[])">
            <summary> Try to load the debugging symbols (.pdb) from the given path </summary>
        </member>
        <member name="M:Debugger.Module.ResetJustMyCodeStatus">
            <summary> Sets all code as being 'my code'.  The code will be gradually
            set to not-user-code as encountered acording to stepping options </summary>
        </member>
        <member name="M:Debugger.NDebugger.GetDebuggerVersion">
            <summary>
            Get the .NET version of the process that called this function
            </summary>
        </member>
        <member name="M:Debugger.NDebugger.GetProgramVersion(System.String)">
            <summary>
            Get the .NET version of a given program - eg. "v1.1.4322"
            </summary>
        </member>
        <member name="M:Debugger.NDebugger.InitDebugger(System.String)">
            <summary>
            Prepares the debugger
            </summary>
            <param name="debuggeeVersion">Version of the program to debug - eg. "v1.1.4322"
            If null, the version of the executing process will be used</param>
        </member>
        <member name="E:Debugger.NDebugger.DebuggerTraceMessage">
            <summary>
            Internal: Used to debug the debugger library.
            </summary>
        </member>
        <member name="M:Debugger.NDebugger.ReloadModuleSymbols">
            <summary> Try to load module symbols using the search path defined in the options </summary>
        </member>
        <member name="M:Debugger.NDebugger.ResetJustMyCodeStatus">
            <summary> Reset the just my code status of modules.  Use this after changing any stepping options. </summary>
        </member>
        <member name="P:Debugger.Process.PauseSession">
            <summary>
            Indentification of the current debugger session. This value changes whenever debugger is continued
            </summary>
        </member>
        <member name="P:Debugger.Process.DebuggeeState">
            <summary>
            Indentification of the state of the debugee. This value changes whenever the state of the debugee significatntly changes
            </summary>
        </member>
        <member name="M:Debugger.Process.NotifyPaused(Debugger.PausedReason)">
            <summary> Puts the process into a paused state </summary>
        </member>
        <member name="M:Debugger.Process.NotifyResumed(Debugger.DebuggeeStateAction)">
            <summary> Puts the process into a resumed state </summary>
        </member>
        <member name="M:Debugger.Process.RaisePausedEvents">
            <summary> Sets up the eviroment and raises user events </summary>
        </member>
        <member name="M:Debugger.Process.Terminate">
            <summary> Terminates the execution of the process </summary>
        </member>
        <member name="M:Debugger.Process.AsyncTerminate">
            <summary> Terminates the execution of the process </summary>
        </member>
        <member name="M:Debugger.Process.WaitForPause">
            <summary>
            Waits until the debugger pauses unless it is already paused.
            Use PausedReason to find out why it paused.
            </summary>
        </member>
        <member name="M:Debugger.Process.WaitForExit">
            <summary>
            Waits until the precesses exits.
            </summary>
        </member>
        <member name="E:Debugger.Process.LogMessage">
            <summary>
            Fired when System.Diagnostics.Trace.WriteLine() is called in debuged process
            </summary>
        </member>
        <member name="M:Debugger.Process.ReadMemory(System.UInt64,System.Int32)">
            <summary> Read the specified amount of memory at the given memory address </summary>
            <returns> The content of the memory.  The amount of the read memory may be less then requested. </returns>
        </member>
        <member name="M:Debugger.Process.WriteMemory(System.UInt64,System.Byte[])">
            <summary> Writes the given buffer at the specified memory address </summary>
            <returns> The number of bytes written </returns>
        </member>
        <member name="T:Debugger.StackFrame">
            <summary>
            A stack frame which is being executed on some thread.
            Use to obtain arguments or local variables.
            </summary>
        </member>
        <member name="P:Debugger.StackFrame.Process">
            <summary> The process in which this stack frame is executed </summary>
        </member>
        <member name="P:Debugger.StackFrame.MethodInfo">
            <summary> Get the method which this stack frame is executing </summary>
        </member>
        <member name="P:Debugger.StackFrame.Thread">
            <summary> A thread in which the stack frame is executed </summary>
        </member>
        <member name="P:Debugger.StackFrame.ChainIndex">
            <summary> Internal index of the stack chain.  The value is increasing with age. </summary>
        </member>
        <member name="P:Debugger.StackFrame.FrameIndex">
            <summary> Internal index of the stack frame.  The value is increasing with age. </summary>
        </member>
        <member name="P:Debugger.StackFrame.HasSymbols">
            <summary> True if the stack frame has symbols defined. 
            (That is has accesss to the .pdb file) </summary>
        </member>
        <member name="P:Debugger.StackFrame.IsInvalid">
            <summary> Returns true is this incance can not be used any more. </summary>
        </member>
        <member name="M:Debugger.StackFrame.ToString">
            <summary> Returns diagnostic description of the frame </summary>
        </member>
        <member name="M:Debugger.StackFrame.StepInto">
            <summary> Step into next instruction </summary>
        </member>
        <member name="M:Debugger.StackFrame.StepOver">
            <summary> Step over next instruction </summary>
        </member>
        <member name="M:Debugger.StackFrame.StepOut">
            <summary> Step out of the stack frame </summary>
        </member>
        <member name="M:Debugger.StackFrame.AsyncStepInto">
            <summary> Step into next instruction </summary>
        </member>
        <member name="M:Debugger.StackFrame.AsyncStepOver">
            <summary> Step over next instruction </summary>
        </member>
        <member name="M:Debugger.StackFrame.AsyncStepOut">
            <summary> Step out of the stack frame </summary>
        </member>
        <member name="P:Debugger.StackFrame.NextStatement">
            <summary>
            Get the information about the next statement to be executed.
            
            Returns null on error.
            </summary>
        </member>
        <member name="M:Debugger.StackFrame.CanSetIP(System.String,System.Int32,System.Int32)">
            <summary>
            Determine whether the instrustion pointer can be set to given location
            </summary>
            <returns> Best possible location. Null is not possible. </returns>
        </member>
        <member name="M:Debugger.StackFrame.SetIP(System.String,System.Int32,System.Int32)">
            <summary>
            Set the instrustion pointer to given location
            </summary>
            <returns> Best possible location. Null is not possible. </returns>
        </member>
        <member name="M:Debugger.StackFrame.GetThisValue">
            <summary> 
            Gets the instance of the class asociated with the current frame.
            That is, 'this' in C#.
            </summary>
        </member>
        <member name="P:Debugger.StackFrame.ArgumentCount">
            <summary> Total number of arguments (excluding implicit 'this' argument) </summary>
        </member>
        <member name="M:Debugger.StackFrame.GetArgumentValue(System.Int32)">
            <summary> Gets argument with a given index </summary>
            <param name="index"> Zero-based index </param>
        </member>
        <member name="M:Debugger.StackFrame.GetArgumentValue(System.String)">
            <summary> Gets argument with a given name </summary>
            <returns> Null if not found </returns>
        </member>
        <member name="M:Debugger.StackFrame.GetArgumentValues">
            <summary> Gets all arguments of the stack frame. </summary>
        </member>
        <member name="M:Debugger.StackFrame.GetLocalVariableValue(Debugger.Wrappers.CorSym.ISymUnmanagedVariable)">
            <summary> Returns value of give local variable </summary>
        </member>
        <member name="M:Debugger.StackFrame.GetLocalVariableValue(System.String)">
            <summary> Get local variable with given name </summary>
            <returns> Null if not found </returns>
        </member>
        <member name="M:Debugger.StackFrame.GetLocalVariableValues">
            <summary> Returns all local variables of the stack frame. </summary>
        </member>
        <member name="P:Debugger.Thread.IsInValidState">
            <summary> From time to time the thread may be in invalid state. </summary>
        </member>
        <member name="P:Debugger.Thread.IsAtSafePoint">
            <summary> If the thread is not at safe point, it is not posible to evaluate
            on it </summary>
            <remarks> Returns false if the thread is in invalid state </remarks>
        </member>
        <member name="P:Debugger.Thread.Suspended">
            <remarks> Returns false if the thread is in invalid state </remarks>
        </member>
        <member name="P:Debugger.Thread.Priority">
            <remarks> Returns Normal if the thread is in invalid state </remarks>
        </member>
        <member name="P:Debugger.Thread.RuntimeValue">
            <summary> Returns value representing the System.Threading.Thread object </summary>
            <remarks> The value is null while the thread is being created (the CreateThread callback) and
            it may stay null during the run of the program. (probaly until the debuggee accesses
            the System.Threading.Thread object which forces the creation)</remarks>
        </member>
        <member name="P:Debugger.Thread.Name">
            <remarks> Returns empty string if the thread is in invalid state </remarks>
        </member>
        <member name="M:Debugger.Thread.InterceptCurrentException">
            <summary> Tryies to intercept the current exception.
            The intercepted expression stays available through the CurrentException property. </summary>
            <returns> False, if the exception was already intercepted or 
            if it can not be intercepted. </returns>
        </member>
        <member name="M:Debugger.Thread.GetCallstack">
            <summary> Gets the whole callstack of the Thread. </summary>
            <remarks> If the thread is in invalid state returns empty array </remarks>
        </member>
        <member name="M:Debugger.Thread.GetCallstack(System.Int32)">
            <summary> Get given number of frames from the callstack </summary>
        </member>
        <member name="P:Debugger.Thread.MostRecentStackFrame">
            <summary>
            Returns the most recent stack frame (the one that is currently executing).
            Returns null if callstack is empty.
            </summary>
        </member>
        <member name="P:Debugger.Thread.OldestStackFrame">
            <summary>
            Returns the first stack frame that was called on thread
            </summary>
        </member>
        <member name="M:Debugger.Breakpoint.Remove">
            <summary> Remove this breakpoint </summary>
        </member>
        <member name="T:Debugger.DebuggeeState">
            <summary>
            Represents span of time in which the debugger state is assumed to
            be unchanged.
            </summary>
            <remarks>
            For example, although property evaluation can in theory change
            any memory, it is assumed that they behave 'correctly' and thus
            property evaluation does not change debugger state.
            </remarks>
        </member>
        <member name="T:Debugger.DebuggerException">
            <summary>
            Type of exception thrown by the Debugger.
            </summary>
        </member>
        <member name="T:Debugger.ProcessExitedException">
            <summary>
            An exception that is thrown when the debugged process unexpectedly exits.
            </summary>
        </member>
        <member name="P:Debugger.ProcessExitedException.ProcessName">
            <summary>
            The name of the process that has exited.
            </summary>
        </member>
        <member name="M:Debugger.ProcessExitedException.#ctor">
            <summary>
            Creates a ProcessExitedException for an unnamed process.
            </summary>
        </member>
        <member name="M:Debugger.ProcessExitedException.#ctor(System.String)">
            <summary>
            Creates a ProcessExitedException for a process.
            </summary>
            <param name="processName">The name of the process</param>
        </member>
        <member name="T:Debugger.DebuggerObject">
            <summary>
            A base class for all classes declared by the debugger
            </summary>
        </member>
        <member name="T:Debugger.Exception">
            <summary> This convenience class provides access to an exception within the debugee. </summary>
            <seealso cref="T:System.Exception" />
        </member>
        <member name="P:Debugger.Exception.Type">
            <summary> The <c>GetType().FullName</c> of the exception. </summary>
            <seealso cref="T:System.Exception" />
        </member>
        <member name="P:Debugger.Exception.Message">
            <summary> The <c>Message</c> property of the exception. </summary>
            <seealso cref="T:System.Exception" />
        </member>
        <member name="P:Debugger.Exception.InnerException">
            <summary> The <c>InnerException</c> property of the exception. </summary>
            <seealso cref="T:System.Exception" />
        </member>
        <member name="M:Debugger.Exception.GetStackTrace(System.String)">
            <summary> Returs formated stacktrace for the exception </summary>
            <exception cref="T:Debugger.GetValueException"> Getting the stacktrace involves property
            evaluation so GetValueException can be thrown in some cicumstances. </exception>
        </member>
        <member name="T:Debugger.PauseSession">
            <summary>
            Holds information about the state of paused debugger.
            Expires when when Continue is called on debugger.
            </summary>
        </member>
        <member name="M:Debugger.SourcecodeSegment.Resolve(Debugger.Module,Debugger.Wrappers.CorDebug.ICorDebugFunction,System.UInt32)">
            <summary>
            'ILStart &lt;= ILOffset &lt;= ILEnd' and this range includes at least
            the returned area of source code. (May incude some extra compiler generated IL too)
            </summary>
        </member>
        <member name="T:Debugger.Expressions.ArrayIndexerExpression">
            <summary>
            Indexer to an element of an array.
            </summary>
        </member>
        <member name="T:Debugger.Expressions.CurrentExceptionExpression">
            <summary>
            An expression which returns the current exception on the thread
            </summary>
        </member>
        <member name="T:Debugger.Expressions.DereferenceExpression">
            <summary>
            A placeholder expression which can not be evaluated.
            </summary>
        </member>
        <member name="T:Debugger.Expressions.EmptyExpression">
            <summary>
            A placeholder expression which can not be evaluated.
            </summary>
        </member>
        <member name="T:Debugger.Expressions.LocalVariableIdentifierExpression">
            <summary>
            Identifier of a local variable within a given method.
            </summary>
        </member>
        <member name="T:Debugger.Expressions.MemberReferenceExpression">
            <summary>
            Reference to a member of a class.
            Can be field, property or a method.
            </summary>
        </member>
        <member name="T:Debugger.Expressions.ParameterIdentifierExpression">
            <summary>
            Identifier of a parameter within a givne method.
            </summary>
        </member>
        <member name="T:Debugger.Expressions.PrimitiveExpression">
            <summary>
            Literal expression
            </summary>
        </member>
        <member name="T:Debugger.Expressions.ThisReferenceExpression">
            <summary>
            'this' reference of a non-static method.
            </summary>
        </member>
        <member name="T:Debugger.Expressions.Expression">
            <summary>
            Represents a piece of code that can be evaluated.
            For example "a[15] + 15".
            </summary>
        </member>
        <member name="T:Debugger.ManagedCallback">
            <summary>
            Handles all callbacks of a given process
            </summary>
        </member>
        <member name="M:Debugger.ManagedCallback.MDANotification(Debugger.Wrappers.CorDebug.ICorDebugController,Debugger.Wrappers.CorDebug.ICorDebugThread,Debugger.Wrappers.CorDebug.ICorDebugMDA)">
            <exception cref="M:Debugger.ManagedCallback.Exception(Debugger.Wrappers.CorDebug.ICorDebugAppDomain,Debugger.Wrappers.CorDebug.ICorDebugThread,System.Int32)">Unknown callback argument</exception>
        </member>
        <member name="T:Debugger.ManagedCallbackProxy">
            <summary>
            This proxy marshals the callback to the appropriate thread
            </summary>
        </member>
        <member name="T:Debugger.ManagedCallbackSwitch">
            <summary>
            This class forwards the callback the the approprite process
            </summary>
        </member>
        <member name="M:Debugger.Interop.MTA2STA.WaitForCall">
            <summary>
            Wait until a call a made
            </summary>
        </member>
        <member name="M:Debugger.Interop.MTA2STA.PerformAllCalls">
            <summary>
            Performs all waiting calls on the current thread
            </summary>
        </member>
        <member name="M:Debugger.Interop.MTA2STA.PerformCall">
            <summary>
            Performs all waiting calls on the current thread
            </summary>
        </member>
        <member name="M:Debugger.Interop.MTA2STA.SoftWait(System.Threading.WaitHandle[])">
            <summary>
            SoftWait waits for any of the given WaitHandles and allows processing of calls during the wait
            </summary>
        </member>
        <member name="M:Debugger.Interop.MTA2STA.AsyncCall(System.Windows.Forms.MethodInvoker)">
            <summary>
            Schedules invocation of method and returns immediately
            </summary>
        </member>
        <member name="M:Debugger.Interop.MTA2STA.InvokeMethod(System.Object,System.String,System.Object[])">
            <summary>
            Uses reflection to call method. Automaticaly marshals parameters.
            </summary>
            <param name="targetObject">Targed object which contains the method. In case of static mehod pass the Type</param>
            <param name="functionName">The name of the function to call</param>
            <param name="functionParameters">Parameters which should be send to the function. Parameters will be marshaled to proper type.</param>
            <returns>Return value of the called function</returns>
        </member>
        <member name="T:Debugger.Wrappers.MetaData.MetaDataImport">
            <summary>Wrapper for the unmanaged metadata API.</summary>
            <remarks>http://msdn.microsoft.com/en-us/library/ms230172.aspx</remarks>
        </member>
        <member name="M:Debugger.Wrappers.MetaData.MetaDataImport.EnumInterfaceImpls(System.UInt32)">
            <returns>MethodDef tokens</returns>
        </member>
        <member name="M:Debugger.Wrappers.MetaData.MetaDataImport.EnumMethodImpls(System.UInt32)">
            <returns>MethodBody and MethodDeclaration tokens</returns>
        </member>
        <member name="M:Debugger.Wrappers.MetaData.MetaDataImport.EnumMethodSemantics(System.UInt32)">
            <returns>Events or properties</returns>
        </member>
        <member name="T:Debugger.MetaData.BindingFlags">
            <summary>
            Binding flags specify which members should be returned.
            <para> Use 'or' operation to combine flags. </para>
            </summary>
        </member>
        <member name="F:Debugger.MetaData.BindingFlags.All">
            Return all members
        </member>
        <member name="T:Debugger.MetaData.DebugType">
            <summary>
            Represents a type in a debugee. That is, a class, array, value type or a primitive type.
            This class mimics the <see cref="T:System.Type"/> class.
            </summary>
            <remarks>
            If two types are identical, the references to DebugType will also be identical 
            Type will be loaded once per each appdomain.
            </remarks>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetMembers">
            <summary> Return all public members.</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetMembers(System.String)">
            <summary> Return all members with the given name.</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetMembers(System.String,Debugger.MetaData.BindingFlags)">
            <summary> Return all members satisfing binding flags.</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetMembers(Debugger.MetaData.BindingFlags)">
            <summary> Return all members satisfing binding flags.</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetMember(System.String)">
            <summary> Return first member with the given name</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetMember(System.String,Debugger.MetaData.BindingFlags)">
            <summary> Return first member with the given name</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetMember(System.UInt32)">
            <summary> Return first member with the given token</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetFields">
            <summary> Return all public fields.</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetFields(Debugger.MetaData.BindingFlags)">
            <summary> Return all fields satisfing binding flags.</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetField(System.String)">
            <summary> Return first field with the given name</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetFields(System.String)">
            <summary> Return fields with the given name</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetField(System.UInt32)">
            <summary> Return first field with the given token</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetMethods">
            <summary> Return all public methods.</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetMethods(Debugger.MetaData.BindingFlags)">
            <summary> Return all methods satisfing binding flags.</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetMethod(System.String)">
            <summary> Return first method with the given name</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetMethods(System.String)">
            <summary> Return methods with the given name</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetMethod(System.UInt32)">
            <summary> Return first method with the given token</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetProperties">
            <summary> Return all public properties.</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetProperties(Debugger.MetaData.BindingFlags)">
            <summary> Return all properties satisfing binding flags.</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetProperty(System.String)">
            <summary> Return first property with the given name</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetProperties(System.String)">
            <summary> Return propertyies with the given name</summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetProperty(System.UInt32)">
            <summary> Return first property with the given token</summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.PrimitiveType">
            <summary> Returns simple managed type coresponding to the primitive type. </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.Process">
            <summary> Gets the process in which the type was loaded </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.Module">
            <summary>
            Gets the module in which the class or value type is defined.
            <para> Only applicable to class or value type! </para>
            </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.Token">
            <summary>
            Gets the metadata token of the class or value type.
            <para> Only applicable to class or value type! </para>
            </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.Name">
            <summary> Gets the name of the type excluding the namespace </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.FullName">
            <summary> Returns a string describing the type including the namespace
            and generic arguments but excluding the assembly name. </summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetArrayRank">
            <summary> Returns the number of dimensions of an array </summary>
            <remarks> Throws <see cref="T:System.ArgumentException"/> if type is not array </remarks>
        </member>
        <member name="P:Debugger.MetaData.DebugType.Interfaces">
            <summary> Gets a list of all interfaces that this type implements </summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetInterface(System.String)">
            <summary> Return an interface with the given name </summary>
            <returns> Null if not found </returns>
        </member>
        <member name="P:Debugger.MetaData.DebugType.ElementType">
            <summary> Get an element type for array or pointer. </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.GenericArguments">
            <summary> Gets generics arguments for a type or an emtpy array for non-generic types. </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.Kind">
            <summary> Returns what kind of type this is. (eg. value type) </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.IsArray">
            <summary> Gets a value indicating whether the type is an array </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.IsClass">
            <summary> Gets a value indicating whether the type is a class </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.IsInterface">
            <summary> Returns true if this type represents interface </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.IsValueType">
            <summary> Gets a value indicating whether the type is a value type (that is, a structre in C#).
            Return false, if the type is a primitive type. </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.IsPrimitive">
            <summary> Gets a value indicating whether the type is a primitive type </summary>
            <remarks> Primitive types are: boolean, char, string and all numeric types </remarks>
        </member>
        <member name="P:Debugger.MetaData.DebugType.IsInteger">
            <summary> Gets a value indicating whether the type is an integer type </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.IsString">
            <summary> Gets a value indicating whether the type is an string </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.IsPointer">
            <summary> Gets a value indicating whether the type is an managed or unmanaged pointer </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.IsVoid">
            <summary> Gets a value indicating whether the type is the void type </summary>
        </member>
        <member name="P:Debugger.MetaData.DebugType.BaseType">
            <summary>
            Gets the type from which this type inherits. 
            <para>
            Returns null if the current type is <see cref="T:System.Object"/>.
            </para>
            </summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.Create(Debugger.Process,Debugger.Wrappers.CorDebug.ICorDebugType)">
            <summary> Obtains instance of DebugType. Same types will return identical instance. </summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetDefinedTypesInModule(Debugger.Module)">
            <summary> Returns all non-generic types defined in the given module </summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.IsSubclassOf(Debugger.MetaData.DebugType)">
            <summary> Determines whether the current type is sublass of 
            the the given type. That is, it derives from the given type. </summary>
            <remarks> Returns false if the given type is same as the current type </remarks>
        </member>
        <member name="M:Debugger.MetaData.DebugType.IsInstanceOfType(Debugger.Value)">
            <summary> Determines whether the given object is instance of the
            current type or can be implicitly cast to it </summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.HasMembers(Debugger.MetaData.BindingFlags)">
            <summary> Return whether the type has any members stisfing the given flags </summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.Equals(System.Object)">
            <summary> Compares two types </summary>
        </member>
        <member name="M:Debugger.MetaData.DebugType.GetHashCode">
            <summary> Get hash code of the object </summary>
        </member>
        <member name="T:Debugger.MetaData.FieldInfo">
            <summary>
            Provides information about a field of some class.
            </summary>
        </member>
        <member name="P:Debugger.MetaData.FieldInfo.IsLiteral">
            <summary> Gets a value indicating whether this field is literal field </summary>
        </member>
        <member name="P:Debugger.MetaData.FieldInfo.IsPrivate">
            <summary> Gets a value indicating whether this member has the private access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.FieldInfo.IsInternal">
            <summary> Gets a value indicating whether this member has the internal access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.FieldInfo.IsProtected">
            <summary> Gets a value indicating whether this member has the protected access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.FieldInfo.IsPublic">
            <summary> Gets a value indicating whether this member has the public access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.FieldInfo.IsStatic">
            <summary> Gets a value indicating whether this field is static </summary>
        </member>
        <member name="P:Debugger.MetaData.FieldInfo.MetadataToken">
            <summary> Gets the metadata token associated with this field </summary>
        </member>
        <member name="P:Debugger.MetaData.FieldInfo.Name">
            <summary> Gets the name of this field </summary>
        </member>
        <member name="T:Debugger.MetaData.MemberInfo">
            <summary>
            Provides information about a member of some class
            (eg. a field or a method).
            </summary>
        </member>
        <member name="P:Debugger.MetaData.MemberInfo.Process">
            <summary> Gets the process in which the type was loaded </summary>
        </member>
        <member name="P:Debugger.MetaData.MemberInfo.Name">
            <summary> Gets the name of this member </summary>
        </member>
        <member name="P:Debugger.MetaData.MemberInfo.FullName">
            <summary> Gets name of the method including the full name of the declaring type </summary>
        </member>
        <member name="P:Debugger.MetaData.MemberInfo.Module">
            <summary> Gets the module in which this member is defined </summary>
        </member>
        <member name="P:Debugger.MetaData.MemberInfo.DeclaringType">
            <summary> Gets the type that declares this member element </summary>
        </member>
        <member name="P:Debugger.MetaData.MemberInfo.IsPrivate">
            <summary> Gets a value indicating whether this member has the private access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.MemberInfo.IsInternal">
            <summary> Gets a value indicating whether this member has the internal access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.MemberInfo.IsProtected">
            <summary> Gets a value indicating whether this member has the protected access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.MemberInfo.IsPublic">
            <summary> Gets a value indicating whether this member has the public access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.MemberInfo.IsStatic">
            <summary> Gets a value indicating whether this member is static </summary>
        </member>
        <member name="P:Debugger.MetaData.MemberInfo.MetadataToken">
            <summary> Gets the metadata token associated with this member </summary>
        </member>
        <member name="T:Debugger.MetaData.MethodInfo">
            <summary>
            Provides information about a method in a class
            </summary>
        </member>
        <member name="P:Debugger.MetaData.MethodInfo.Name">
            <summary> Gets the name of this method </summary>
        </member>
        <member name="P:Debugger.MetaData.MethodInfo.IsPrivate">
            <summary> Gets a value indicating whether this member has the private access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.MethodInfo.IsInternal">
            <summary> Gets a value indicating whether this member has the internal access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.MethodInfo.IsProtected">
            <summary> Gets a value indicating whether this member has the protected access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.MethodInfo.IsPublic">
            <summary> Gets a value indicating whether this member has the public access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.MethodInfo.IsSpecialName">
            <summary> Gets a value indicating whether the name of this method
            is marked as specail.</summary>
            <remarks> For example, property accessors are marked as special </remarks>
        </member>
        <member name="P:Debugger.MetaData.MethodInfo.IsStatic">
            <summary> Gets a value indicating whether this method is static </summary>
        </member>
        <member name="P:Debugger.MetaData.MethodInfo.MetadataToken">
            <summary> Gets the metadata token associated with this method </summary>
        </member>
        <member name="P:Debugger.MetaData.MethodInfo.StepOver">
            <summary> Gets value indicating whether this method should be stepped over
            accoring to current options </summary>
        </member>
        <member name="M:Debugger.MetaData.MethodInfo.GetFromName(Debugger.Process,System.Nullable{System.UInt32},System.Type,System.String,System.Int32)">
            <summary>
            Get a method from a managed type, method name and argument count
            </summary>
        </member>
        <member name="P:Debugger.MetaData.MethodInfo.ParameterCount">
            <summary> Gets the number of paramters of this method </summary>
        </member>
        <member name="M:Debugger.MetaData.MethodInfo.GetParameterName(System.Int32)">
            <summary> Gets the name of given parameter </summary>
            <param name="index"> Zero-based index </param>
        </member>
        <member name="M:Debugger.MetaData.MethodInfo.GetParameterNames">
            <summary> Get names of all parameters in order </summary>
        </member>
        <member name="M:Debugger.MetaData.MethodInfo.GetExpressionForThis">
            <summary> Returns expression for 'this' value of the stack frame </summary>
        </member>
        <member name="M:Debugger.MetaData.MethodInfo.GetExpressionForParameter(System.Int32)">
            <summary> Returns expression for argument with the given index </summary>
        </member>
        <member name="M:Debugger.MetaData.MethodInfo.GetExpressionForParameter(System.String)">
            <summary> Returns expression for argument with the given name </summary>
        </member>
        <member name="M:Debugger.MetaData.MethodInfo.GetExpressionsForParameters">
            <summary> Returns expressions for all arguments of this stack frame </summary>
        </member>
        <member name="M:Debugger.MetaData.MethodInfo.GetExpressionForLocalVariable(Debugger.Wrappers.CorSym.ISymUnmanagedVariable)">
            <summary> Returns expression for the given local variable </summary>
        </member>
        <member name="M:Debugger.MetaData.MethodInfo.GetExpressionForLocalVariable(System.String)">
            <summary> Returns expression for local variable with the given name </summary>
            <returns> Null if not found </returns>
        </member>
        <member name="M:Debugger.MetaData.MethodInfo.GetExpressionsForLocalVariables">
            <summary> Returns expressions for all local variables </summary>
        </member>
        <member name="M:Debugger.MetaData.MethodInfo.GetExpressionsForAllVariables">
            <summary> Returns a combined collection of all variables in this stack frame </summary>
        </member>
        <member name="T:Debugger.MetaData.PropertyInfo">
            <summary>
            Provides information about a property in a class
            </summary>
        </member>
        <member name="P:Debugger.MetaData.PropertyInfo.IsPrivate">
            <summary> Gets a value indicating whether this member has the private access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.PropertyInfo.IsInternal">
            <summary> Gets a value indicating whether this member has the internal access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.PropertyInfo.IsProtected">
            <summary> Gets a value indicating whether this member has the protected access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.PropertyInfo.IsPublic">
            <summary> Gets a value indicating whether this member has the public access modifier</summary>
        </member>
        <member name="P:Debugger.MetaData.PropertyInfo.IsStatic">
            <summary> Gets a value indicating whether this property is static </summary>
        </member>
        <member name="P:Debugger.MetaData.PropertyInfo.MetadataToken">
            <summary> Gets the metadata token associated with getter (or setter)
            of this property </summary>
        </member>
        <member name="P:Debugger.MetaData.PropertyInfo.Name">
            <summary> Gets the name of this property </summary>
        </member>
        <member name="P:Debugger.MetaData.PropertyInfo.GetMethod">
            <summary> Get the get accessor of the property </summary>
        </member>
        <member name="P:Debugger.MetaData.PropertyInfo.SetMethod">
            <summary> Get the set accessor of the property </summary>
        </member>
        <member name="T:Debugger.Util.HighPrecisionTimer">
            <summary>
            HighPrecisionTimer can obtain much more accurate time measurement
            for performace optimization
            </summary>
        </member>
        <member name="T:Debugger.ArrayDimension">
            <summary>
            Specifies the range of valid indicies for an array dimension
            </summary>
        </member>
        <member name="P:Debugger.ArrayDimension.LowerBound">
            <summary> The smallest valid index in this dimension </summary>
        </member>
        <member name="P:Debugger.ArrayDimension.UpperBound">
            <summary> The largest valid index in this dimension.  
            Returns LowerBound - 1 if the array is empty. </summary>
        </member>
        <member name="P:Debugger.ArrayDimension.Count">
            <summary> The number of valid indicies of this dimension </summary>
        </member>
        <member name="M:Debugger.ArrayDimension.IsIndexValid(System.Int32)">
            <summary> Determines whether the given index is a valid index for this dimension </summary>
        </member>
        <member name="T:Debugger.ArrayDimensions">
            <summary>
            Specifies the range of valid indicies for all array dimensions
            </summary>
        </member>
        <member name="P:Debugger.ArrayDimensions.Item(System.Int32)">
            <summary> Gets a given dimension </summary>
        </member>
        <member name="P:Debugger.ArrayDimensions.Count">
            <summary> Get the number of dimensions of the array </summary>
        </member>
        <member name="P:Debugger.ArrayDimensions.TotalElementCount">
            <summary> Get the total number of elements within the bounds
            of an array specified by these dimensions. </summary>
        </member>
        <member name="P:Debugger.ArrayDimensions.Indices">
            <summary> Enumerate all vaild indicies in the array </summary>
        </member>
        <member name="M:Debugger.ArrayDimensions.IsIndexValid(System.Int32[])">
            <summary> Determines whether the given index is a valid index for the array </summary>
        </member>
        <member name="T:Debugger.Value">
            <summary>
            Value class provides functions to examine value in the debuggee.
            It has very life-time.  In general, value dies whenever debugger is
            resumed (this includes method invocation and property evaluation).
            You can use Expressions to reobtain the value.
            </summary>
        </member>
        <member name="P:Debugger.Value.ArrayLength">
            <summary>
            Gets the number of elements in the array.
            eg new object[4,5] returns 20
            </summary>
        </member>
        <member name="P:Debugger.Value.ArrayRank">
            <summary>
            Gets the number of dimensions of the array.
            eg new object[4,5] returns 2
            </summary>
        </member>
        <member name="P:Debugger.Value.ArrayDimensions">
            <summary> Gets the dimensions of the array  </summary>
        </member>
        <member name="M:Debugger.Value.GetArrayElement(System.Int32)">
            <summary> Returns an element of a single-dimensional array </summary>
        </member>
        <member name="M:Debugger.Value.GetArrayElement(System.Int32[])">
            <summary> Returns an element of an array </summary>
        </member>
        <member name="M:Debugger.Value.GetArrayElements">
            <summary> Returns all elements in the array </summary>
        </member>
        <member name="P:Debugger.Value.Expression">
            <summary> Expression which can be used to reobtain this value. </summary>
        </member>
        <member name="P:Debugger.Value.IsNull">
            <summary> Returns true if the value is null </summary>
        </member>
        <member name="P:Debugger.Value.AsString">
            <summary> Gets a string representation of the value </summary>
        </member>
        <member name="P:Debugger.Value.Process">
            <summary> The process that owns the value </summary>
        </member>
        <member name="P:Debugger.Value.IsInvalid">
            <summary> Returns true if the Value can not be used anymore.
            Value is valid only until the debuggee is resummed. </summary>
        </member>
        <member name="P:Debugger.Value.Address">
            <summary>
            Gets the address in memory where this value is stored
            </summary>
        </member>
        <member name="P:Debugger.Value.IsReference">
            <summary> Gets value indication whether the value is a reference </summary>
            <remarks> Value types also return true if they are boxed </remarks>
        </member>
        <member name="P:Debugger.Value.Type">
            <summary> Returns the <see cref="!:Debugger.DebugType"/> of the value </summary>
        </member>
        <member name="M:Debugger.Value.Dereference">
            <summary> Dereferences a pointer type </summary>
            <returns> Returns null for a null pointer </returns>
        </member>
        <member name="M:Debugger.Value.SetValue(Debugger.Value)">
            <summary> Copy the acutal value from some other Value object </summary>
        </member>
        <member name="M:Debugger.Value.GetMemberValue(Debugger.MetaData.MemberInfo)">
            <summary> Get the value of given member. </summary>
        </member>
        <member name="M:Debugger.Value.GetMemberValue(Debugger.MetaData.MemberInfo,Debugger.Value[])">
            <summary> Get the value of given member. </summary>
        </member>
        <member name="M:Debugger.Value.GetMemberValue(Debugger.Value,Debugger.MetaData.MemberInfo,Debugger.Value[])">
            <summary> Get the value of given member. </summary>
            <param name="objectInstance">null if member is static</param>
        </member>
        <member name="M:Debugger.Value.GetFieldValue(Debugger.MetaData.FieldInfo)">
            <summary> Get the value of given field. </summary>
        </member>
        <member name="M:Debugger.Value.GetFieldValue(Debugger.Value,Debugger.MetaData.FieldInfo)">
            <summary> Get the value of given field. </summary>
            <param name="objectInstance">null if field is static</param>
        </member>
        <member name="M:Debugger.Value.GetPropertyValue(Debugger.MetaData.PropertyInfo)">
            <summary> Get the value of the property using the get accessor </summary>
        </member>
        <member name="M:Debugger.Value.GetPropertyValue(Debugger.MetaData.PropertyInfo,Debugger.Value[])">
            <summary> Get the value of the property using the get accessor </summary>
        </member>
        <member name="M:Debugger.Value.GetPropertyValue(Debugger.Value,Debugger.MetaData.PropertyInfo)">
            <summary> Get the value of the property using the get accessor </summary>
        </member>
        <member name="M:Debugger.Value.GetPropertyValue(Debugger.Value,Debugger.MetaData.PropertyInfo,Debugger.Value[])">
            <summary> Get the value of the property using the get accessor </summary>
        </member>
        <member name="M:Debugger.Value.SetPropertyValue(Debugger.MetaData.PropertyInfo,Debugger.Value)">
            <summary> Set the value of the property using the set accessor </summary>
        </member>
        <member name="M:Debugger.Value.SetPropertyValue(Debugger.MetaData.PropertyInfo,Debugger.Value[],Debugger.Value)">
            <summary> Set the value of the property using the set accessor </summary>
        </member>
        <member name="M:Debugger.Value.SetPropertyValue(Debugger.Value,Debugger.MetaData.PropertyInfo,Debugger.Value)">
            <summary> Set the value of the property using the set accessor </summary>
        </member>
        <member name="M:Debugger.Value.SetPropertyValue(Debugger.Value,Debugger.MetaData.PropertyInfo,Debugger.Value[],Debugger.Value)">
            <summary> Set the value of the property using the set accessor </summary>
        </member>
        <member name="M:Debugger.Value.InvokeMethod(Debugger.MetaData.MethodInfo,Debugger.Value[])">
            <summary> Synchronously invoke the method </summary>
        </member>
        <member name="M:Debugger.Value.InvokeMethod(Debugger.Value,Debugger.MetaData.MethodInfo,Debugger.Value[])">
            <summary> Synchronously invoke the method </summary>
        </member>
        <member name="M:Debugger.Value.InvokeToString">
            <summary> Invoke the ToString() method </summary>
        </member>
        <member name="M:Debugger.Value.AsyncInvokeMethod(Debugger.MetaData.MethodInfo,Debugger.Value[])">
            <summary> Asynchronously invoke the method </summary>
        </member>
        <member name="M:Debugger.Value.AsyncInvokeMethod(Debugger.Value,Debugger.MetaData.MethodInfo,Debugger.Value[])">
            <summary> Asynchronously invoke the method </summary>
        </member>
        <member name="M:Debugger.Value.GetMemberValue(System.String)">
            <summary> Get a field or property of an object with a given name. </summary>
            <returns> Null if not found </returns>
        </member>
        <member name="M:Debugger.Value.GetMemberValues">
            <summary> Get all fields and properties of an object. </summary>
        </member>
        <member name="M:Debugger.Value.GetMemberValues(Debugger.MetaData.BindingFlags)">
            <summary>
            Get fields and properties of an object which are defined by a given type.
            </summary>
            <param name="type"> Limit to type, null for all types </param>
            <param name="bindingFlags"> Get only members with certain flags </param>
        </member>
        <member name="P:Debugger.Value.PrimitiveValue">
            <summary>
            Gets or sets the value of a primitive type.
            
            If setting of a value fails, NotSupportedException is thrown.
            </summary>
        </member>
        <member name="P:Debugger.GetValueException.Expression">
            <summary> Expression that has caused this exception to occur </summary>
        </member>
        <member name="T:ikvm.debugger.Debugger">
            <summary>
            This is the start class of the debugger.
            </summary>
        </member>
        <member name="M:ikvm.debugger.DebuggerUtils.ReadFully(System.IO.Stream,System.Byte[])">
            <summary>
            Read the buffer full. 
            </summary>
            <param name="stream">the stream to read</param>
            <param name="buffer">the buffer that should be fill</param>
            <exception cref="T:System.IO.IOException">
            If the stream ends.
            </exception>
        </member>
        <member name="M:ikvm.debugger.DebuggerUtils.ConvertJniClassName(System.String)">
            <summary>
            Convert a JNI signature of the class (for example, "Ljava/lang/String;").   
            </summary>
            <param name="jniName"></param>
            <returns></returns>
        </member>
        <member name="T:ikvm.debugger.requests.EventRequest">
            <summary>
            http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_EventRequest
            </summary>
        </member>
        <member name="M:ikvm.debugger.requests.EventRequest.create(ikvm.debugger.Packet)">
            <summary>
            Create a new EventRequest with the data in the Packet
            </summary>
            <param name="packet">a data packet send from the Java debugger</param>
            <returns>a new packet or null if there are some unknown types.</returns>
        </member>
        <member name="T:ikvm.debugger.requests.CountEventModifier">
            <summary>
            Limit the requested event to be reported at most once after a given number of occurrences. 
            The event is not reported the first count - 1 times this filter is reached. 
            To request a one-off event, call this method with a count of 1.
            
            Once the count reaches 0, any subsequent filters in this request are applied. 
            If none of those filters cause the event to be suppressed, the event is reported. 
            Otherwise, the event is not reported. In either case subsequent events are never reported 
            for this request. This modifier can be used with any event kind.  
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.CountEventModifier.count">
            <summary>
            Count before event. One for one-off.  
            </summary>
        </member>
        <member name="T:ikvm.debugger.requests.ConditionalEventModifier">
            <summary>
            Conditional on expression  
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.ConditionalEventModifier.exprID">
            <summary>
            For the future
            </summary>
        </member>
        <member name="T:ikvm.debugger.requests.ThreadOnlyEventModifier">
            <summary>
            Restricts reported events to those in the given thread. 
            This modifier can be used with any event kind except for class unload.   
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.ThreadOnlyEventModifier.threadID">
            <summary>
            Required thread
            </summary>
        </member>
        <member name="T:ikvm.debugger.requests.ClassOnlyEventModifier">
            <summary>
            For class prepare events, restricts the events generated by this request to be the preparation 
            of the given reference type and any subtypes. For monitor wait and waited events, 
            restricts the events generated by this request to those whose monitor object 
            is of the given reference type or any of its subtypes. For other events, 
            restricts the events generated by this request to those whose location is 
            in the given reference type or any of its subtypes. An event will be generated 
            for any location in a reference type that can be safely cast to the given reference type. 
            This modifier can be used with any event kind except class unload, thread start, and thread end.
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.ClassOnlyEventModifier.classID">
            <summary>
            Required class
            </summary>
        </member>
        <member name="T:ikvm.debugger.requests.ClassMatchEventModifier">
            <summary>
            Restricts reported events to those for classes whose name matches the given restricted 
            regular expression. For class prepare events, the prepared class name is matched. 
            For class unload events, the unloaded class name is matched. For monitor wait and waited events, 
            the name of the class of the monitor object is matched. For other events, 
            the class name of the event's location is matched. 
            This modifier can be used with any event kind except thread start and thread end.
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.ClassMatchEventModifier.classPattern">
            <summary>
            Required class pattern. Matches are limited to exact matches of the given class pattern 
            and matches of patterns that begin or end with '*'; for example, "*.Foo" or "java.*".
            </summary>
        </member>
        <member name="T:ikvm.debugger.requests.ClassExcludeEventModifier">
            <summary>
            Restricts reported events to those for classes whose name does not match the given 
            restricted regular expression. For class prepare events, the prepared class name is matched. 
            For class unload events, the unloaded class name is matched. For monitor wait and waited events, 
            the name of the class of the monitor object is matched. For other events, 
            the class name of the event's location is matched. 
            This modifier can be used with any event kind except thread start and thread end.
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.ClassExcludeEventModifier.classPattern">
            <summary>
            Disallowed class pattern. Matches are limited to exact matches of the given class pattern 
            and matches of patterns that begin or end with '*'; for example, "*.Foo" or "java.*".
            </summary>
        </member>
        <member name="T:ikvm.debugger.requests.LocationOnlyEventModifier">
            <summary>
            Restricts reported events to those that occur at the given location. This modifier can be used 
            with breakpoint, field access, field modification, step, and exception event kinds.
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.LocationOnlyEventModifier.location">
            <summary>
            Required location
            </summary>
        </member>
        <member name="T:ikvm.debugger.requests.ExceptionOnlyEventModifier">
            <summary>
            Restricts reported exceptions by their class and whether they are caught or uncaught. 
            This modifier can be used with exception event kinds only.
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.ExceptionOnlyEventModifier.refTypeID">
            <summary>
            Exception to report. Null (0) means report exceptions of all types. A non-null type 
            restricts the reported exception events to exceptions of the given type or any of its subtypes.
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.ExceptionOnlyEventModifier.caught">
            <summary>
            Report caught exceptions
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.ExceptionOnlyEventModifier.uncaught">
            <summary>
            Report uncaught exceptions. Note that it is not always possible to determine 
            whether an exception is caught or uncaught at the time it is thrown. 
            See the exception event catch location under composite events for more information.
            http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_Event_Composite
            </summary>
        </member>
        <member name="T:ikvm.debugger.requests.FieldOnlyEventModifier">
            <summary>
            Restricts reported events to those that occur for a given field. 
            This modifier can be used with field access and field modification event kinds only.
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.FieldOnlyEventModifier.refTypeID">
            <summary>
            Type in which field is declared.
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.FieldOnlyEventModifier.fieldID">
            <summary>
            Required field
            </summary>
        </member>
        <member name="T:ikvm.debugger.requests.StepEventModifier">
            <summary>
            Restricts reported step events to those which satisfy depth and size constraints. 
            This modifier can be used with step event kinds only.
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.StepEventModifier.threadID">
            <summary>
            Thread in which to step
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.StepEventModifier.size">
            <summary>
            size of each step. See class StepSize
            </summary>
            <see cref="T:ikvm.debugger.StepSize"/>
        </member>
        <member name="F:ikvm.debugger.requests.StepEventModifier.depth">
            <summary>
            relative call stack limit. See class StepDepth  
            </summary>
            <see cref="T:ikvm.debugger.StepDepth"/>
        </member>
        <member name="T:ikvm.debugger.requests.InstanceOnlyEventModifier">
            <summary>
            Restricts reported events to those whose active 'this' object is the given object. 
            Match value is the null object for static methods. 
            This modifier can be used with any event kind except class prepare, 
            class unload, thread start, and thread end. Introduced in JDWP version 1.4.
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.InstanceOnlyEventModifier.instanceID">
            <summary>
            Required 'this' object
            </summary>
        </member>
        <member name="T:ikvm.debugger.requests.SourceNameMatchEventModifier">
            <summary>
            Restricts reported class prepare events to those for reference types 
            which have a source name which matches the given restricted regular expression. 
            The source names are determined by the reference type's  SourceDebugExtension. 
            http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_ReferenceType_SourceDebugExtension
            This modifier can only be used with class prepare events. 
            Since JDWP version 1.6. Requires the canUseSourceNameFilters capability - see CapabilitiesNew.
            http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_VirtualMachine_CapabilitiesNew
            </summary>
        </member>
        <member name="F:ikvm.debugger.requests.SourceNameMatchEventModifier.sourceNamePattern">
            <summary>
            Required source name pattern. Matches are limited to exact matches of the given pattern and matches of patterns 
            that begin or end with '*'; for example, "*.Foo" or "java.*".   
            </summary>
        </member>
        <member name="F:ikvm.debugger.JdwpConnection.readHeader">
            <summary>
            Shared buffer for reading and monitor for reading
            </summary>
        </member>
        <member name="T:ikvm.debugger.StepDepth">
            <summary>
            http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_StepDepth
            </summary>
        </member>
        <member name="F:ikvm.debugger.StepDepth.INTO">
            <summary>
            Step into any method calls that occur before the end of the step.
            </summary>
        </member>
        <member name="F:ikvm.debugger.StepDepth.OVER">
            <summary>
            Step over any method calls that occur before the end of the step.
            </summary>
        </member>
        <member name="F:ikvm.debugger.StepDepth.OUT">
            <summary>
            Step out of the current method.
            </summary>
        </member>
        <member name="T:ikvm.debugger.StepSize">
            <summary>
            http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_StepSize
            </summary>
        </member>
        <member name="F:ikvm.debugger.StepSize.MIN">
            <summary>
            Step by the minimum possible amount (often a bytecode instruction).   
            </summary>
        </member>
        <member name="F:ikvm.debugger.StepSize.LINE">
            <summary>
            Step to the next source line unless there is no line number information in which case a MIN step is done instead.
            </summary>
        </member>
        <member name="T:ikvm.debugger.InvokeOptions">
            <summary>
            The invoke options are a combination of zero or more of the following bit flags:
            </summary>
        </member>
        <member name="T:ikvm.debugger.JdwpHandler">
            <summary>
            Implementation of the JDWP Protocol. The documentation is at:
            http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html
            </summary>
        </member>
        <member name="M:ikvm.debugger.JdwpHandler.CommandSetVirtualMachine(ikvm.debugger.Packet)">
            <summary>
            http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_VirtualMachine
            </summary>
            <param name="packet"></param>
        </member>
        <member name="M:ikvm.debugger.JdwpHandler.CommandSetReferenceType(ikvm.debugger.Packet)">
            <summary>
            http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_ReferenceType
            </summary>
            <param name="packet"></param>
        </member>
        <member name="M:ikvm.debugger.JdwpHandler.CommandSetEventRequest(ikvm.debugger.Packet)">
            <summary>
            http://java.sun.com/javase/6/docs/platform/jpda/jdwp/jdwp-protocol.html#JDWP_EventRequest
            </summary>
            <param name="packet"></param>
        </member>
        <member name="M:ikvm.debugger.JdwpParameters.Parse(System.String)">
            <summary>
            Parse the command line parameters. 
            Terminate the program if invalid or help parameter.
            </summary>
            <param name="command">a JDWP parameter</param>
        </member>
        <member name="P:ikvm.debugger.JdwpParameters.Server">
            <summary>
            If the debugger should listen as server.
            true - listen as server;
            false - connect to the debugger;
            </summary>
        </member>
        <member name="M:ikvm.debugger.JdwpParameters.Exit(System.Int32)">
            <summary>
            If a instance does not want exit the application then it must override this method.
            </summary>
            <param name="code">exit code</param>
        </member>
        <member name="M:ikvm.debugger.JdwpParameters.PrintHelp">
            <summary>
            Print the usage help to the console
            </summary>
        </member>
        <member name="T:ikvm.debugger.Packet">
            <summary>
            A JDWP Packet descriped at
            http://java.sun.com/javase/6/docs/technotes/guides/jpda/jdwp-spec.html
            </summary>
        </member>
        <member name="M:ikvm.debugger.Packet.#ctor">
            <summary>
            Private constructor, use the factory methods
            </summary>
        </member>
        <member name="M:ikvm.debugger.Packet.Read(System.Byte[],System.IO.Stream)">
            <summary>
            Create a packet from the stream.
            </summary>
            <param name="header">The first 11 bytes of the data.</param>
            <param name="stream">The stream with the data</param>
            <returns>a new Packet</returns>
            <exception cref="T:System.IO.IOException">If the data in the stream are invalid.</exception>
        </member>
        <member name="M:ikvm.debugger.Packet.CreateEventPacket">
            <summary>
            Create a empty packet to send an Event from the target VM (debuggee) to the debugger.
            </summary>
            <returns>a new packet</returns>
        </member>
        <member name="M:ikvm.debugger.Packet.Send(System.IO.Stream)">
            <summary>
            Is used from JdwpConnection. You should use jdwpConnection.Send(Packet).
            </summary>
            <param name="stream"></param>
        </member>
        <member name="T:ikvm.debugger.win.TargetVM">
            <summary>
            This class represent the target IKVM that should be debugged. The current implementation 
            based on Debugger.Core.dll from the SharpDevelop project.
            </summary>
        </member>
        <member name="M:ikvm.debugger.win.TargetVM.#ctor(System.Int32,ikvm.debugger.JdwpEventHandler)">
            <summary>
            Create a new target VM for the giveb process id.
            </summary>
            <param name="pid">Process ID of the IKVM</param>
        </member>
        <member name="M:ikvm.debugger.win.TargetVM.GetThreadIDs">
            <summary>
            Return a list of thread IDs 
            </summary>
            <returns>never null</returns>
        </member>
        <member name="M:ikvm.debugger.win.TargetVM.FindTypes(System.String)">
            <summary>
            Find all types with the given names that can currently loaded.
            If the module or depending modules was not loaded then a empty list return.
            </summary>
            <param name="jniClassName">a class name with JNI syntax.</param>
            <returns>the list, never null</returns>
        </member>
        <member name="M:ikvm.debugger.win.TargetVM.AddEventRequest(ikvm.debugger.requests.EventRequest)">
            <summary>
            Set an EventRequest received from debugger. 
            </summary>
            <param name="eventRequest">the new EventRequest</param>
        </member>
    </members>
</doc>
